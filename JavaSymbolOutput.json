{
  "ribbon\\ribbon\\src\\examples\\java\\com\\netflix\\ribbon\\RibbonExamples.java": {
    "TypeDeclarations": [
      "RibbonExamples"
    ],
    "MethodDeclarations": [
      "RibbonExamples.main(String)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "withResponseValidator",
        "code",
        "withFallbackProvider",
        "withHystrixProperties",
        "withUriTemplate",
        "build",
        "withRequestProperty",
        "build",
        "execute",
        "withRequestProperty",
        "build",
        "withMetadata",
        "observe",
        "flatMap",
        "isResponseFromFallback",
        "map"
      ]
    },
    "Imports": {
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "HttpClientResponse": "io.reactivex.netty.protocol.http.client.HttpClientResponse",
      "Map": "java.util.Map",
      "Observable": "rx.Observable",
      "Func1": "rx.functions.Func1",
      "HystrixCommandGroupKey": "com.netflix.hystrix.HystrixCommandGroupKey",
      "HystrixCommandProperties": "com.netflix.hystrix.HystrixCommandProperties",
      "HystrixInvokableInfo": "com.netflix.hystrix.HystrixInvokableInfo",
      "HystrixObservableCommand": "com.netflix.hystrix.HystrixObservableCommand",
      "HttpRequestTemplate": "com.netflix.ribbon.http.HttpRequestTemplate",
      "HttpResourceGroup": "com.netflix.ribbon.http.HttpResourceGroup",
      "FallbackHandler": "com.netflix.ribbon.hystrix.FallbackHandler"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\CacheProvider.java": {
    "TypeDeclarations": [
      "CacheProvider"
    ],
    "MethodDeclarations": [
      "CacheProvider.get(String, Map)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "Map": "java.util.Map",
      "RequestBuilder": "com.netflix.ribbon.RequestTemplate.RequestBuilder",
      "Observable": "rx.Observable"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\CacheProviderFactory.java": {
    "TypeDeclarations": [
      "CacheProviderFactory"
    ],
    "MethodDeclarations": [
      "CacheProviderFactory.createCacheProvider()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {},
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\ClientOptions.java": {
    "TypeDeclarations": [
      "ClientOptions"
    ],
    "MethodDeclarations": [
      "ClientOptions.create()",
      "ClientOptions.from(IClientConfig)",
      "ClientOptions.withDiscoveryServiceIdentifier(String)",
      "ClientOptions.withConfigurationBasedServerList(String)",
      "ClientOptions.withMaxAutoRetries(BasicType(dimensions=[], name=int))",
      "ClientOptions.withMaxAutoRetriesNextServer(BasicType(dimensions=[], name=int))",
      "ClientOptions.withRetryOnAllOperations(BasicType(dimensions=[], name=boolean))",
      "ClientOptions.withMaxConnectionsPerHost(BasicType(dimensions=[], name=int))",
      "ClientOptions.withMaxTotalConnections(BasicType(dimensions=[], name=int))",
      "ClientOptions.withConnectTimeout(BasicType(dimensions=[], name=int))",
      "ClientOptions.withReadTimeout(BasicType(dimensions=[], name=int))",
      "ClientOptions.withFollowRedirects(BasicType(dimensions=[], name=boolean))",
      "ClientOptions.withConnectionPoolIdleEvictTimeMilliseconds(BasicType(dimensions=[], name=int))",
      "ClientOptions.withLoadBalancerEnabled(BasicType(dimensions=[], name=boolean))",
      "ClientOptions.getOptions()"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.util.Map.put",
        "java.util.Map.put",
        "java.util.Map.put",
        "java.util.Map.put",
        "java.util.Map.put",
        "java.util.Map.put",
        "java.util.Map.put",
        "java.util.Map.put",
        "java.util.Map.put",
        "java.util.Map.put",
        "java.util.Map.put",
        "java.util.Map.put"
      ],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "IClientConfigKey": "com.netflix.client.config.IClientConfigKey",
      "Map": "java.util.Map",
      "ConcurrentHashMap": "java.util.concurrent.ConcurrentHashMap"
    },
    "FieldTypes": {
      "options": "java.util.Map"
    }
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\DefaultResourceFactory.java": {
    "TypeDeclarations": [
      "DefaultResourceFactory"
    ],
    "MethodDeclarations": [],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "ClientConfigFactory": "com.netflix.client.config.ClientConfigFactory",
      "AnnotationProcessorsProvider": "com.netflix.ribbon.proxy.processor.AnnotationProcessorsProvider",
      "Inject": "javax.inject.Inject"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\RequestTemplate.java": {
    "TypeDeclarations": [
      "RequestTemplate",
      "RequestBuilder"
    ],
    "MethodDeclarations": [
      "RequestTemplate.requestBuilder()",
      "RequestTemplate.name()",
      "RequestTemplate.copy(String)",
      "RequestBuilder.withRequestProperty(String, Object)",
      "RequestBuilder.build()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {},
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\RequestWithMetaData.java": {
    "TypeDeclarations": [
      "RequestWithMetaData"
    ],
    "MethodDeclarations": [
      "RequestWithMetaData.observe()",
      "RequestWithMetaData.toObservable()",
      "RequestWithMetaData.queue()",
      "RequestWithMetaData.execute()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "Future": "java.util.concurrent.Future",
      "Observable": "rx.Observable"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\ResourceGroup.java": {
    "TypeDeclarations": [
      "ResourceGroup",
      "GroupBuilder",
      "TemplateBuilder"
    ],
    "MethodDeclarations": [
      "GroupBuilder.build()",
      "GroupBuilder.withClientOptions(ClientOptions)",
      "TemplateBuilder.withFallbackProvider(FallbackHandler)",
      "TemplateBuilder.withResponseValidator(ResponseValidator)",
      "TemplateBuilder.withRequestCacheKey(String)",
      "TemplateBuilder.withCacheProvider(String, CacheProvider)",
      "TemplateBuilder.withHystrixProperties(HystrixObservableCommand)",
      "TemplateBuilder.build()",
      "ResourceGroup.getClientConfig()",
      "ResourceGroup.name()",
      "ResourceGroup.newTemplateBuilder(String, Class)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "com.netflix.client.config.ClientConfigFactory.newConfig",
        "com.netflix.client.config.IClientConfig.loadProperties",
        "keySet",
        "com.netflix.client.config.IClientConfig.set",
        "get"
      ]
    },
    "Imports": {
      "ClientConfigFactory": "com.netflix.client.config.ClientConfigFactory",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "IClientConfigKey": "com.netflix.client.config.IClientConfigKey",
      "HystrixObservableCommand": "com.netflix.hystrix.HystrixObservableCommand",
      "FallbackHandler": "com.netflix.ribbon.hystrix.FallbackHandler"
    },
    "FieldTypes": {
      "clientConfig": "com.netflix.client.config.IClientConfig",
      "configFactory": "com.netflix.client.config.ClientConfigFactory"
    }
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\ResponseValidator.java": {
    "TypeDeclarations": [
      "ResponseValidator"
    ],
    "MethodDeclarations": [
      "ResponseValidator.validate(T)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "HttpClientResponse": "io.reactivex.netty.protocol.http.client.HttpClientResponse"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\Ribbon.java": {
    "TypeDeclarations": [
      "Ribbon"
    ],
    "MethodDeclarations": [
      "Ribbon.createHttpResourceGroupBuilder(String)",
      "Ribbon.createHttpResourceGroup(String)",
      "Ribbon.createHttpResourceGroup(String, ClientOptions)",
      "Ribbon.from(Class)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "ClientConfigFactory": "com.netflix.client.config.ClientConfigFactory",
      "HttpResourceGroup": "com.netflix.ribbon.http.HttpResourceGroup",
      "Builder": "com.netflix.ribbon.http.HttpResourceGroup.Builder",
      "AnnotationProcessorsProvider": "com.netflix.ribbon.proxy.processor.AnnotationProcessorsProvider"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\RibbonRequest.java": {
    "TypeDeclarations": [
      "RibbonRequest"
    ],
    "MethodDeclarations": [
      "RibbonRequest.execute()",
      "RibbonRequest.queue()",
      "RibbonRequest.observe()",
      "RibbonRequest.toObservable()",
      "RibbonRequest.withMetadata()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "Future": "java.util.concurrent.Future",
      "Observable": "rx.Observable"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\RibbonResourceFactory.java": {
    "TypeDeclarations": [
      "RibbonResourceFactory"
    ],
    "MethodDeclarations": [
      "RibbonResourceFactory.createHttpResourceGroupBuilder(String)",
      "RibbonResourceFactory.createHttpResourceGroup(String)",
      "RibbonResourceFactory.from(Class)",
      "RibbonResourceFactory.createHttpResourceGroup(String, ClientOptions)",
      "RibbonResourceFactory.getTransportFactory()",
      "RibbonResourceFactory.getClientConfigFactory()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "RibbonResourceFactory.createHttpResourceGroupBuilder",
        "RibbonResourceFactory.createHttpResourceGroupBuilder"
      ],
      "Unresolved": []
    },
    "Imports": {
      "ClientConfigFactory": "com.netflix.client.config.ClientConfigFactory",
      "HttpResourceGroup": "com.netflix.ribbon.http.HttpResourceGroup",
      "Builder": "com.netflix.ribbon.http.HttpResourceGroup.Builder",
      "RibbonDynamicProxy": "com.netflix.ribbon.proxy.RibbonDynamicProxy",
      "AnnotationProcessorsProvider": "com.netflix.ribbon.proxy.processor.AnnotationProcessorsProvider"
    },
    "FieldTypes": {
      "clientConfigFactory": "com.netflix.client.config.ClientConfigFactory",
      "annotationProcessors": "com.netflix.ribbon.proxy.processor.AnnotationProcessorsProvider"
    }
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\RibbonResponse.java": {
    "TypeDeclarations": [
      "RibbonResponse"
    ],
    "MethodDeclarations": [
      "RibbonResponse.content()",
      "RibbonResponse.getHystrixInfo()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "HystrixInvokableInfo": "com.netflix.hystrix.HystrixInvokableInfo"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\ServerError.java": {
    "TypeDeclarations": [
      "ServerError"
    ],
    "MethodDeclarations": [],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {},
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\UnsuccessfulResponseException.java": {
    "TypeDeclarations": [
      "UnsuccessfulResponseException"
    ],
    "MethodDeclarations": [],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {},
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\http\\HttpMetaRequest.java": {
    "TypeDeclarations": [
      "HttpMetaRequest",
      "ResponseWithSubject"
    ],
    "MethodDeclarations": [
      "ResponseWithSubject.content()",
      "ResponseWithSubject.getHystrixInfo()",
      "HttpMetaRequest.toObservable()",
      "HttpMetaRequest.observe()",
      "HttpMetaRequest.queue()",
      "HttpMetaRequest.execute()",
      "HttpMetaRequest.retainBufferIfNeeded(Observable)",
      "HttpMetaRequest.convertToRibbonResponse(HystrixObservableCommandChain, Observable)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "convertToRibbonResponse",
        "retainBufferIfNeeded",
        "convertToRibbonResponse",
        "toResultCommandPairObservable",
        "retainBufferIfNeeded",
        "toFuture",
        "observe",
        "toBlocking",
        "last",
        "toBlocking",
        "last",
        "subscribe",
        "java.util.concurrent.atomic.AtomicBoolean.compareAndSet",
        "getCommand",
        "rx.subjects.Subject.onNext",
        "getResult",
        "rx.subjects.Subject.onCompleted",
        "rx.subjects.Subject.onError"
      ]
    },
    "Imports": {
      "HystrixInvokableInfo": "com.netflix.hystrix.HystrixInvokableInfo",
      "HystrixObservableCommand": "com.netflix.hystrix.HystrixObservableCommand",
      "RequestWithMetaData": "com.netflix.ribbon.RequestWithMetaData",
      "RibbonResponse": "com.netflix.ribbon.RibbonResponse",
      "HystrixObservableCommandChain": "com.netflix.ribbon.hystrix.HystrixObservableCommandChain",
      "ResultCommandPair": "com.netflix.ribbon.hystrix.ResultCommandPair",
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "Notification": "rx.Notification",
      "Observable": "rx.Observable",
      "OnSubscribe": "rx.Observable.OnSubscribe",
      "Subscriber": "rx.Subscriber",
      "Action1": "rx.functions.Action1",
      "Func1": "rx.functions.Func1",
      "ReplaySubject": "rx.subjects.ReplaySubject",
      "Subject": "rx.subjects.Subject",
      "ExecutionException": "java.util.concurrent.ExecutionException",
      "Future": "java.util.concurrent.Future",
      "TimeUnit": "java.util.concurrent.TimeUnit",
      "TimeoutException": "java.util.concurrent.TimeoutException",
      "AtomicBoolean": "java.util.concurrent.atomic.AtomicBoolean"
    },
    "FieldTypes": {
      "subject": "rx.subjects.Subject",
      "info": "com.netflix.hystrix.HystrixInvokableInfo",
      "first": "java.util.concurrent.atomic.AtomicBoolean"
    }
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\http\\HttpMetaResponse.java": {
    "TypeDeclarations": [
      "HttpMetaResponse"
    ],
    "MethodDeclarations": [
      "HttpMetaResponse.content()",
      "HttpMetaResponse.getHystrixInfo()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "HystrixInvokableInfo": "com.netflix.hystrix.HystrixInvokableInfo",
      "RibbonResponse": "com.netflix.ribbon.RibbonResponse"
    },
    "FieldTypes": {
      "hystrixInfo": "com.netflix.hystrix.HystrixInvokableInfo"
    }
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\http\\HttpRequest.java": {
    "TypeDeclarations": [
      "HttpRequest",
      "CacheProviderWithKey"
    ],
    "MethodDeclarations": [
      "CacheProviderWithKey.getCacheProvider()",
      "CacheProviderWithKey.getKey()",
      "HttpRequest.createHystrixCommandChain()",
      "HttpRequest.toObservable()",
      "HttpRequest.execute()",
      "HttpRequest.queue()",
      "HttpRequest.observe()",
      "HttpRequest.withMetadata()",
      "HttpRequest.isByteBufResponse()",
      "HttpRequest.getObservable()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "getClient",
        "getProvider",
        "getKeyTemplate",
        "isAssignableFrom",
        "com.netflix.ribbon.CacheProvider.getCacheProvider",
        "com.netflix.ribbon.CacheProvider.getKey",
        "createHystrixCommandChain",
        "toObservable",
        "getObservable",
        "toBlocking",
        "last",
        "getObservable",
        "toBlocking",
        "toFuture",
        "getObservable",
        "subscribe",
        "isAssignableFrom",
        "isByteBufResponse",
        "toObservable",
        "toObservable"
      ]
    },
    "Imports": {
      "HystrixObservableCommand": "com.netflix.hystrix.HystrixObservableCommand",
      "CacheProvider": "com.netflix.ribbon.CacheProvider",
      "RequestWithMetaData": "com.netflix.ribbon.RequestWithMetaData",
      "RibbonRequest": "com.netflix.ribbon.RibbonRequest",
      "CacheObservableCommand": "com.netflix.ribbon.hystrix.CacheObservableCommand",
      "HystrixObservableCommandChain": "com.netflix.ribbon.hystrix.HystrixObservableCommandChain",
      "TemplateParser": "com.netflix.ribbon.template.TemplateParser",
      "TemplateParsingException": "com.netflix.ribbon.template.TemplateParsingException",
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "HttpClient": "io.reactivex.netty.protocol.http.client.HttpClient",
      "HttpClientRequest": "io.reactivex.netty.protocol.http.client.HttpClientRequest",
      "Observable": "rx.Observable",
      "Func1": "rx.functions.Func1",
      "ReplaySubject": "rx.subjects.ReplaySubject",
      "ArrayList": "java.util.ArrayList",
      "HashMap": "java.util.HashMap",
      "List": "java.util.List",
      "Map": "java.util.Map",
      "Future": "java.util.concurrent.Future"
    },
    "FieldTypes": {
      "cacheProvider": "com.netflix.ribbon.CacheProvider",
      "refCountIncrementer": "rx.functions.Func1",
      "httpRequest": "io.reactivex.netty.protocol.http.client.HttpClientRequest",
      "requestProperties": "java.util.Map",
      "client": "io.reactivex.netty.protocol.http.client.HttpClient"
    }
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\http\\HttpRequestBuilder.java": {
    "TypeDeclarations": [
      "HttpRequestBuilder"
    ],
    "MethodDeclarations": [
      "HttpRequestBuilder.withRequestProperty(String, Object)",
      "HttpRequestBuilder.withRawContentSource(Observable, ContentTransformer)",
      "HttpRequestBuilder.withContent(Observable)",
      "HttpRequestBuilder.withHeader(String, String)",
      "HttpRequestBuilder.build()",
      "HttpRequestBuilder.createClientRequest()",
      "HttpRequestBuilder.hystrixCacheKey()",
      "HttpRequestBuilder.requestProperties()",
      "HttpRequestBuilder.cacheProvider()",
      "HttpRequestBuilder.template()"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.util.Map.put",
        "java.util.Map.put",
        "java.util.Map.entrySet"
      ],
      "UserDefined": [],
      "Unresolved": [
        "com.netflix.ribbon.template.ParsedTemplate.getTemplate",
        "com.netflix.ribbon.template.ParsedTemplate.getParsed",
        "entries",
        "length"
      ]
    },
    "Imports": {
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "ByteBufAllocator": "io.netty.buffer.ByteBufAllocator",
      "ContentTransformer": "io.reactivex.netty.channel.ContentTransformer",
      "HttpClientRequest": "io.reactivex.netty.protocol.http.client.HttpClientRequest",
      "HashMap": "java.util.HashMap",
      "Map": "java.util.Map",
      "ConcurrentHashMap": "java.util.concurrent.ConcurrentHashMap",
      "Observable": "rx.Observable",
      "HystrixBadRequestException": "com.netflix.hystrix.exception.HystrixBadRequestException",
      "RequestBuilder": "com.netflix.ribbon.RequestTemplate.RequestBuilder",
      "RibbonRequest": "com.netflix.ribbon.RibbonRequest",
      "CacheProviderWithKeyTemplate": "com.netflix.ribbon.http.HttpRequestTemplate.CacheProviderWithKeyTemplate",
      "ParsedTemplate": "com.netflix.ribbon.template.ParsedTemplate",
      "TemplateParser": "com.netflix.ribbon.template.TemplateParser",
      "TemplateParsingException": "com.netflix.ribbon.template.TemplateParsingException"
    },
    "FieldTypes": {
      "vars": "java.util.Map",
      "parsedUriTemplate": "com.netflix.ribbon.template.ParsedTemplate",
      "rawContentSource": "rx.Observable",
      "contentTransformer": "io.reactivex.netty.channel.ContentTransformer",
      "extraHeaders": "java.util.Map",
      "passThroughContentTransformer": "io.reactivex.netty.channel.ContentTransformer"
    }
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\http\\HttpRequestTemplate.java": {
    "TypeDeclarations": [
      "HttpRequestTemplate",
      "Builder",
      "CacheProviderWithKeyTemplate"
    ],
    "MethodDeclarations": [
      "Builder.createParsedTemplate(String)",
      "Builder.newBuilder(String, HttpResourceGroup, Class)",
      "Builder.withFallbackProvider(FallbackHandler)",
      "Builder.withResponseValidator(ResponseValidator)",
      "Builder.withMethod(String)",
      "Builder.withUriTemplate(String)",
      "Builder.withRequestCacheKey(String)",
      "Builder.withCacheProvider(String, CacheProvider)",
      "Builder.withHeader(String, String)",
      "Builder.withHystrixProperties(Setter)",
      "Builder.build()",
      "CacheProviderWithKeyTemplate.getKeyTemplate()",
      "CacheProviderWithKeyTemplate.getProvider()",
      "HttpRequestTemplate.requestBuilder()",
      "HttpRequestTemplate.hystrixCacheKeyTemplate()",
      "HttpRequestTemplate.cacheProvider()",
      "HttpRequestTemplate.responseValidator()",
      "HttpRequestTemplate.fallbackHandler()",
      "HttpRequestTemplate.uriTemplate()",
      "HttpRequestTemplate.method()",
      "HttpRequestTemplate.getClassType()",
      "HttpRequestTemplate.getHeaders()",
      "HttpRequestTemplate.name()",
      "HttpRequestTemplate.copy(String)",
      "HttpRequestTemplate.hystrixProperties()",
      "HttpRequestTemplate.cacheHystrixProperties()",
      "HttpRequestTemplate.getClient()"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.util.Map.get",
        "java.util.Map.put"
      ],
      "UserDefined": [],
      "Unresolved": [
        "io.netty.handler.codec.http.HttpHeaders.add",
        "createParsedTemplate",
        "createParsedTemplate",
        "createParsedTemplate",
        "io.netty.handler.codec.http.HttpHeaders.add",
        "andCommandKey",
        "com.netflix.hystrix.HystrixObservableCommand.Setter.Setter",
        "com.netflix.hystrix.HystrixObservableCommand.andCommandPropertiesDefaults",
        "andCommandKey",
        "name",
        "io.reactivex.netty.protocol.http.client.HttpClient.name",
        "com.netflix.hystrix.HystrixObservableCommand.Setter.Setter",
        "andCommandPropertiesDefaults"
      ]
    },
    "Imports": {
      "LoadBalancingRxClient": "com.netflix.ribbon.transport.netty.LoadBalancingRxClient",
      "HystrixCommandGroupKey": "com.netflix.hystrix.HystrixCommandGroupKey",
      "HystrixCommandKey": "com.netflix.hystrix.HystrixCommandKey",
      "HystrixCommandProperties": "com.netflix.hystrix.HystrixCommandProperties",
      "HystrixObservableCommand": "com.netflix.hystrix.HystrixObservableCommand",
      "Setter": "com.netflix.hystrix.HystrixObservableCommand.Setter",
      "CacheProvider": "com.netflix.ribbon.CacheProvider",
      "RequestTemplate": "com.netflix.ribbon.RequestTemplate",
      "TemplateBuilder": "com.netflix.ribbon.ResourceGroup.TemplateBuilder",
      "ResponseValidator": "com.netflix.ribbon.ResponseValidator",
      "FallbackHandler": "com.netflix.ribbon.hystrix.FallbackHandler",
      "ParsedTemplate": "com.netflix.ribbon.template.ParsedTemplate",
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "DefaultHttpHeaders": "io.netty.handler.codec.http.DefaultHttpHeaders",
      "HttpHeaders": "io.netty.handler.codec.http.HttpHeaders",
      "HttpMethod": "io.netty.handler.codec.http.HttpMethod",
      "HttpClient": "io.reactivex.netty.protocol.http.client.HttpClient",
      "HttpClientResponse": "io.reactivex.netty.protocol.http.client.HttpClientResponse",
      "HashMap": "java.util.HashMap",
      "Map": "java.util.Map"
    },
    "FieldTypes": {
      "fallbackHandler": "com.netflix.ribbon.hystrix.FallbackHandler",
      "method": "io.netty.handler.codec.http.HttpMethod",
      "parsedUriTemplate": "com.netflix.ribbon.template.ParsedTemplate",
      "cacheKeyTemplate": "com.netflix.ribbon.template.ParsedTemplate",
      "headers": "io.netty.handler.codec.http.HttpHeaders",
      "setter": "com.netflix.hystrix.HystrixObservableCommand",
      "parsedTemplates": "java.util.Map",
      "validator": "com.netflix.ribbon.ResponseValidator",
      "client": "io.reactivex.netty.protocol.http.client.HttpClient",
      "cacheSetter": "com.netflix.hystrix.HystrixObservableCommand",
      "hystrixCacheKeyTemplate": "com.netflix.ribbon.template.ParsedTemplate",
      "keyTemplate": "com.netflix.ribbon.template.ParsedTemplate",
      "provider": "com.netflix.ribbon.CacheProvider"
    }
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\http\\HttpResourceGroup.java": {
    "TypeDeclarations": [
      "HttpResourceGroup",
      "Builder"
    ],
    "MethodDeclarations": [
      "Builder.newBuilder(String, ClientConfigFactory, RibbonTransportFactory)",
      "Builder.withClientOptions(ClientOptions)",
      "Builder.withHeader(String, String)",
      "Builder.build()",
      "HttpResourceGroup.newTemplateBuilder(String, Class)",
      "HttpResourceGroup.newTemplateBuilder(String)",
      "HttpResourceGroup.getHeaders()",
      "HttpResourceGroup.getClient()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "io.netty.handler.codec.http.HttpHeaders.add",
        "com.netflix.ribbon.RibbonTransportFactory.newHttpClient",
        "getClientConfig",
        "com.netflix.ribbon.RibbonTransportFactory.newHttpClient",
        "getClientConfig"
      ]
    },
    "Imports": {
      "ClientConfigFactory": "com.netflix.client.config.ClientConfigFactory",
      "ClientOptions": "com.netflix.ribbon.ClientOptions",
      "ResourceGroup": "com.netflix.ribbon.ResourceGroup",
      "RibbonTransportFactory": "com.netflix.ribbon.RibbonTransportFactory",
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "DefaultHttpHeaders": "io.netty.handler.codec.http.DefaultHttpHeaders",
      "HttpHeaders": "io.netty.handler.codec.http.HttpHeaders",
      "HttpClient": "io.reactivex.netty.protocol.http.client.HttpClient"
    },
    "FieldTypes": {
      "client": "io.reactivex.netty.protocol.http.client.HttpClient",
      "headers": "io.netty.handler.codec.http.HttpHeaders",
      "clientOptions": "com.netflix.ribbon.ClientOptions",
      "httpHeaders": "io.netty.handler.codec.http.HttpHeaders",
      "clientConfigFactory": "com.netflix.client.config.ClientConfigFactory",
      "transportFactory": "com.netflix.ribbon.RibbonTransportFactory"
    }
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\http\\HttpResourceObservableCommand.java": {
    "TypeDeclarations": [
      "HttpResourceObservableCommand"
    ],
    "MethodDeclarations": [
      "HttpResourceObservableCommand.getCacheKey()",
      "HttpResourceObservableCommand.resumeWithFallback()",
      "HttpResourceObservableCommand.construct()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "com.netflix.ribbon.hystrix.FallbackHandler.getFallback",
        "io.reactivex.netty.protocol.http.client.HttpClient.submit",
        "com.netflix.ribbon.ResponseValidator.validate",
        "map"
      ]
    },
    "Imports": {
      "HystrixObservableCommand": "com.netflix.hystrix.HystrixObservableCommand",
      "HystrixBadRequestException": "com.netflix.hystrix.exception.HystrixBadRequestException",
      "ResponseValidator": "com.netflix.ribbon.ResponseValidator",
      "ServerError": "com.netflix.ribbon.ServerError",
      "UnsuccessfulResponseException": "com.netflix.ribbon.UnsuccessfulResponseException",
      "FallbackHandler": "com.netflix.ribbon.hystrix.FallbackHandler",
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "HttpClient": "io.reactivex.netty.protocol.http.client.HttpClient",
      "HttpClientRequest": "io.reactivex.netty.protocol.http.client.HttpClientRequest",
      "HttpClientResponse": "io.reactivex.netty.protocol.http.client.HttpClientResponse",
      "Observable": "rx.Observable",
      "Func1": "rx.functions.Func1",
      "Map": "java.util.Map"
    },
    "FieldTypes": {
      "httpClient": "io.reactivex.netty.protocol.http.client.HttpClient",
      "httpRequest": "io.reactivex.netty.protocol.http.client.HttpClientRequest",
      "requestProperties": "java.util.Map",
      "fallbackHandler": "com.netflix.ribbon.hystrix.FallbackHandler",
      "validator": "com.netflix.ribbon.ResponseValidator"
    }
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\http\\HttpResponseValidator.java": {
    "TypeDeclarations": [
      "HttpResponseValidator"
    ],
    "MethodDeclarations": [],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "HttpClientResponse": "io.reactivex.netty.protocol.http.client.HttpClientResponse",
      "ResponseValidator": "com.netflix.ribbon.ResponseValidator"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\hystrix\\CacheObservableCommand.java": {
    "TypeDeclarations": [
      "CacheObservableCommand"
    ],
    "MethodDeclarations": [
      "CacheObservableCommand.getCacheKey()",
      "CacheObservableCommand.construct()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "com.netflix.ribbon.CacheProvider.get"
      ]
    },
    "Imports": {
      "Map": "java.util.Map",
      "Observable": "rx.Observable",
      "HystrixObservableCommand": "com.netflix.hystrix.HystrixObservableCommand",
      "CacheProvider": "com.netflix.ribbon.CacheProvider"
    },
    "FieldTypes": {
      "cacheProvider": "com.netflix.ribbon.CacheProvider",
      "requestProperties": "java.util.Map"
    }
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\hystrix\\FallbackHandler.java": {
    "TypeDeclarations": [
      "FallbackHandler"
    ],
    "MethodDeclarations": [
      "FallbackHandler.getFallback(HystrixInvokableInfo, Map)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "Map": "java.util.Map",
      "HystrixInvokableInfo": "com.netflix.hystrix.HystrixInvokableInfo",
      "Observable": "rx.Observable"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\hystrix\\HystrixObservableCommandChain.java": {
    "TypeDeclarations": [
      "HystrixObservableCommandChain"
    ],
    "MethodDeclarations": [
      "HystrixObservableCommandChain.toResultCommandPairObservable()",
      "HystrixObservableCommandChain.toObservable()",
      "HystrixObservableCommandChain.getCommands()",
      "HystrixObservableCommandChain.getLastCommand()"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.util.List.get",
        "java.util.List.size"
      ],
      "UserDefined": [],
      "Unresolved": [
        "map"
      ]
    },
    "Imports": {
      "HystrixObservableCommand": "com.netflix.hystrix.HystrixObservableCommand",
      "Observable": "rx.Observable",
      "Func1": "rx.functions.Func1",
      "ArrayList": "java.util.ArrayList",
      "Collections": "java.util.Collections",
      "List": "java.util.List"
    },
    "FieldTypes": {
      "hystrixCommands": "java.util.List"
    }
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\hystrix\\ResultCommandPair.java": {
    "TypeDeclarations": [
      "ResultCommandPair"
    ],
    "MethodDeclarations": [
      "ResultCommandPair.getResult()",
      "ResultCommandPair.getCommand()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "HystrixObservableCommand": "com.netflix.hystrix.HystrixObservableCommand"
    },
    "FieldTypes": {
      "command": "com.netflix.hystrix.HystrixObservableCommand"
    }
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\proxy\\ClassTemplate.java": {
    "TypeDeclarations": [
      "ClassTemplate"
    ],
    "MethodDeclarations": [
      "ClassTemplate.getClientInterface()",
      "ClassTemplate.getResourceGroupName()",
      "ClassTemplate.getResourceGroupClass()",
      "ClassTemplate.from(Class)",
      "ClassTemplate.verify()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "ClassTemplate.verify"
      ],
      "Unresolved": [
        "trim"
      ]
    },
    "Imports": {
      "HttpResourceGroup": "com.netflix.ribbon.http.HttpResourceGroup",
      "ResourceGroup": "com.netflix.ribbon.proxy.annotation.ResourceGroup"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\proxy\\MethodTemplate.java": {
    "TypeDeclarations": [
      "MethodTemplate",
      "CacheProviderEntry",
      "MethodAnnotationValues"
    ],
    "MethodDeclarations": [
      "MethodTemplate.getTemplateName()",
      "MethodTemplate.getMethod()",
      "MethodTemplate.getParamName(BasicType(dimensions=[], name=int))",
      "MethodTemplate.getParamPosition(BasicType(dimensions=[], name=int))",
      "MethodTemplate.getParamSize()",
      "MethodTemplate.getContentArgPosition()",
      "MethodTemplate.getContentTransformerClass()",
      "MethodTemplate.getResultType()",
      "MethodTemplate.getGenericContentType()",
      "MethodTemplate.from(Class)",
      "CacheProviderEntry.getKey()",
      "CacheProviderEntry.getCacheProvider()",
      "MethodAnnotationValues.extractParamNamesWithIndexes()",
      "MethodAnnotationValues.extractContentArgPosition()",
      "MethodAnnotationValues.extractContentTransformerClass()",
      "MethodAnnotationValues.extractTemplateName()",
      "MethodAnnotationValues.extractResultType()",
      "MethodAnnotationValues.methodName()"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.lang.equals",
        "java.lang.equals"
      ],
      "UserDefined": [
        "MethodAnnotationValues.extractTemplateName",
        "MethodAnnotationValues.extractParamNamesWithIndexes",
        "MethodAnnotationValues.extractContentArgPosition",
        "MethodAnnotationValues.extractContentTransformerClass",
        "MethodAnnotationValues.extractResultType",
        "java.lang.String.format",
        "MethodAnnotationValues.methodName",
        "java.lang.String.format",
        "java.lang.String.format",
        "MethodAnnotationValues.methodName",
        "java.lang.String.format",
        "MethodAnnotationValues.methodName",
        "java.lang.String.format",
        "MethodAnnotationValues.methodName"
      ],
      "Unresolved": [
        "java.lang.reflect.Method.getParameterAnnotations",
        "java.lang.reflect.Method.getParameterAnnotations",
        "java.lang.reflect.Method.getGenericParameterTypes",
        "java.lang.reflect.Method.getAnnotation",
        "java.lang.reflect.Method.getName",
        "java.lang.reflect.Method.getParameterTypes",
        "isAssignableFrom",
        "isAssignableFrom",
        "isAssignableFrom",
        "isAssignableFrom",
        "isAssignableFrom",
        "java.lang.reflect.Method.getAnnotation",
        "java.lang.reflect.Method.getName",
        "java.lang.reflect.Method.getReturnType",
        "java.lang.reflect.Method.getGenericReturnType",
        "isAssignableFrom",
        "java.lang.reflect.Method.getDeclaringClass",
        "getSimpleName",
        "java.lang.reflect.Method.getName"
      ]
    },
    "Imports": {
      "RibbonRequest": "com.netflix.ribbon.RibbonRequest",
      "Content": "com.netflix.ribbon.proxy.annotation.Content",
      "ContentTransformerClass": "com.netflix.ribbon.proxy.annotation.ContentTransformerClass",
      "TemplateName": "com.netflix.ribbon.proxy.annotation.TemplateName",
      "Var": "com.netflix.ribbon.proxy.annotation.Var",
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "ContentTransformer": "io.reactivex.netty.channel.ContentTransformer",
      "Observable": "rx.Observable",
      "Annotation": "java.lang.annotation.Annotation",
      "Method": "java.lang.reflect.Method",
      "ParameterizedType": "java.lang.reflect.ParameterizedType",
      "Type": "java.lang.reflect.Type",
      "ArrayList": "java.util.ArrayList",
      "List": "java.util.List",
      "format": "java.lang.String.format"
    },
    "FieldTypes": {
      "method": "java.lang.reflect.Method"
    }
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\proxy\\MethodTemplateExecutor.java": {
    "TypeDeclarations": [
      "MethodTemplateExecutor"
    ],
    "MethodDeclarations": [
      "MethodTemplateExecutor.executeFromTemplate(Object)",
      "MethodTemplateExecutor.createHttpRequestTemplateBuilder()",
      "MethodTemplateExecutor.createBaseHttpRequestTemplate(HttpResourceGroup)",
      "MethodTemplateExecutor.withParameters(HttpRequestBuilder, Object)",
      "MethodTemplateExecutor.withContent(HttpRequestBuilder, Object)",
      "MethodTemplateExecutor.from(HttpResourceGroup, Class, AnnotationProcessorsProvider)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "MethodTemplateExecutor.createHttpRequestTemplateBuilder",
        "MethodTemplateExecutor.withParameters",
        "MethodTemplateExecutor.withContent",
        "MethodTemplateExecutor.createBaseHttpRequestTemplate"
      ],
      "Unresolved": [
        "com.netflix.ribbon.http.HttpRequestTemplate.Builder.build",
        "requestBuilder",
        "isAssignableFrom",
        "com.netflix.ribbon.http.HttpResourceGroup.newTemplateBuilder",
        "com.netflix.ribbon.http.HttpResourceGroup.newTemplateBuilder",
        "isAssignableFrom"
      ]
    },
    "Imports": {
      "RibbonRequest": "com.netflix.ribbon.RibbonRequest",
      "HttpRequestBuilder": "com.netflix.ribbon.http.HttpRequestBuilder",
      "Builder": "com.netflix.ribbon.http.HttpRequestTemplate.Builder",
      "HttpResourceGroup": "com.netflix.ribbon.http.HttpResourceGroup",
      "AnnotationProcessor": "com.netflix.ribbon.proxy.processor.AnnotationProcessor",
      "AnnotationProcessorsProvider": "com.netflix.ribbon.proxy.processor.AnnotationProcessorsProvider",
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "ByteBufAllocator": "io.netty.buffer.ByteBufAllocator",
      "ContentTransformer": "io.reactivex.netty.channel.ContentTransformer",
      "StringTransformer": "io.reactivex.netty.channel.StringTransformer",
      "Observable": "rx.Observable",
      "Method": "java.lang.reflect.Method",
      "HashMap": "java.util.HashMap",
      "Map": "java.util.Map"
    },
    "FieldTypes": {
      "BYTE_BUF_TRANSFORMER": "io.reactivex.netty.channel.ContentTransformer",
      "BYTE_ARRAY_TRANSFORMER": "io.reactivex.netty.channel.ContentTransformer",
      "STRING_TRANSFORMER": "io.reactivex.netty.channel.StringTransformer",
      "httpResourceGroup": "com.netflix.ribbon.http.HttpResourceGroup",
      "httpRequestTemplateBuilder": "com.netflix.ribbon.http.HttpRequestTemplate.Builder"
    }
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\proxy\\ProxyAnnotationException.java": {
    "TypeDeclarations": [
      "ProxyAnnotationException"
    ],
    "MethodDeclarations": [],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {},
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\proxy\\ProxyHttpResourceGroupFactory.java": {
    "TypeDeclarations": [
      "ProxyHttpResourceGroupFactory"
    ],
    "MethodDeclarations": [
      "ProxyHttpResourceGroupFactory.createResourceGroup()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "getSimpleName",
        "com.netflix.ribbon.RibbonResourceFactory.createHttpResourceGroupBuilder",
        "com.netflix.ribbon.proxy.processor.AnnotationProcessorsProvider.getProcessors"
      ]
    },
    "Imports": {
      "ClientConfigFactory": "com.netflix.client.config.ClientConfigFactory",
      "DefaultResourceFactory": "com.netflix.ribbon.DefaultResourceFactory",
      "RibbonResourceFactory": "com.netflix.ribbon.RibbonResourceFactory",
      "RibbonTransportFactory": "com.netflix.ribbon.RibbonTransportFactory",
      "HttpResourceGroup": "com.netflix.ribbon.http.HttpResourceGroup",
      "AnnotationProcessor": "com.netflix.ribbon.proxy.processor.AnnotationProcessor",
      "AnnotationProcessorsProvider": "com.netflix.ribbon.proxy.processor.AnnotationProcessorsProvider"
    },
    "FieldTypes": {
      "httpResourceGroupFactory": "com.netflix.ribbon.RibbonResourceFactory",
      "processors": "com.netflix.ribbon.proxy.processor.AnnotationProcessorsProvider"
    }
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\proxy\\ProxyLifeCycle.java": {
    "TypeDeclarations": [
      "ProxyLifeCycle"
    ],
    "MethodDeclarations": [
      "ProxyLifeCycle.isShutDown()",
      "ProxyLifeCycle.shutdown()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {},
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\proxy\\RibbonDynamicProxy.java": {
    "TypeDeclarations": [
      "RibbonDynamicProxy",
      "ProxyLifecycleImpl"
    ],
    "MethodDeclarations": [
      "RibbonDynamicProxy.registerAnnotationProcessors(AnnotationProcessorsProvider)",
      "RibbonDynamicProxy.invoke(Object, Method, Object)",
      "RibbonDynamicProxy.handleProxyLifeCycle(Method, Object)",
      "RibbonDynamicProxy.toString()",
      "ProxyLifecycleImpl.isShutDown()",
      "ProxyLifecycleImpl.shutdown()",
      "RibbonDynamicProxy.newInstance(Class)",
      "RibbonDynamicProxy.newInstance(Class, HttpResourceGroup)",
      "RibbonDynamicProxy.newInstance(Class, RibbonResourceFactory, ClientConfigFactory, RibbonTransportFactory, AnnotationProcessorsProvider)",
      "RibbonDynamicProxy.newInstance(Class, RibbonResourceFactory, ClientConfigFactory, RibbonTransportFactory)"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.util.Map.get"
      ],
      "UserDefined": [
        "ProxyLifecycleImpl.shutdown"
      ],
      "Unresolved": [
        "registerAnnotationProcessors",
        "registerAnnotationProcessors",
        "createResourceGroup",
        "isAssignableFrom",
        "handleProxyLifeCycle",
        "com.netflix.ribbon.http.HttpResourceGroup.getClient",
        "newInstance",
        "getContextClassLoader",
        "getContextClassLoader",
        "newInstance"
      ]
    },
    "Imports": {
      "ClientConfigFactory": "com.netflix.client.config.ClientConfigFactory",
      "DefaultResourceFactory": "com.netflix.ribbon.DefaultResourceFactory",
      "RibbonResourceFactory": "com.netflix.ribbon.RibbonResourceFactory",
      "RibbonTransportFactory": "com.netflix.ribbon.RibbonTransportFactory",
      "HttpResourceGroup": "com.netflix.ribbon.http.HttpResourceGroup",
      "AnnotationProcessorsProvider": "com.netflix.ribbon.proxy.processor.AnnotationProcessorsProvider",
      "CacheProviderAnnotationProcessor": "com.netflix.ribbon.proxy.processor.CacheProviderAnnotationProcessor",
      "ClientPropertiesProcessor": "com.netflix.ribbon.proxy.processor.ClientPropertiesProcessor",
      "HttpAnnotationProcessor": "com.netflix.ribbon.proxy.processor.HttpAnnotationProcessor",
      "HystrixAnnotationProcessor": "com.netflix.ribbon.proxy.processor.HystrixAnnotationProcessor",
      "InvocationHandler": "java.lang.reflect.InvocationHandler",
      "Method": "java.lang.reflect.Method",
      "Proxy": "java.lang.reflect.Proxy",
      "Map": "java.util.Map"
    },
    "FieldTypes": {
      "templateExecutorMap": "java.util.Map",
      "httpResourceGroup": "com.netflix.ribbon.http.HttpResourceGroup"
    }
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\proxy\\RibbonProxyException.java": {
    "TypeDeclarations": [
      "RibbonProxyException"
    ],
    "MethodDeclarations": [],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {},
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\proxy\\Utils.java": {
    "TypeDeclarations": [
      "Utils"
    ],
    "MethodDeclarations": [
      "Utils.methodByName(Class, String)",
      "Utils.executeOnInstance(Object, Method, Object)",
      "Utils.newInstance(Class)"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.lang.equals"
      ],
      "UserDefined": [
        "Utils.methodByName"
      ],
      "Unresolved": [
        "format",
        "getSimpleName",
        "format",
        "getSimpleName"
      ]
    },
    "Imports": {
      "Method": "java.lang.reflect.Method",
      "java.lang.String.*": "java.lang.String"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\proxy\\annotation\\CacheProvider.java": {
    "TypeDeclarations": [
      "CacheProvider"
    ],
    "MethodDeclarations": [],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "CacheProviderFactory": "com.netflix.ribbon.CacheProviderFactory",
      "ElementType": "java.lang.annotation.ElementType",
      "Retention": "java.lang.annotation.Retention",
      "RetentionPolicy": "java.lang.annotation.RetentionPolicy",
      "Target": "java.lang.annotation.Target"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\proxy\\annotation\\ClientProperties.java": {
    "TypeDeclarations": [
      "ClientProperties",
      "Property"
    ],
    "MethodDeclarations": [],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "ElementType": "java.lang.annotation.ElementType",
      "Retention": "java.lang.annotation.Retention",
      "RetentionPolicy": "java.lang.annotation.RetentionPolicy",
      "Target": "java.lang.annotation.Target"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\proxy\\annotation\\Content.java": {
    "TypeDeclarations": [
      "Content"
    ],
    "MethodDeclarations": [],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "ElementType": "java.lang.annotation.ElementType",
      "Retention": "java.lang.annotation.Retention",
      "RetentionPolicy": "java.lang.annotation.RetentionPolicy",
      "Target": "java.lang.annotation.Target"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\proxy\\annotation\\ContentTransformerClass.java": {
    "TypeDeclarations": [
      "ContentTransformerClass"
    ],
    "MethodDeclarations": [],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "ContentTransformer": "io.reactivex.netty.channel.ContentTransformer",
      "ElementType": "java.lang.annotation.ElementType",
      "Retention": "java.lang.annotation.Retention",
      "RetentionPolicy": "java.lang.annotation.RetentionPolicy",
      "Target": "java.lang.annotation.Target"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\proxy\\annotation\\Http.java": {
    "TypeDeclarations": [
      "Http",
      "HttpMethod",
      "Header"
    ],
    "MethodDeclarations": [],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "ElementType": "java.lang.annotation.ElementType",
      "Retention": "java.lang.annotation.Retention",
      "RetentionPolicy": "java.lang.annotation.RetentionPolicy",
      "Target": "java.lang.annotation.Target"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\proxy\\annotation\\Hystrix.java": {
    "TypeDeclarations": [
      "Hystrix"
    ],
    "MethodDeclarations": [],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "HttpResponseValidator": "com.netflix.ribbon.http.HttpResponseValidator",
      "FallbackHandler": "com.netflix.ribbon.hystrix.FallbackHandler",
      "ElementType": "java.lang.annotation.ElementType",
      "Retention": "java.lang.annotation.Retention",
      "RetentionPolicy": "java.lang.annotation.RetentionPolicy",
      "Target": "java.lang.annotation.Target"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\proxy\\annotation\\ResourceGroup.java": {
    "TypeDeclarations": [
      "ResourceGroup"
    ],
    "MethodDeclarations": [],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "HttpResourceGroup": "com.netflix.ribbon.http.HttpResourceGroup",
      "ElementType": "java.lang.annotation.ElementType",
      "Retention": "java.lang.annotation.Retention",
      "RetentionPolicy": "java.lang.annotation.RetentionPolicy",
      "Target": "java.lang.annotation.Target"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\proxy\\annotation\\TemplateName.java": {
    "TypeDeclarations": [
      "TemplateName"
    ],
    "MethodDeclarations": [],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "ElementType": "java.lang.annotation.ElementType",
      "Retention": "java.lang.annotation.Retention",
      "RetentionPolicy": "java.lang.annotation.RetentionPolicy",
      "Target": "java.lang.annotation.Target"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\proxy\\annotation\\Var.java": {
    "TypeDeclarations": [
      "Var"
    ],
    "MethodDeclarations": [],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "ElementType": "java.lang.annotation.ElementType",
      "Retention": "java.lang.annotation.Retention",
      "RetentionPolicy": "java.lang.annotation.RetentionPolicy",
      "Target": "java.lang.annotation.Target"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\proxy\\processor\\AnnotationProcessor.java": {
    "TypeDeclarations": [
      "AnnotationProcessor"
    ],
    "MethodDeclarations": [
      "AnnotationProcessor.process(String, S, Method)",
      "AnnotationProcessor.process(String, T, RibbonResourceFactory, Class)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "GroupBuilder": "com.netflix.ribbon.ResourceGroup.GroupBuilder",
      "TemplateBuilder": "com.netflix.ribbon.ResourceGroup.TemplateBuilder",
      "RibbonResourceFactory": "com.netflix.ribbon.RibbonResourceFactory",
      "Method": "java.lang.reflect.Method"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\proxy\\processor\\AnnotationProcessorsProvider.java": {
    "TypeDeclarations": [
      "AnnotationProcessorsProvider",
      "DefaultAnnotationProcessorsProvider"
    ],
    "MethodDeclarations": [
      "AnnotationProcessorsProvider.register(AnnotationProcessor)",
      "AnnotationProcessorsProvider.getProcessors()"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.util.List.add"
      ],
      "UserDefined": [],
      "Unresolved": [
        "register"
      ]
    },
    "Imports": {
      "Iterator": "java.util.Iterator",
      "List": "java.util.List",
      "ServiceLoader": "java.util.ServiceLoader",
      "CopyOnWriteArrayList": "java.util.concurrent.CopyOnWriteArrayList"
    },
    "FieldTypes": {
      "processors": "java.util.List"
    }
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\proxy\\processor\\CacheProviderAnnotationProcessor.java": {
    "TypeDeclarations": [
      "CacheProviderAnnotationProcessor"
    ],
    "MethodDeclarations": [
      "CacheProviderAnnotationProcessor.process(String, TemplateBuilder, Method)",
      "CacheProviderAnnotationProcessor.process(String, GroupBuilder, RibbonResourceFactory, Class)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "CacheProviderFactory": "com.netflix.ribbon.CacheProviderFactory",
      "GroupBuilder": "com.netflix.ribbon.ResourceGroup.GroupBuilder",
      "TemplateBuilder": "com.netflix.ribbon.ResourceGroup.TemplateBuilder",
      "RibbonResourceFactory": "com.netflix.ribbon.RibbonResourceFactory",
      "Utils": "com.netflix.ribbon.proxy.Utils",
      "CacheProvider": "com.netflix.ribbon.proxy.annotation.CacheProvider",
      "Method": "java.lang.reflect.Method"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\proxy\\processor\\ClientPropertiesProcessor.java": {
    "TypeDeclarations": [
      "ClientPropertiesProcessor"
    ],
    "MethodDeclarations": [
      "ClientPropertiesProcessor.process(String, TemplateBuilder, Method)",
      "ClientPropertiesProcessor.process(String, GroupBuilder, RibbonResourceFactory, Class)",
      "ClientPropertiesProcessor.exportPropertiesToArchaius(String, IClientConfig, String)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "ClientPropertiesProcessor.exportPropertiesToArchaius"
      ],
      "Unresolved": [
        "newConfig"
      ]
    },
    "Imports": {
      "CommonClientConfigKey": "com.netflix.client.config.CommonClientConfigKey",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "AggregatedConfiguration": "com.netflix.config.AggregatedConfiguration",
      "ConcurrentMapConfiguration": "com.netflix.config.ConcurrentMapConfiguration",
      "ConfigurationManager": "com.netflix.config.ConfigurationManager",
      "ClientOptions": "com.netflix.ribbon.ClientOptions",
      "GroupBuilder": "com.netflix.ribbon.ResourceGroup.GroupBuilder",
      "TemplateBuilder": "com.netflix.ribbon.ResourceGroup.TemplateBuilder",
      "RibbonResourceFactory": "com.netflix.ribbon.RibbonResourceFactory",
      "ClientProperties": "com.netflix.ribbon.proxy.annotation.ClientProperties",
      "Property": "com.netflix.ribbon.proxy.annotation.ClientProperties.Property",
      "AbstractConfiguration": "org.apache.commons.configuration.AbstractConfiguration",
      "Configuration": "org.apache.commons.configuration.Configuration",
      "Method": "java.lang.reflect.Method",
      "Map": "java.util.Map"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\proxy\\processor\\HttpAnnotationProcessor.java": {
    "TypeDeclarations": [
      "HttpAnnotationProcessor"
    ],
    "MethodDeclarations": [
      "HttpAnnotationProcessor.process(String, Builder, Method)",
      "HttpAnnotationProcessor.process(String, HttpResourceGroup, RibbonResourceFactory, Class)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "java.lang.String.format"
      ],
      "Unresolved": [
        "add"
      ]
    },
    "Imports": {
      "RibbonResourceFactory": "com.netflix.ribbon.RibbonResourceFactory",
      "Builder": "com.netflix.ribbon.http.HttpRequestTemplate.Builder",
      "HttpResourceGroup": "com.netflix.ribbon.http.HttpResourceGroup",
      "ProxyAnnotationException": "com.netflix.ribbon.proxy.ProxyAnnotationException",
      "Http": "com.netflix.ribbon.proxy.annotation.Http",
      "Header": "com.netflix.ribbon.proxy.annotation.Http.Header",
      "HttpMethod": "com.netflix.ribbon.proxy.annotation.Http.HttpMethod",
      "Method": "java.lang.reflect.Method",
      "ArrayList": "java.util.ArrayList",
      "HashMap": "java.util.HashMap",
      "List": "java.util.List",
      "Map": "java.util.Map",
      "Entry": "java.util.Map.Entry",
      "format": "java.lang.String.format"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\proxy\\processor\\HystrixAnnotationProcessor.java": {
    "TypeDeclarations": [
      "HystrixAnnotationProcessor"
    ],
    "MethodDeclarations": [
      "HystrixAnnotationProcessor.process(String, Builder, Method)",
      "HystrixAnnotationProcessor.process(String, HttpResourceGroup, RibbonResourceFactory, Class)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "java.lang.String.format",
        "java.lang.String.format"
      ],
      "Unresolved": [
        "trim"
      ]
    },
    "Imports": {
      "RibbonResourceFactory": "com.netflix.ribbon.RibbonResourceFactory",
      "Builder": "com.netflix.ribbon.http.HttpRequestTemplate.Builder",
      "HttpResourceGroup": "com.netflix.ribbon.http.HttpResourceGroup",
      "HttpResponseValidator": "com.netflix.ribbon.http.HttpResponseValidator",
      "FallbackHandler": "com.netflix.ribbon.hystrix.FallbackHandler",
      "ProxyAnnotationException": "com.netflix.ribbon.proxy.ProxyAnnotationException",
      "Utils": "com.netflix.ribbon.proxy.Utils",
      "Hystrix": "com.netflix.ribbon.proxy.annotation.Hystrix",
      "Method": "java.lang.reflect.Method",
      "format": "java.lang.String.format"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\template\\MatrixVar.java": {
    "TypeDeclarations": [
      "MatrixVar"
    ],
    "MethodDeclarations": [],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {},
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\template\\ParsedTemplate.java": {
    "TypeDeclarations": [
      "ParsedTemplate"
    ],
    "MethodDeclarations": [
      "ParsedTemplate.getParsed()",
      "ParsedTemplate.getTemplate()",
      "ParsedTemplate.create(String)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "List": "java.util.List"
    },
    "FieldTypes": {
      "parsed": "java.util.List"
    }
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\template\\PathVar.java": {
    "TypeDeclarations": [
      "PathVar"
    ],
    "MethodDeclarations": [],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {},
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\template\\TemplateParser.java": {
    "TypeDeclarations": [
      "TemplateParser"
    ],
    "MethodDeclarations": [
      "TemplateParser.parseTemplate(String)",
      "TemplateParser.toData(Map, ParsedTemplate)",
      "TemplateParser.toData(Map, String, List)",
      "TemplateParser.main(String)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "TemplateParser.toData",
        "TemplateParser.parseTemplate",
        "TemplateParser.toData"
      ],
      "Unresolved": [
        "append",
        "append",
        "append",
        "getCanonicalName"
      ]
    },
    "Imports": {
      "ArrayList": "java.util.ArrayList",
      "List": "java.util.List",
      "Map": "java.util.Map",
      "Maps": "com.google.common.collect.Maps"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\template\\TemplateParsingException.java": {
    "TypeDeclarations": [
      "TemplateParsingException"
    ],
    "MethodDeclarations": [],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {},
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\main\\java\\com\\netflix\\ribbon\\template\\TemplateVar.java": {
    "TypeDeclarations": [
      "TemplateVar"
    ],
    "MethodDeclarations": [
      "TemplateVar.toString()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {},
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\test\\java\\com\\netflix\\ribbon\\DiscoveryEnabledServerListTest.java": {
    "TypeDeclarations": [
      "DiscoveryEnabledServerListTest"
    ],
    "MethodDeclarations": [
      "DiscoveryEnabledServerListTest.init()",
      "DiscoveryEnabledServerListTest.shutdown()",
      "DiscoveryEnabledServerListTest.getMockServerList()",
      "DiscoveryEnabledServerListTest.getVipAddress()",
      "DiscoveryEnabledServerListTest.testDynamicServers()"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.lang.toString"
      ],
      "UserDefined": [
        "DiscoveryEnabledServerListTest.getVipAddress",
        "org.junit.Assert.assertEquals"
      ],
      "Unresolved": [
        "setResponseCode",
        "setHeader",
        "setBody",
        "com.google.mockwebserver.MockWebServer.enqueue",
        "com.google.mockwebserver.MockWebServer.play",
        "com.google.mockwebserver.MockWebServer.shutdown",
        "com.google.mockwebserver.MockWebServer.getPort",
        "setProperty",
        "setProperty",
        "getName",
        "withClientOptions",
        "withMaxAutoRetriesNextServer",
        "withReadTimeout",
        "build",
        "withUriTemplate",
        "withMethod",
        "build",
        "build"
      ]
    },
    "Imports": {
      "MockResponse": "com.google.mockwebserver.MockResponse",
      "MockWebServer": "com.google.mockwebserver.MockWebServer",
      "Keys": "com.netflix.client.config.IClientConfigKey.Keys",
      "ConfigurationManager": "com.netflix.config.ConfigurationManager",
      "Server": "com.netflix.loadbalancer.Server",
      "DiscoveryEnabledNIWSServerList": "com.netflix.niws.loadbalancer.DiscoveryEnabledNIWSServerList",
      "HttpRequestTemplate": "com.netflix.ribbon.http.HttpRequestTemplate",
      "HttpResourceGroup": "com.netflix.ribbon.http.HttpResourceGroup",
      "MockedDiscoveryServerListTest": "com.netflix.ribbon.testutils.MockedDiscoveryServerListTest",
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "AfterClass": "org.junit.AfterClass",
      "BeforeClass": "org.junit.BeforeClass",
      "Test": "org.junit.Test",
      "PowerMockIgnore": "org.powermock.core.classloader.annotations.PowerMockIgnore",
      "IOException": "java.io.IOException",
      "Charset": "java.nio.charset.Charset",
      "ArrayList": "java.util.ArrayList",
      "List": "java.util.List",
      "assertEquals": "org.junit.Assert.assertEquals"
    },
    "FieldTypes": {
      "server": "com.google.mockwebserver.MockWebServer"
    }
  },
  "ribbon\\ribbon\\src\\test\\java\\com\\netflix\\ribbon\\RibbonTest.java": {
    "TypeDeclarations": [
      "RibbonTest"
    ],
    "MethodDeclarations": [
      "RibbonTest.toStringBlocking(RibbonRequest)",
      "RibbonTest.init()",
      "RibbonTest.testCommand()",
      "RibbonTest.testHystrixCache()",
      "RibbonTest.testCommandWithMetaData()",
      "RibbonTest.testValidator()",
      "RibbonTest.testFallback()",
      "RibbonTest.testCacheHit()",
      "RibbonTest.testObserve()",
      "RibbonTest.testCacheMiss()"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.lang.toString",
        "java.lang.toString",
        "java.lang.toString",
        "java.lang.toString",
        "java.lang.toString"
      ],
      "UserDefined": [
        "RibbonTest.toStringBlocking"
      ],
      "Unresolved": [
        "map",
        "toBlocking",
        "single",
        "setLevel",
        "setResponseCode",
        "setHeader",
        "setBody",
        "withMaxAutoRetriesNextServer",
        "withReadTimeout",
        "withConfigurationBasedServerList",
        "withUriTemplate",
        "withMethod",
        "build",
        "build",
        "assertEquals",
        "assertEquals",
        "get",
        "assertEquals",
        "setResponseCode",
        "setHeader",
        "setBody",
        "build",
        "withUriTemplate",
        "withMethod",
        "withRequestCacheKey",
        "build",
        "build",
        "execute",
        "assertFalse",
        "isResponseFromCache",
        "execute",
        "assertTrue",
        "isResponseFromCache",
        "setResponseCode",
        "setHeader",
        "setBody",
        "withConfigurationBasedServerList",
        "withMaxAutoRetriesNextServer",
        "withUriTemplate",
        "withMethod",
        "withCacheProvider",
        "build",
        "build",
        "flatMap",
        "isSuccessfulExecution",
        "map",
        "single",
        "assertEquals",
        "assertTrue",
        "assertTrue",
        "assertEquals",
        "assertTrue",
        "isSuccessfulExecution",
        "assertEquals",
        "assertTrue",
        "isSuccessfulExecution",
        "setResponseCode",
        "setHeader",
        "setBody",
        "withConfigurationBasedServerList",
        "withUriTemplate",
        "withMethod",
        "withResponseValidator",
        "build",
        "build",
        "subscribe",
        "assertTrue",
        "assertTrue",
        "getCause",
        "withConfigurationBasedServerList",
        "withMaxAutoRetriesNextServer",
        "withUriTemplate",
        "withMethod",
        "withFallbackProvider",
        "writeBytes",
        "build",
        "build",
        "toObservable",
        "flatMap",
        "isFailedExecution",
        "map",
        "single",
        "assertTrue",
        "isResponseFromFallback",
        "assertTrue",
        "assertEquals",
        "withConfigurationBasedServerList",
        "withMaxAutoRetriesNextServer",
        "withCacheProvider",
        "writeBytes",
        "withUriTemplate",
        "withMethod",
        "build",
        "build",
        "assertEquals",
        "setResponseCode",
        "setHeader",
        "setBody",
        "setResponseCode",
        "setHeader",
        "setBody",
        "withMaxAutoRetriesNextServer",
        "withReadTimeout",
        "withConfigurationBasedServerList",
        "withUriTemplate",
        "withMethod",
        "build",
        "build",
        "last",
        "assertEquals",
        "observe",
        "last",
        "map",
        "toBlocking",
        "single",
        "assertEquals",
        "setResponseCode",
        "setHeader",
        "setBody",
        "withConfigurationBasedServerList",
        "withMaxAutoRetriesNextServer",
        "withCacheProvider",
        "withMethod",
        "withUriTemplate",
        "build",
        "build",
        "assertEquals"
      ]
    },
    "Imports": {
      "MockResponse": "com.google.mockwebserver.MockResponse",
      "MockWebServer": "com.google.mockwebserver.MockWebServer",
      "HystrixInvokableInfo": "com.netflix.hystrix.HystrixInvokableInfo",
      "HystrixBadRequestException": "com.netflix.hystrix.exception.HystrixBadRequestException",
      "HystrixRequestContext": "com.netflix.hystrix.strategy.concurrency.HystrixRequestContext",
      "HttpRequestTemplate": "com.netflix.ribbon.http.HttpRequestTemplate",
      "HttpResourceGroup": "com.netflix.ribbon.http.HttpResourceGroup",
      "FallbackHandler": "com.netflix.ribbon.hystrix.FallbackHandler",
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "Unpooled": "io.netty.buffer.Unpooled",
      "HttpClientResponse": "io.reactivex.netty.protocol.http.client.HttpClientResponse",
      "Level": "org.apache.log4j.Level",
      "LogManager": "org.apache.log4j.LogManager",
      "BeforeClass": "org.junit.BeforeClass",
      "Ignore": "org.junit.Ignore",
      "Test": "org.junit.Test",
      "Observable": "rx.Observable",
      "Action0": "rx.functions.Action0",
      "Action1": "rx.functions.Action1",
      "Func1": "rx.functions.Func1",
      "IOException": "java.io.IOException",
      "UnsupportedEncodingException": "java.io.UnsupportedEncodingException",
      "Charset": "java.nio.charset.Charset",
      "Map": "java.util.Map",
      "CountDownLatch": "java.util.concurrent.CountDownLatch",
      "ExecutionException": "java.util.concurrent.ExecutionException",
      "Future": "java.util.concurrent.Future",
      "AtomicBoolean": "java.util.concurrent.atomic.AtomicBoolean",
      "AtomicReference": "java.util.concurrent.atomic.AtomicReference",
      "org.junit.Assert.*": "org.junit.Assert"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\test\\java\\com\\netflix\\ribbon\\http\\TemplateBuilderTest.java": {
    "TypeDeclarations": [
      "TemplateBuilderTest",
      "FakeCacheProvider"
    ],
    "MethodDeclarations": [
      "FakeCacheProvider.get(String, Map)",
      "TemplateBuilderTest.testVarReplacement()",
      "TemplateBuilderTest.testCacheKeyTemplates()",
      "TemplateBuilderTest.testHttpHeaders()",
      "TemplateBuilderTest.testHystrixProperties()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "FakeCacheProvider.get",
        "org.junit.Assert.assertEquals",
        "FakeCacheProvider.get",
        "org.junit.Assert.assertEquals",
        "FakeCacheProvider.get"
      ],
      "Unresolved": [
        "writeBytes",
        "build",
        "withMethod",
        "withUriTemplate",
        "build",
        "withRequestProperty",
        "withRequestProperty",
        "createClientRequest",
        "build",
        "withUriTemplate",
        "withMethod",
        "withCacheProvider",
        "build",
        "withRequestProperty",
        "build",
        "withHeader",
        "build",
        "withUriTemplate",
        "withMethod",
        "withHeader",
        "withHeader",
        "build",
        "withHeader",
        "withMaxAutoRetriesNextServer",
        "withMaxAutoRetries",
        "withConnectTimeout",
        "withMaxTotalConnections",
        "withReadTimeout",
        "withMethod",
        "withUriTemplate",
        "build",
        "build",
        "getProperties",
        "intValue",
        "intValue"
      ]
    },
    "Imports": {
      "HystrixCommandProperties": "com.netflix.hystrix.HystrixCommandProperties",
      "CacheProvider": "com.netflix.ribbon.CacheProvider",
      "ClientOptions": "com.netflix.ribbon.ClientOptions",
      "Ribbon": "com.netflix.ribbon.Ribbon",
      "RibbonRequest": "com.netflix.ribbon.RibbonRequest",
      "HystrixObservableCommandChain": "com.netflix.ribbon.hystrix.HystrixObservableCommandChain",
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "Unpooled": "io.netty.buffer.Unpooled",
      "HttpClientRequest": "io.reactivex.netty.protocol.http.client.HttpClientRequest",
      "HttpRequestHeaders": "io.reactivex.netty.protocol.http.client.HttpRequestHeaders",
      "Test": "org.junit.Test",
      "Observable": "rx.Observable",
      "Charset": "java.nio.charset.Charset",
      "List": "java.util.List",
      "Map": "java.util.Map",
      "assertEquals": "org.junit.Assert.assertEquals"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\test\\java\\com\\netflix\\ribbon\\hystrix\\HystrixCommandChainTest.java": {
    "TypeDeclarations": [
      "HystrixCommandChainTest",
      "TestableHystrixObservableCommand"
    ],
    "MethodDeclarations": [
      "HystrixCommandChainTest.testMaterializedNotificationObservableFirstOK()",
      "HystrixCommandChainTest.testMaterializedNotificationObservableLastOK()",
      "HystrixCommandChainTest.testMaterializedNotificationObservableError()",
      "HystrixCommandChainTest.testObservableOK()",
      "HystrixCommandChainTest.testObservableError()",
      "TestableHystrixObservableCommand.construct()",
      "TestableHystrixObservableCommand.fireEvents(Observer)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertTrue",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "TestableHystrixObservableCommand.fireEvents"
      ],
      "Unresolved": [
        "toBlocking",
        "single",
        "toBlocking",
        "single",
        "materialize",
        "toBlocking",
        "single",
        "toBlocking",
        "single",
        "toBlocking",
        "single"
      ]
    },
    "Imports": {
      "assertEquals": "org.junit.Assert.assertEquals",
      "assertTrue": "org.junit.Assert.assertTrue",
      "Test": "org.junit.Test",
      "Notification": "rx.Notification",
      "Observable": "rx.Observable",
      "Observer": "rx.Observer",
      "ReplaySubject": "rx.subjects.ReplaySubject",
      "Subject": "rx.subjects.Subject",
      "HystrixCommandGroupKey": "com.netflix.hystrix.HystrixCommandGroupKey",
      "HystrixObservableCommand": "com.netflix.hystrix.HystrixObservableCommand"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\test\\java\\com\\netflix\\ribbon\\proxy\\ClassTemplateTest.java": {
    "TypeDeclarations": [
      "ClassTemplateTest"
    ],
    "MethodDeclarations": [
      "ClassTemplateTest.testResourceGroupAnnotationMissing()",
      "ClassTemplateTest.testCreateWithResourceGroupNameAnnotation()",
      "ClassTemplateTest.testCreateWithResourceGroupClassAnnotation()",
      "ClassTemplateTest.testBothNameAndResourceGroupClassInAnnotation()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "assertNull",
        "assertNull",
        "assertNull",
        "assertNotNull",
        "assertNotNull",
        "assertNull"
      ]
    },
    "Imports": {
      "Test": "org.junit.Test",
      "ClassTemplate": "com.netflix.ribbon.proxy.ClassTemplate",
      "RibbonProxyException": "com.netflix.ribbon.proxy.RibbonProxyException",
      "com.netflix.ribbon.proxy.sample.MovieServiceInterfaces.*": "com.netflix.ribbon.proxy.sample.MovieServiceInterfaces",
      "org.junit.Assert.*": "org.junit.Assert"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\test\\java\\com\\netflix\\ribbon\\proxy\\ClientPropertiesTest.java": {
    "TypeDeclarations": [
      "ClientPropertiesTest",
      "MyTransportFactory",
      "MovieService"
    ],
    "MethodDeclarations": [
      "MyTransportFactory.newHttpClient(IClientConfig)",
      "MyTransportFactory.getClientConfig()",
      "ClientPropertiesTest.testAnnotation()",
      "ClientPropertiesTest.testNoExportToArchaius()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertNull",
        "org.junit.Assert.assertEquals"
      ],
      "Unresolved": [
        "longValue",
        "longValue",
        "com.netflix.client.config.IClientConfig.getProperty",
        "com.netflix.client.config.IClientConfig.getProperty",
        "com.netflix.client.config.IClientConfig.setProperty",
        "longValue",
        "longValue",
        "longValue",
        "longValue",
        "com.netflix.client.config.IClientConfig.getProperty",
        "com.netflix.client.config.IClientConfig.setProperty",
        "longValue"
      ]
    },
    "Imports": {
      "ClientConfigFactory": "com.netflix.client.config.ClientConfigFactory",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "Keys": "com.netflix.client.config.IClientConfigKey.Keys",
      "ConfigurationManager": "com.netflix.config.ConfigurationManager",
      "DefaultResourceFactory": "com.netflix.ribbon.DefaultResourceFactory",
      "RibbonResourceFactory": "com.netflix.ribbon.RibbonResourceFactory",
      "DefaultRibbonTransportFactory": "com.netflix.ribbon.RibbonTransportFactory.DefaultRibbonTransportFactory",
      "ClientProperties": "com.netflix.ribbon.proxy.annotation.ClientProperties",
      "Property": "com.netflix.ribbon.proxy.annotation.ClientProperties.Property",
      "SampleMovieService": "com.netflix.ribbon.proxy.sample.MovieServiceInterfaces.SampleMovieService",
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "HttpClient": "io.reactivex.netty.protocol.http.client.HttpClient",
      "Configuration": "org.apache.commons.configuration.Configuration",
      "Test": "org.junit.Test",
      "assertEquals": "org.junit.Assert.assertEquals",
      "assertNull": "org.junit.Assert.assertNull"
    },
    "FieldTypes": {
      "config": "com.netflix.client.config.IClientConfig"
    }
  },
  "ribbon\\ribbon\\src\\test\\java\\com\\netflix\\ribbon\\proxy\\HttpResourceGroupFactoryTest.java": {
    "TypeDeclarations": [
      "HttpResourceGroupFactoryTest"
    ],
    "MethodDeclarations": [
      "HttpResourceGroupFactoryTest.testResourceGroupAnnotationMissing()",
      "HttpResourceGroupFactoryTest.testCreateWithResourceGroupNameAnnotation()",
      "HttpResourceGroupFactoryTest.testCreateWithResourceGroupClassAnnotation()",
      "HttpResourceGroupFactoryTest.testResourceGroupCreation(Class, Class)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "HttpResourceGroupFactoryTest.testResourceGroupCreation",
        "HttpResourceGroupFactoryTest.testResourceGroupCreation"
      ],
      "Unresolved": [
        "createResourceGroup",
        "createResourceGroup",
        "assertNotNull"
      ]
    },
    "Imports": {
      "ClientConfigFactory": "com.netflix.client.config.ClientConfigFactory",
      "DefaultResourceFactory": "com.netflix.ribbon.DefaultResourceFactory",
      "RibbonTransportFactory": "com.netflix.ribbon.RibbonTransportFactory",
      "HttpResourceGroup": "com.netflix.ribbon.http.HttpResourceGroup",
      "AnnotationProcessorsProvider": "com.netflix.ribbon.proxy.processor.AnnotationProcessorsProvider",
      "SampleMovieService": "com.netflix.ribbon.proxy.sample.MovieServiceInterfaces.SampleMovieService",
      "SampleMovieServiceWithResourceGroupClassAnnotation": "com.netflix.ribbon.proxy.sample.MovieServiceInterfaces.SampleMovieServiceWithResourceGroupClassAnnotation",
      "SampleMovieServiceWithResourceGroupNameAnnotation": "com.netflix.ribbon.proxy.sample.MovieServiceInterfaces.SampleMovieServiceWithResourceGroupNameAnnotation",
      "SampleHttpResourceGroup": "com.netflix.ribbon.proxy.sample.ResourceGroupClasses.SampleHttpResourceGroup",
      "Test": "org.junit.Test",
      "org.junit.Assert.*": "org.junit.Assert"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\test\\java\\com\\netflix\\ribbon\\proxy\\MethodTemplateExecutorTest.java": {
    "TypeDeclarations": [
      "MethodTemplateExecutorTest"
    ],
    "MethodDeclarations": [
      "MethodTemplateExecutorTest.setup()",
      "MethodTemplateExecutorTest.setUp()",
      "MethodTemplateExecutorTest.testGetQueryWithDomainObjectResult()",
      "MethodTemplateExecutorTest.testGetQueryWithByteBufResult()",
      "MethodTemplateExecutorTest.testPostWithDomainObjectAndTransformer()",
      "MethodTemplateExecutorTest.testPostWithString()",
      "MethodTemplateExecutorTest.testPostWithByteBuf()",
      "MethodTemplateExecutorTest.testPostWithByteArray()",
      "MethodTemplateExecutorTest.doTestPostWith(String, String, Object)",
      "MethodTemplateExecutorTest.testFromFactory()",
      "MethodTemplateExecutorTest.expectUrlBase(String, String)",
      "MethodTemplateExecutorTest.createExecutor(Class, String)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.expect",
        "MethodTemplateExecutorTest.expectUrlBase",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.anyObject",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.anyObject",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.anyObject",
        "org.easymock.EasyMock.anyObject",
        "MethodTemplateExecutorTest.createExecutor",
        "junit.framework.Assert.assertEquals",
        "MethodTemplateExecutorTest.expectUrlBase",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.expect",
        "MethodTemplateExecutorTest.createExecutor",
        "junit.framework.Assert.assertEquals",
        "MethodTemplateExecutorTest.doTestPostWith",
        "MethodTemplateExecutorTest.doTestPostWith",
        "MethodTemplateExecutorTest.doTestPostWith",
        "MethodTemplateExecutorTest.doTestPostWith",
        "MethodTemplateExecutorTest.expectUrlBase",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.anyObject",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.anyObject",
        "org.easymock.EasyMock.anyObject",
        "MethodTemplateExecutorTest.createExecutor",
        "junit.framework.Assert.assertEquals",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.anyObject",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.anyObject",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.anyObject",
        "junit.framework.Assert.assertEquals",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.expect",
        "com.netflix.ribbon.proxy.Utils.methodByName"
      ],
      "Unresolved": [
        "createMock",
        "createMock",
        "createMock",
        "createMock",
        "createMock",
        "andReturn",
        "com.netflix.ribbon.http.HttpRequestBuilder.build",
        "andReturn",
        "com.netflix.ribbon.http.HttpRequestTemplate.Builder.build",
        "andReturn",
        "com.netflix.ribbon.http.HttpRequestTemplate.requestBuilder",
        "andReturn",
        "com.netflix.ribbon.http.HttpRequestBuilder.withRequestProperty",
        "andReturn",
        "com.netflix.ribbon.http.HttpResourceGroup.newTemplateBuilder",
        "andReturn",
        "com.netflix.ribbon.http.HttpRequestTemplate.Builder.withHeader",
        "andReturn",
        "com.netflix.ribbon.http.HttpRequestTemplate.Builder.withHeader",
        "andReturn",
        "com.netflix.ribbon.http.HttpRequestTemplate.Builder.withHeader",
        "andReturn",
        "com.netflix.ribbon.http.HttpRequestTemplate.Builder.withRequestCacheKey",
        "andReturn",
        "com.netflix.ribbon.http.HttpRequestTemplate.Builder.withFallbackProvider",
        "andReturn",
        "com.netflix.ribbon.http.HttpRequestTemplate.Builder.withResponseValidator",
        "andReturn",
        "com.netflix.ribbon.http.HttpRequestTemplate.Builder.withCacheProvider",
        "replayAll",
        "verifyAll",
        "andReturn",
        "com.netflix.ribbon.http.HttpRequestBuilder.withRequestProperty",
        "andReturn",
        "com.netflix.ribbon.http.HttpResourceGroup.newTemplateBuilder",
        "replayAll",
        "verifyAll",
        "createMock",
        "andReturn",
        "com.netflix.ribbon.http.HttpResourceGroup.newTemplateBuilder",
        "andReturn",
        "com.netflix.ribbon.http.HttpRequestTemplate.Builder.withRequestCacheKey",
        "andReturn",
        "com.netflix.ribbon.http.HttpRequestTemplate.Builder.withFallbackProvider",
        "andReturn",
        "com.netflix.ribbon.http.HttpRequestBuilder.withRawContentSource",
        "replayAll",
        "verifyAll",
        "andReturn",
        "anyTimes",
        "com.netflix.ribbon.http.HttpResourceGroup.newTemplateBuilder",
        "andReturn",
        "anyTimes",
        "com.netflix.ribbon.http.HttpRequestTemplate.Builder.withMethod",
        "andReturn",
        "anyTimes",
        "com.netflix.ribbon.http.HttpRequestTemplate.Builder.withUriTemplate",
        "replayAll",
        "getMethods",
        "andReturn",
        "com.netflix.ribbon.http.HttpRequestTemplate.Builder.withMethod",
        "andReturn",
        "com.netflix.ribbon.http.HttpRequestTemplate.Builder.withUriTemplate"
      ]
    },
    "Imports": {
      "CacheProvider": "com.netflix.ribbon.CacheProvider",
      "RibbonRequest": "com.netflix.ribbon.RibbonRequest",
      "HttpRequestBuilder": "com.netflix.ribbon.http.HttpRequestBuilder",
      "HttpRequestTemplate": "com.netflix.ribbon.http.HttpRequestTemplate",
      "Builder": "com.netflix.ribbon.http.HttpRequestTemplate.Builder",
      "HttpResourceGroup": "com.netflix.ribbon.http.HttpResourceGroup",
      "AnnotationProcessorsProvider": "com.netflix.ribbon.proxy.processor.AnnotationProcessorsProvider",
      "MovieFallbackHandler": "com.netflix.ribbon.proxy.sample.HystrixHandlers.MovieFallbackHandler",
      "SampleHttpResponseValidator": "com.netflix.ribbon.proxy.sample.HystrixHandlers.SampleHttpResponseValidator",
      "Movie": "com.netflix.ribbon.proxy.sample.Movie",
      "SampleMovieService": "com.netflix.ribbon.proxy.sample.MovieServiceInterfaces.SampleMovieService",
      "ShortMovieService": "com.netflix.ribbon.proxy.sample.MovieServiceInterfaces.ShortMovieService",
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "ContentTransformer": "io.reactivex.netty.channel.ContentTransformer",
      "Before": "org.junit.Before",
      "BeforeClass": "org.junit.BeforeClass",
      "Test": "org.junit.Test",
      "RunWith": "org.junit.runner.RunWith",
      "Mock": "org.powermock.api.easymock.annotation.Mock",
      "PowerMockIgnore": "org.powermock.core.classloader.annotations.PowerMockIgnore",
      "PrepareForTest": "org.powermock.core.classloader.annotations.PrepareForTest",
      "PowerMockRunner": "org.powermock.modules.junit4.PowerMockRunner",
      "Observable": "rx.Observable",
      "Method": "java.lang.reflect.Method",
      "Map": "java.util.Map",
      "methodByName": "com.netflix.ribbon.proxy.Utils.methodByName",
      "assertEquals": "junit.framework.Assert.assertEquals",
      "anyObject": "org.easymock.EasyMock.anyObject",
      "expect": "org.easymock.EasyMock.expect",
      "org.powermock.api.easymock.PowerMock.*": "org.powermock.api.easymock.PowerMock"
    },
    "FieldTypes": {
      "ribbonRequestMock": "com.netflix.ribbon.RibbonRequest",
      "requestBuilderMock": "com.netflix.ribbon.http.HttpRequestBuilder",
      "httpRequestTemplateBuilderMock": "com.netflix.ribbon.http.HttpRequestTemplate.Builder",
      "httpRequestTemplateMock": "com.netflix.ribbon.http.HttpRequestTemplate",
      "httpResourceGroupMock": "com.netflix.ribbon.http.HttpResourceGroup"
    }
  },
  "ribbon\\ribbon\\src\\test\\java\\com\\netflix\\ribbon\\proxy\\MethodTemplateTest.java": {
    "TypeDeclarations": [
      "MethodTemplateTest"
    ],
    "MethodDeclarations": [
      "MethodTemplateTest.testGetWithOneParameter()",
      "MethodTemplateTest.testGetWithTwoParameters()",
      "MethodTemplateTest.testTemplateNameCanBeDerivedFromMethodName()",
      "MethodTemplateTest.testWithRawContentSourceContent()",
      "MethodTemplateTest.testWithByteBufContent()",
      "MethodTemplateTest.testWithByteArrayContent()",
      "MethodTemplateTest.testWithStringContent()",
      "MethodTemplateTest.testWithUserClassContent()",
      "MethodTemplateTest.testWithUserClassContentAndNotDefinedContentTransformer()",
      "MethodTemplateTest.testFromFactory()",
      "MethodTemplateTest.testDetectsInvalidResultType()",
      "MethodTemplateTest.testMissingHttpMethod()",
      "MethodTemplateTest.testMultipleContentParameters()"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.lang.equals"
      ],
      "UserDefined": [
        "com.netflix.ribbon.proxy.Utils.methodByName",
        "com.netflix.ribbon.proxy.Utils.methodByName",
        "com.netflix.ribbon.proxy.Utils.methodByName",
        "com.netflix.ribbon.proxy.Utils.methodByName",
        "com.netflix.ribbon.proxy.Utils.methodByName",
        "com.netflix.ribbon.proxy.Utils.methodByName",
        "com.netflix.ribbon.proxy.Utils.methodByName",
        "com.netflix.ribbon.proxy.Utils.methodByName",
        "com.netflix.ribbon.proxy.Utils.methodByName",
        "com.netflix.ribbon.proxy.Utils.methodByName",
        "com.netflix.ribbon.proxy.Utils.methodByName",
        "com.netflix.ribbon.proxy.Utils.methodByName"
      ],
      "Unresolved": [
        "assertEquals",
        "assertEquals",
        "assertEquals",
        "assertEquals",
        "assertEquals",
        "assertEquals",
        "assertEquals",
        "assertEquals",
        "assertEquals",
        "assertEquals",
        "assertEquals",
        "assertNotNull",
        "assertEquals",
        "assertEquals",
        "assertNull",
        "assertEquals",
        "assertNull",
        "assertEquals",
        "assertNull",
        "assertEquals",
        "assertNotNull",
        "assertTrue",
        "assertEquals",
        "getMethods"
      ]
    },
    "Imports": {
      "Movie": "com.netflix.ribbon.proxy.sample.Movie",
      "BrokenMovieService": "com.netflix.ribbon.proxy.sample.MovieServiceInterfaces.BrokenMovieService",
      "PostsWithDifferentContentTypes": "com.netflix.ribbon.proxy.sample.MovieServiceInterfaces.PostsWithDifferentContentTypes",
      "SampleMovieService": "com.netflix.ribbon.proxy.sample.MovieServiceInterfaces.SampleMovieService",
      "TemplateNameDerivedFromMethodName": "com.netflix.ribbon.proxy.sample.MovieServiceInterfaces.TemplateNameDerivedFromMethodName",
      "MovieTransformer": "com.netflix.ribbon.proxy.sample.MovieTransformer",
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "Test": "org.junit.Test",
      "methodByName": "com.netflix.ribbon.proxy.Utils.methodByName",
      "org.junit.Assert.*": "org.junit.Assert"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\test\\java\\com\\netflix\\ribbon\\proxy\\RibbonDynamicProxyTest.java": {
    "TypeDeclarations": [
      "RibbonDynamicProxyTest"
    ],
    "MethodDeclarations": [
      "RibbonDynamicProxyTest.setUp()",
      "RibbonDynamicProxyTest.testAcceptsInterfaceOnly()",
      "RibbonDynamicProxyTest.testSetupWithExplicitResourceGroupObject()",
      "RibbonDynamicProxyTest.testSetupWithResourceGroupNameInAnnotation()",
      "RibbonDynamicProxyTest.testTypedClientGetWithPathParameter()",
      "RibbonDynamicProxyTest.testPlainObjectInvocations()",
      "RibbonDynamicProxyTest.initializeSampleMovieServiceMocks()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.anyObject",
        "org.easymock.EasyMock.anyObject",
        "org.easymock.EasyMock.anyObject",
        "RibbonDynamicProxyTest.initializeSampleMovieServiceMocks",
        "RibbonDynamicProxyTest.initializeSampleMovieServiceMocks",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.anyObject",
        "com.netflix.ribbon.proxy.Utils.methodByName",
        "org.easymock.EasyMock.expect"
      ],
      "Unresolved": [
        "andReturn",
        "replayAll",
        "mockStatic",
        "expectNew",
        "andReturn",
        "replayAll",
        "replayAll",
        "assertNotNull",
        "replayAll",
        "assertFalse",
        "assertEquals",
        "createMock",
        "andReturn",
        "mockStatic",
        "andReturn"
      ]
    },
    "Imports": {
      "RibbonRequest": "com.netflix.ribbon.RibbonRequest",
      "RibbonResourceFactory": "com.netflix.ribbon.RibbonResourceFactory",
      "HttpResourceGroup": "com.netflix.ribbon.http.HttpResourceGroup",
      "AnnotationProcessorsProvider": "com.netflix.ribbon.proxy.processor.AnnotationProcessorsProvider",
      "SampleMovieService": "com.netflix.ribbon.proxy.sample.MovieServiceInterfaces.SampleMovieService",
      "SampleMovieServiceWithResourceGroupNameAnnotation": "com.netflix.ribbon.proxy.sample.MovieServiceInterfaces.SampleMovieServiceWithResourceGroupNameAnnotation",
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "HttpClient": "io.reactivex.netty.protocol.http.client.HttpClient",
      "Before": "org.junit.Before",
      "Test": "org.junit.Test",
      "RunWith": "org.junit.runner.RunWith",
      "Mock": "org.powermock.api.easymock.annotation.Mock",
      "PrepareForTest": "org.powermock.core.classloader.annotations.PrepareForTest",
      "PowerMockRunner": "org.powermock.modules.junit4.PowerMockRunner",
      "Method": "java.lang.reflect.Method",
      "HashMap": "java.util.HashMap",
      "Map": "java.util.Map",
      "methodByName": "com.netflix.ribbon.proxy.Utils.methodByName",
      "anyObject": "org.easymock.EasyMock.anyObject",
      "expect": "org.easymock.EasyMock.expect",
      "org.powermock.api.easymock.PowerMock.*": "org.powermock.api.easymock.PowerMock",
      "org.junit.Assert.*": "org.junit.Assert"
    },
    "FieldTypes": {
      "httpResourceGroupMock": "com.netflix.ribbon.http.HttpResourceGroup",
      "ribbonRequestMock": "com.netflix.ribbon.RibbonRequest",
      "httpClientMock": "io.reactivex.netty.protocol.http.client.HttpClient"
    }
  },
  "ribbon\\ribbon\\src\\test\\java\\com\\netflix\\ribbon\\proxy\\ShutDownTest.java": {
    "TypeDeclarations": [
      "ShutDownTest"
    ],
    "MethodDeclarations": [
      "ShutDownTest.testLifeCycleShutdown()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "org.junit.Assert.assertTrue",
        "org.junit.Assert.assertTrue"
      ],
      "Unresolved": []
    },
    "Imports": {
      "ClientConfigFactory": "com.netflix.client.config.ClientConfigFactory",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "RibbonTransportFactory": "com.netflix.ribbon.RibbonTransportFactory",
      "HttpResourceGroup": "com.netflix.ribbon.http.HttpResourceGroup",
      "SampleMovieService": "com.netflix.ribbon.proxy.sample.MovieServiceInterfaces.SampleMovieService",
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "ObservableConnection": "io.reactivex.netty.channel.ObservableConnection",
      "ClientMetricsEvent": "io.reactivex.netty.client.ClientMetricsEvent",
      "MetricEventsListener": "io.reactivex.netty.metrics.MetricEventsListener",
      "HttpClient": "io.reactivex.netty.protocol.http.client.HttpClient",
      "HttpClientRequest": "io.reactivex.netty.protocol.http.client.HttpClientRequest",
      "HttpClientResponse": "io.reactivex.netty.protocol.http.client.HttpClientResponse",
      "Test": "org.junit.Test",
      "Observable": "rx.Observable",
      "Subscription": "rx.Subscription",
      "AtomicBoolean": "java.util.concurrent.atomic.AtomicBoolean",
      "assertTrue": "org.junit.Assert.assertTrue"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\test\\java\\com\\netflix\\ribbon\\proxy\\UtilsTest.java": {
    "TypeDeclarations": [
      "UtilsTest"
    ],
    "MethodDeclarations": [
      "UtilsTest.testMethodByName()",
      "UtilsTest.testExecuteOnInstance()",
      "UtilsTest.testExecuteNotExistingMethod()",
      "UtilsTest.testNewInstance()",
      "UtilsTest.testNewInstanceForFailure()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "assertNotNull",
        "assertEquals",
        "assertNull",
        "assertEquals",
        "assertEquals",
        "assertNotNull"
      ]
    },
    "Imports": {
      "Test": "org.junit.Test",
      "InputStream": "java.io.InputStream",
      "Method": "java.lang.reflect.Method",
      "junit.framework.Assert.*": "junit.framework.Assert"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\test\\java\\com\\netflix\\ribbon\\proxy\\sample\\HystrixHandlers.java": {
    "TypeDeclarations": [
      "HystrixHandlers",
      "SampleHttpResponseValidator",
      "MovieFallbackHandler"
    ],
    "MethodDeclarations": [
      "SampleHttpResponseValidator.validate(HttpClientResponse)",
      "MovieFallbackHandler.getFallback(HystrixInvokableInfo, Map)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "HystrixInvokableInfo": "com.netflix.hystrix.HystrixInvokableInfo",
      "ServerError": "com.netflix.ribbon.ServerError",
      "UnsuccessfulResponseException": "com.netflix.ribbon.UnsuccessfulResponseException",
      "HttpResponseValidator": "com.netflix.ribbon.http.HttpResponseValidator",
      "FallbackHandler": "com.netflix.ribbon.hystrix.FallbackHandler",
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "HttpClientResponse": "io.reactivex.netty.protocol.http.client.HttpClientResponse",
      "Observable": "rx.Observable",
      "Map": "java.util.Map"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\test\\java\\com\\netflix\\ribbon\\proxy\\sample\\Movie.java": {
    "TypeDeclarations": [
      "Movie"
    ],
    "MethodDeclarations": [],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {},
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\test\\java\\com\\netflix\\ribbon\\proxy\\sample\\MovieServiceInterfaces.java": {
    "TypeDeclarations": [
      "MovieServiceInterfaces",
      "SampleMovieService",
      "ShortMovieService",
      "BrokenMovieService",
      "SampleMovieServiceWithResourceGroupNameAnnotation",
      "SampleMovieServiceWithResourceGroupClassAnnotation",
      "BrokenMovieServiceWithResourceGroupNameAndClassAnnotation",
      "TemplateNameDerivedFromMethodName",
      "HystrixOptionalAnnotationValues",
      "PostsWithDifferentContentTypes"
    ],
    "MethodDeclarations": [
      "SampleMovieService.findMovieById(String)",
      "SampleMovieService.findRawMovieById(String)",
      "SampleMovieService.findMovie(String, String)",
      "SampleMovieService.registerMovie(Movie)",
      "SampleMovieService.updateMovie(String, Movie)",
      "SampleMovieService.updateMoviePartial(String, Movie)",
      "SampleMovieService.registerTitle(String)",
      "SampleMovieService.registerByteBufBinary(ByteBuf)",
      "SampleMovieService.registerByteArrayBinary(BasicType(dimensions=[None], name=byte))",
      "SampleMovieService.deleteMovie(String)",
      "ShortMovieService.findMovieById(String)",
      "ShortMovieService.findAll()",
      "BrokenMovieService.returnTypeNotRibbonRequest()",
      "BrokenMovieService.missingHttpAnnotation()",
      "BrokenMovieService.multipleContentParameters(Movie, Movie)",
      "TemplateNameDerivedFromMethodName.myTemplateName()",
      "HystrixOptionalAnnotationValues.hystrixWithCacheKeyOnly()",
      "HystrixOptionalAnnotationValues.hystrixWithValidatorOnly()",
      "HystrixOptionalAnnotationValues.hystrixWithFallbackHandlerOnly()",
      "PostsWithDifferentContentTypes.postwithRawContentSource(AtomicReference, BasicType(dimensions=[], name=int), Observable)",
      "PostsWithDifferentContentTypes.postwithByteBufContent(ByteBuf)",
      "PostsWithDifferentContentTypes.postwithByteArrayContent(BasicType(dimensions=[None], name=byte))",
      "PostsWithDifferentContentTypes.postwithStringContent(String)",
      "PostsWithDifferentContentTypes.postwithMovieContent(Movie)",
      "PostsWithDifferentContentTypes.postwithMovieContentBroken(Movie)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "RibbonRequest": "com.netflix.ribbon.RibbonRequest",
      "CacheProvider": "com.netflix.ribbon.proxy.annotation.CacheProvider",
      "ClientProperties": "com.netflix.ribbon.proxy.annotation.ClientProperties",
      "Property": "com.netflix.ribbon.proxy.annotation.ClientProperties.Property",
      "Content": "com.netflix.ribbon.proxy.annotation.Content",
      "ContentTransformerClass": "com.netflix.ribbon.proxy.annotation.ContentTransformerClass",
      "Http": "com.netflix.ribbon.proxy.annotation.Http",
      "Header": "com.netflix.ribbon.proxy.annotation.Http.Header",
      "HttpMethod": "com.netflix.ribbon.proxy.annotation.Http.HttpMethod",
      "Hystrix": "com.netflix.ribbon.proxy.annotation.Hystrix",
      "ResourceGroup": "com.netflix.ribbon.proxy.annotation.ResourceGroup",
      "TemplateName": "com.netflix.ribbon.proxy.annotation.TemplateName",
      "Var": "com.netflix.ribbon.proxy.annotation.Var",
      "MovieFallbackHandler": "com.netflix.ribbon.proxy.sample.HystrixHandlers.MovieFallbackHandler",
      "SampleHttpResponseValidator": "com.netflix.ribbon.proxy.sample.HystrixHandlers.SampleHttpResponseValidator",
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "Observable": "rx.Observable",
      "AtomicReference": "java.util.concurrent.atomic.AtomicReference",
      "SampleHttpResourceGroup": "com.netflix.ribbon.proxy.sample.ResourceGroupClasses.SampleHttpResourceGroup"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\test\\java\\com\\netflix\\ribbon\\proxy\\sample\\MovieTransformer.java": {
    "TypeDeclarations": [
      "MovieTransformer"
    ],
    "MethodDeclarations": [
      "MovieTransformer.call(MovieTransformer, ByteBufAllocator)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "ByteBufAllocator": "io.netty.buffer.ByteBufAllocator",
      "ContentTransformer": "io.reactivex.netty.channel.ContentTransformer"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\test\\java\\com\\netflix\\ribbon\\proxy\\sample\\ResourceGroupClasses.java": {
    "TypeDeclarations": [
      "ResourceGroupClasses",
      "SampleHttpResourceGroup"
    ],
    "MethodDeclarations": [],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "HttpResourceGroup": "com.netflix.ribbon.http.HttpResourceGroup"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon\\src\\test\\java\\com\\netflix\\ribbon\\proxy\\sample\\SampleCacheProviderFactory.java": {
    "TypeDeclarations": [
      "SampleCacheProviderFactory",
      "SampleCacheProvider"
    ],
    "MethodDeclarations": [
      "SampleCacheProviderFactory.createCacheProvider()",
      "SampleCacheProvider.get(String, Map)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "CacheProvider": "com.netflix.ribbon.CacheProvider",
      "CacheProviderFactory": "com.netflix.ribbon.CacheProviderFactory",
      "Observable": "rx.Observable",
      "Map": "java.util.Map"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-archaius\\src\\main\\java\\com\\netflix\\client\\SimpleVipAddressResolver.java": {
    "TypeDeclarations": [
      "SimpleVipAddressResolver"
    ],
    "MethodDeclarations": [
      "SimpleVipAddressResolver.resolve(String, IClientConfig)",
      "SimpleVipAddressResolver.replaceMacrosFromConfig(String)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "SimpleVipAddressResolver.replaceMacrosFromConfig"
      ],
      "Unresolved": [
        "java.util.regex.Pattern.matcher",
        "getString",
        "java.util.regex.Pattern.matcher"
      ]
    },
    "Imports": {
      "Matcher": "java.util.regex.Matcher",
      "Pattern": "java.util.regex.Pattern",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "ConfigurationManager": "com.netflix.config.ConfigurationManager"
    },
    "FieldTypes": {
      "VAR_PATTERN": "java.util.regex.Pattern"
    }
  },
  "ribbon\\ribbon-archaius\\src\\main\\java\\com\\netflix\\client\\config\\ArchaiusClientConfigFactory.java": {
    "TypeDeclarations": [
      "ArchaiusClientConfigFactory"
    ],
    "MethodDeclarations": [
      "ArchaiusClientConfigFactory.newConfig()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {},
    "FieldTypes": {}
  },
  "ribbon\\ribbon-archaius\\src\\main\\java\\com\\netflix\\client\\config\\ArchaiusPropertyResolver.java": {
    "TypeDeclarations": [
      "ArchaiusPropertyResolver"
    ],
    "MethodDeclarations": [
      "ArchaiusPropertyResolver.invokeAction(Runnable)",
      "ArchaiusPropertyResolver.get(String, Class)",
      "ArchaiusPropertyResolver.forEach(String, BiConsumer)",
      "ArchaiusPropertyResolver.onChange(Runnable)",
      "ArchaiusPropertyResolver.getActionCount()"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.lang.equals",
        "java.lang.equals",
        "java.lang.equals",
        "java.lang.equals",
        "java.lang.equals",
        "java.lang.equals"
      ],
      "UserDefined": [],
      "Unresolved": [
        "addConfigurationListener",
        "java.util.concurrent.CopyOnWriteArrayList.forEach",
        "org.slf4j.Logger.info",
        "org.apache.commons.configuration.AbstractConfiguration.getInteger",
        "org.apache.commons.configuration.AbstractConfiguration.getBoolean",
        "org.apache.commons.configuration.AbstractConfiguration.getFloat",
        "org.apache.commons.configuration.AbstractConfiguration.getLong",
        "org.apache.commons.configuration.AbstractConfiguration.getDouble",
        "org.apache.commons.configuration.AbstractConfiguration.getString",
        "filter",
        "map",
        "collect",
        "map",
        "orElseThrow",
        "org.apache.commons.configuration.AbstractConfiguration.getStringArray",
        "ifPresent",
        "forEachRemaining",
        "org.apache.commons.configuration.AbstractConfiguration.getString",
        "org.apache.commons.configuration.AbstractConfiguration.subset",
        "java.util.concurrent.CopyOnWriteArrayList.add",
        "java.util.concurrent.CopyOnWriteArrayList.size"
      ]
    },
    "Imports": {
      "ConfigurationManager": "com.netflix.config.ConfigurationManager",
      "AbstractConfiguration": "org.apache.commons.configuration.AbstractConfiguration",
      "ConfigurationEvent": "org.apache.commons.configuration.event.ConfigurationEvent",
      "ConfigurationListener": "org.apache.commons.configuration.event.ConfigurationListener",
      "Logger": "org.slf4j.Logger",
      "LoggerFactory": "org.slf4j.LoggerFactory",
      "Arrays": "java.util.Arrays",
      "Optional": "java.util.Optional",
      "CopyOnWriteArrayList": "java.util.concurrent.CopyOnWriteArrayList",
      "TimeUnit": "java.util.concurrent.TimeUnit",
      "BiConsumer": "java.util.function.BiConsumer",
      "Collectors": "java.util.stream.Collectors"
    },
    "FieldTypes": {
      "LOG": "org.slf4j.Logger",
      "config": "org.apache.commons.configuration.AbstractConfiguration",
      "actions": "java.util.concurrent.CopyOnWriteArrayList"
    }
  },
  "ribbon\\ribbon-archaius\\src\\main\\java\\com\\netflix\\client\\config\\DefaultClientConfigImpl.java": {
    "TypeDeclarations": [
      "DefaultClientConfigImpl"
    ],
    "MethodDeclarations": [
      "DefaultClientConfigImpl.getDefaultPrioritizeVipAddressBasedServers()",
      "DefaultClientConfigImpl.getDefaultNfloadbalancerPingClassname()",
      "DefaultClientConfigImpl.getDefaultNfloadbalancerRuleClassname()",
      "DefaultClientConfigImpl.getDefaultNfloadbalancerClassname()",
      "DefaultClientConfigImpl.getDefaultUseIpAddressForServer()",
      "DefaultClientConfigImpl.getDefaultClientClassname()",
      "DefaultClientConfigImpl.getDefaultVipaddressResolverClassname()",
      "DefaultClientConfigImpl.getDefaultPrimeConnectionsUri()",
      "DefaultClientConfigImpl.getDefaultMaxTotalTimeToPrimeConnections()",
      "DefaultClientConfigImpl.getDefaultMaxRetriesPerServerPrimeConnection()",
      "DefaultClientConfigImpl.getDefaultEnablePrimeConnections()",
      "DefaultClientConfigImpl.getDefaultMaxRequestsAllowedPerWindow()",
      "DefaultClientConfigImpl.getDefaultRequestThrottlingWindowInMillis()",
      "DefaultClientConfigImpl.getDefaultEnableRequestThrottling()",
      "DefaultClientConfigImpl.getDefaultEnableGzipContentEncodingFilter()",
      "DefaultClientConfigImpl.getDefaultConnectionPoolCleanerTaskEnabled()",
      "DefaultClientConfigImpl.getDefaultFollowRedirects()",
      "DefaultClientConfigImpl.getDefaultPercentageNiwsEventLogged()",
      "DefaultClientConfigImpl.getDefaultMaxAutoRetriesNextServer()",
      "DefaultClientConfigImpl.getDefaultMaxAutoRetries()",
      "DefaultClientConfigImpl.getDefaultReadTimeout()",
      "DefaultClientConfigImpl.getDefaultConnectionManagerTimeout()",
      "DefaultClientConfigImpl.getDefaultConnectTimeout()",
      "DefaultClientConfigImpl.getDefaultMaxHttpConnectionsPerHost()",
      "DefaultClientConfigImpl.getDefaultMaxTotalHttpConnections()",
      "DefaultClientConfigImpl.getDefaultMaxConnectionsPerHost()",
      "DefaultClientConfigImpl.getDefaultMaxTotalConnections()",
      "DefaultClientConfigImpl.getDefaultMinPrimeConnectionsRatio()",
      "DefaultClientConfigImpl.getDefaultPrimeConnectionsClass()",
      "DefaultClientConfigImpl.getDefaultSeverListClass()",
      "DefaultClientConfigImpl.getDefaultConnectionIdleTimertaskRepeatInMsecs()",
      "DefaultClientConfigImpl.getDefaultConnectionidleTimeInMsecs()",
      "DefaultClientConfigImpl.getDefaultPoolMaxThreads()",
      "DefaultClientConfigImpl.getDefaultPoolMinThreads()",
      "DefaultClientConfigImpl.getDefaultPoolKeepAliveTime()",
      "DefaultClientConfigImpl.getDefaultPoolKeepAliveTimeUnits()",
      "DefaultClientConfigImpl.getDefaultEnableZoneAffinity()",
      "DefaultClientConfigImpl.getDefaultEnableZoneExclusivity()",
      "DefaultClientConfigImpl.getDefaultPort()",
      "DefaultClientConfigImpl.getDefaultEnableLoadbalancer()",
      "DefaultClientConfigImpl.getDefaultOkToRetryOnAllOperations()",
      "DefaultClientConfigImpl.getDefaultIsClientAuthRequired()",
      "DefaultClientConfigImpl.getDefaultEnableConnectionPool()",
      "DefaultClientConfigImpl.loadDefaultValues()",
      "DefaultClientConfigImpl.setPropertyInternal(IClientConfigKey, Object)",
      "DefaultClientConfigImpl.putDefaultIntegerProperty(IClientConfigKey, Integer)",
      "DefaultClientConfigImpl.putDefaultLongProperty(IClientConfigKey, Long)",
      "DefaultClientConfigImpl.putDefaultFloatProperty(IClientConfigKey, Float)",
      "DefaultClientConfigImpl.putDefaultTimeUnitProperty(IClientConfigKey, TimeUnit)",
      "DefaultClientConfigImpl.putDefaultStringProperty(IClientConfigKey, String)",
      "DefaultClientConfigImpl.putDefaultBooleanProperty(IClientConfigKey, Boolean)",
      "DefaultClientConfigImpl.getDefaultPropName(String)",
      "DefaultClientConfigImpl.getDefaultPropName(IClientConfigKey)",
      "DefaultClientConfigImpl.getInstancePropName(String, IClientConfigKey)",
      "DefaultClientConfigImpl.getInstancePropName(String, String)",
      "DefaultClientConfigImpl.withProperty(IClientConfigKey, Object)",
      "DefaultClientConfigImpl.getEmptyConfig()",
      "DefaultClientConfigImpl.getClientConfigWithDefaultValues(String)",
      "DefaultClientConfigImpl.getClientConfigWithDefaultValues()",
      "DefaultClientConfigImpl.getClientConfigWithDefaultValues(String, String)"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.lang.toString"
      ],
      "UserDefined": [
        "DefaultClientConfigImpl.getDefaultMaxHttpConnectionsPerHost",
        "DefaultClientConfigImpl.getDefaultMaxTotalHttpConnections",
        "DefaultClientConfigImpl.getDefaultEnableConnectionPool",
        "DefaultClientConfigImpl.getDefaultMaxConnectionsPerHost",
        "DefaultClientConfigImpl.getDefaultMaxTotalConnections",
        "DefaultClientConfigImpl.getDefaultConnectTimeout",
        "DefaultClientConfigImpl.getDefaultConnectionManagerTimeout",
        "DefaultClientConfigImpl.getDefaultReadTimeout",
        "DefaultClientConfigImpl.getDefaultMaxAutoRetries",
        "DefaultClientConfigImpl.getDefaultMaxAutoRetriesNextServer",
        "DefaultClientConfigImpl.getDefaultOkToRetryOnAllOperations",
        "DefaultClientConfigImpl.getDefaultFollowRedirects",
        "DefaultClientConfigImpl.getDefaultConnectionPoolCleanerTaskEnabled",
        "DefaultClientConfigImpl.getDefaultConnectionidleTimeInMsecs",
        "DefaultClientConfigImpl.getDefaultConnectionIdleTimertaskRepeatInMsecs",
        "DefaultClientConfigImpl.getDefaultEnableGzipContentEncodingFilter",
        "DefaultClientConfigImpl.getDefaultPort",
        "DefaultClientConfigImpl.getDefaultEnablePrimeConnections",
        "DefaultClientConfigImpl.getDefaultMaxRetriesPerServerPrimeConnection",
        "DefaultClientConfigImpl.getDefaultMaxTotalTimeToPrimeConnections",
        "DefaultClientConfigImpl.getDefaultPrimeConnectionsUri",
        "DefaultClientConfigImpl.getDefaultPoolMinThreads",
        "DefaultClientConfigImpl.getDefaultPoolMaxThreads",
        "DefaultClientConfigImpl.getDefaultPoolKeepAliveTime",
        "DefaultClientConfigImpl.getDefaultPoolKeepAliveTimeUnits",
        "DefaultClientConfigImpl.getDefaultEnableZoneAffinity",
        "DefaultClientConfigImpl.getDefaultEnableZoneExclusivity",
        "DefaultClientConfigImpl.getDefaultClientClassname",
        "DefaultClientConfigImpl.getDefaultNfloadbalancerClassname",
        "DefaultClientConfigImpl.getDefaultNfloadbalancerRuleClassname",
        "DefaultClientConfigImpl.getDefaultNfloadbalancerPingClassname",
        "DefaultClientConfigImpl.getDefaultPrioritizeVipAddressBasedServers",
        "DefaultClientConfigImpl.getDefaultMinPrimeConnectionsRatio",
        "DefaultClientConfigImpl.getDefaultPrimeConnectionsClass",
        "DefaultClientConfigImpl.getDefaultSeverListClass",
        "DefaultClientConfigImpl.getDefaultVipaddressResolverClassname",
        "DefaultClientConfigImpl.getDefaultIsClientAuthRequired",
        "DefaultClientConfigImpl.getDefaultUseIpAddressForServer",
        "DefaultClientConfigImpl.getDefaultPropName",
        "DefaultClientConfigImpl.getInstancePropName",
        "DefaultClientConfigImpl.getClientConfigWithDefaultValues",
        "DefaultClientConfigImpl.getClientConfigWithDefaultValues"
      ],
      "Unresolved": [
        "setDefault",
        "setDefault",
        "setDefault",
        "setDefault",
        "setDefault",
        "setDefault",
        "setDefault",
        "setDefault",
        "setDefault",
        "setDefault",
        "setDefault",
        "setDefault",
        "setDefault",
        "setDefault",
        "setDefault",
        "setDefault",
        "setDefault",
        "setDefault",
        "setDefault",
        "setDefault",
        "setDefault",
        "setDefault",
        "setDefault",
        "setDefault",
        "setDefault",
        "setDefault",
        "setDefault",
        "setDefault",
        "setDefault",
        "setDefault",
        "setDefault",
        "setDefault",
        "setDefault",
        "setDefault",
        "setDefault",
        "setDefault",
        "setDefault",
        "setDefault",
        "setDefault",
        "setDefault",
        "setDefault",
        "set",
        "set",
        "set",
        "set",
        "set",
        "set",
        "set",
        "getNameSpace",
        "getNameSpace",
        "getNameSpace",
        "setProperty"
      ]
    },
    "Imports": {
      "TimeUnit": "java.util.concurrent.TimeUnit"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-archaius\\src\\main\\java\\com\\netflix\\utils\\ScheduledThreadPoolExectuorWithDynamicSize.java": {
    "TypeDeclarations": [
      "ScheduledThreadPoolExectuorWithDynamicSize"
    ],
    "MethodDeclarations": [],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "setCorePoolSize",
        "shutdown",
        "removeShutdownHook",
        "addShutdownHook"
      ]
    },
    "Imports": {
      "ScheduledThreadPoolExecutor": "java.util.concurrent.ScheduledThreadPoolExecutor",
      "ThreadFactory": "java.util.concurrent.ThreadFactory",
      "DynamicIntProperty": "com.netflix.config.DynamicIntProperty"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-core\\src\\main\\java\\com\\netflix\\client\\ClientException.java": {
    "TypeDeclarations": [
      "ClientException",
      "ErrorType"
    ],
    "MethodDeclarations": [
      "ErrorType.getName(BasicType(dimensions=[], name=int))",
      "ClientException.getErrorType()",
      "ClientException.getErrorCode()",
      "ClientException.setErrorCode(BasicType(dimensions=[], name=int))",
      "ClientException.getErrorMessage()",
      "ClientException.setErrorMessage(String)",
      "ClientException.getErrorObject()",
      "ClientException.setErrorObject(Object)",
      "ClientException.getInternalMessage()",
      "ClientException.getErrorCodes(Class)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "ErrorType.getName"
      ],
      "Unresolved": [
        "values",
        "name",
        "getModifiers",
        "get"
      ]
    },
    "Imports": {
      "Field": "java.lang.reflect.Field",
      "Modifier": "java.lang.reflect.Modifier",
      "HashMap": "java.util.HashMap"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-core\\src\\main\\java\\com\\netflix\\client\\ClientRequest.java": {
    "TypeDeclarations": [
      "ClientRequest"
    ],
    "MethodDeclarations": [
      "ClientRequest.getUri()",
      "ClientRequest.setUri(URI)",
      "ClientRequest.getLoadBalancerKey()",
      "ClientRequest.setLoadBalancerKey(Object)",
      "ClientRequest.isRetriable()",
      "ClientRequest.setRetriable(BasicType(dimensions=[], name=boolean))",
      "ClientRequest.getOverrideConfig()",
      "ClientRequest.setOverrideConfig(IClientConfig)",
      "ClientRequest.replaceUri(URI)"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.lang.clone"
      ],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "URI": "java.net.URI",
      "IClientConfig": "com.netflix.client.config.IClientConfig"
    },
    "FieldTypes": {
      "uri": "java.net.URI",
      "overrideConfig": "com.netflix.client.config.IClientConfig"
    }
  },
  "ribbon\\ribbon-core\\src\\main\\java\\com\\netflix\\client\\DefaultLoadBalancerRetryHandler.java": {
    "TypeDeclarations": [
      "DefaultLoadBalancerRetryHandler"
    ],
    "MethodDeclarations": [
      "DefaultLoadBalancerRetryHandler.isRetriableException(Throwable, BasicType(dimensions=[], name=boolean))",
      "DefaultLoadBalancerRetryHandler.isCircuitTrippingException(Throwable)",
      "DefaultLoadBalancerRetryHandler.getMaxRetriesOnSameServer()",
      "DefaultLoadBalancerRetryHandler.getMaxRetriesOnNextServer()",
      "DefaultLoadBalancerRetryHandler.getRetriableExceptions()",
      "DefaultLoadBalancerRetryHandler.getCircuitRelatedExceptions()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "com.google.common.collect.Lists",
        "com.google.common.collect.Lists",
        "DefaultLoadBalancerRetryHandler.getRetriableExceptions",
        "DefaultLoadBalancerRetryHandler.getCircuitRelatedExceptions"
      ],
      "Unresolved": []
    },
    "Imports": {
      "Lists": "com.google.common.collect.Lists",
      "CommonClientConfigKey": "com.netflix.client.config.CommonClientConfigKey",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "ConnectException": "java.net.ConnectException",
      "SocketException": "java.net.SocketException",
      "SocketTimeoutException": "java.net.SocketTimeoutException",
      "List": "java.util.List"
    },
    "FieldTypes": {
      "retriable": "java.util.List",
      "circuitRelated": "java.util.List"
    }
  },
  "ribbon\\ribbon-core\\src\\main\\java\\com\\netflix\\client\\IClient.java": {
    "TypeDeclarations": [
      "IClient"
    ],
    "MethodDeclarations": [
      "IClient.execute(S, IClientConfig)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "IClientConfig": "com.netflix.client.config.IClientConfig"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-core\\src\\main\\java\\com\\netflix\\client\\IClientConfigAware.java": {
    "TypeDeclarations": [
      "IClientConfigAware",
      "Factory"
    ],
    "MethodDeclarations": [
      "Factory.create(String, IClientConfig)",
      "IClientConfigAware.initWithNiwsConfig(IClientConfig)",
      "IClientConfigAware.initWithNiwsConfig(IClientConfig, Factory)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "initWithNiwsConfig"
      ]
    },
    "Imports": {
      "IClientConfig": "com.netflix.client.config.IClientConfig"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-core\\src\\main\\java\\com\\netflix\\client\\IResponse.java": {
    "TypeDeclarations": [
      "IResponse"
    ],
    "MethodDeclarations": [
      "IResponse.getPayload()",
      "IResponse.hasPayload()",
      "IResponse.isSuccess()",
      "IResponse.getRequestedURI()",
      "IResponse.getHeaders()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "Closeable": "java.io.Closeable",
      "URI": "java.net.URI",
      "Map": "java.util.Map"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-core\\src\\main\\java\\com\\netflix\\client\\RequestSpecificRetryHandler.java": {
    "TypeDeclarations": [
      "RequestSpecificRetryHandler"
    ],
    "MethodDeclarations": [
      "RequestSpecificRetryHandler.isConnectionException(Throwable)",
      "RequestSpecificRetryHandler.isRetriableException(Throwable, BasicType(dimensions=[], name=boolean))",
      "RequestSpecificRetryHandler.isCircuitTrippingException(Throwable)",
      "RequestSpecificRetryHandler.getMaxRetriesOnSameServer()",
      "RequestSpecificRetryHandler.getMaxRetriesOnNextServer()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "com.google.common.collect.Lists",
        "RequestSpecificRetryHandler.isConnectionException"
      ],
      "Unresolved": [
        "ifPresent",
        "ifPresent"
      ]
    },
    "Imports": {
      "Preconditions": "com.google.common.base.Preconditions",
      "Lists": "com.google.common.collect.Lists",
      "CommonClientConfigKey": "com.netflix.client.config.CommonClientConfigKey",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "Nullable": "javax.annotation.Nullable",
      "SocketException": "java.net.SocketException",
      "List": "java.util.List",
      "Optional": "java.util.Optional"
    },
    "FieldTypes": {
      "connectionRelated": "java.util.List"
    }
  },
  "ribbon\\ribbon-core\\src\\main\\java\\com\\netflix\\client\\RetryHandler.java": {
    "TypeDeclarations": [
      "RetryHandler"
    ],
    "MethodDeclarations": [
      "RetryHandler.isRetriableException(Throwable, BasicType(dimensions=[], name=boolean))",
      "RetryHandler.isCircuitTrippingException(Throwable)",
      "RetryHandler.getMaxRetriesOnSameServer()",
      "RetryHandler.getMaxRetriesOnNextServer()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "ConnectException": "java.net.ConnectException"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-core\\src\\main\\java\\com\\netflix\\client\\Utils.java": {
    "TypeDeclarations": [
      "Utils"
    ],
    "MethodDeclarations": [
      "Utils.isPresentAsCause(Throwable, Collection)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "Collection": "java.util.Collection"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-core\\src\\main\\java\\com\\netflix\\client\\VipAddressResolver.java": {
    "TypeDeclarations": [
      "VipAddressResolver"
    ],
    "MethodDeclarations": [
      "VipAddressResolver.resolve(String, IClientConfig)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "IClientConfig": "com.netflix.client.config.IClientConfig"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-core\\src\\main\\java\\com\\netflix\\client\\config\\AbstractDefaultClientConfigImpl.java": {
    "TypeDeclarations": [
      "AbstractDefaultClientConfigImpl"
    ],
    "MethodDeclarations": [
      "AbstractDefaultClientConfigImpl.setVipAddressResolver(VipAddressResolver)",
      "AbstractDefaultClientConfigImpl.getResolver()",
      "AbstractDefaultClientConfigImpl.getVipAddressResolver()",
      "AbstractDefaultClientConfigImpl.resolveDeploymentContextbasedVipAddresses()",
      "AbstractDefaultClientConfigImpl.getAppName()",
      "AbstractDefaultClientConfigImpl.getVersion()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "AbstractDefaultClientConfigImpl.getVipAddressResolver"
      ],
      "Unresolved": [
        "newInstance",
        "getOrDefault",
        "get",
        "resolve",
        "get",
        "get"
      ]
    },
    "Imports": {
      "VipAddressResolver": "com.netflix.client.VipAddressResolver",
      "TimeUnit": "java.util.concurrent.TimeUnit"
    },
    "FieldTypes": {
      "DEFAULT_POOL_KEEP_ALIVE_TIME_UNITS": "java.util.concurrent.TimeUnit",
      "vipResolver": "com.netflix.client.VipAddressResolver"
    }
  },
  "ribbon\\ribbon-core\\src\\main\\java\\com\\netflix\\client\\config\\ClientConfigFactory.java": {
    "TypeDeclarations": [
      "ClientConfigFactory"
    ],
    "MethodDeclarations": [
      "ClientConfigFactory.newConfig()",
      "ClientConfigFactory.getPriority()",
      "ClientConfigFactory.findDefaultConfigFactory()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "ClientConfigFactory.findDefaultConfigFactory"
      ],
      "Unresolved": [
        "sorted",
        "thenComparing",
        "getCanonicalName",
        "reversed",
        "findFirst",
        "orElseGet",
        "spliterator"
      ]
    },
    "Imports": {
      "Comparator": "java.util.Comparator",
      "ServiceLoader": "java.util.ServiceLoader",
      "StreamSupport": "java.util.stream.StreamSupport"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-core\\src\\main\\java\\com\\netflix\\client\\config\\CommonClientConfigKey.java": {
    "TypeDeclarations": [
      "CommonClientConfigKey"
    ],
    "MethodDeclarations": [
      "CommonClientConfigKey.values()",
      "CommonClientConfigKey.keys()",
      "CommonClientConfigKey.valueOf(String)",
      "CommonClientConfigKey.type()",
      "CommonClientConfigKey.key()",
      "CommonClientConfigKey.toString()",
      "CommonClientConfigKey.defaultValue()",
      "CommonClientConfigKey.equals(Object)",
      "CommonClientConfigKey.hashCode()"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.util.Set.add",
        "java.lang.getClass",
        "java.lang.getClass"
      ],
      "UserDefined": [
        "CommonClientConfigKey.keys",
        "CommonClientConfigKey.keys",
        "CommonClientConfigKey.equals",
        "com.google.common.base.Preconditions.checkArgument"
      ],
      "Unresolved": [
        "getDeclaredFields",
        "isAssignableFrom",
        "toArray",
        "getGenericSuperclass",
        "getRawType"
      ]
    },
    "Imports": {
      "TypeToken": "com.google.common.reflect.TypeToken",
      "Field": "java.lang.reflect.Field",
      "Modifier": "java.lang.reflect.Modifier",
      "ParameterizedType": "java.lang.reflect.ParameterizedType",
      "Type": "java.lang.reflect.Type",
      "HashSet": "java.util.HashSet",
      "Objects": "java.util.Objects",
      "Set": "java.util.Set",
      "TimeUnit": "java.util.concurrent.TimeUnit",
      "checkArgument": "com.google.common.base.Preconditions.checkArgument"
    },
    "FieldTypes": {
      "keys": "java.util.Set"
    }
  },
  "ribbon\\ribbon-core\\src\\main\\java\\com\\netflix\\client\\config\\FallbackProperty.java": {
    "TypeDeclarations": [
      "FallbackProperty"
    ],
    "MethodDeclarations": [
      "FallbackProperty.onChange(Consumer)",
      "FallbackProperty.get()",
      "FallbackProperty.getOrDefault()",
      "FallbackProperty.toString()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "FallbackProperty.getOrDefault",
        "FallbackProperty.getOrDefault",
        "FallbackProperty.get"
      ],
      "Unresolved": [
        "orElseGet"
      ]
    },
    "Imports": {
      "Optional": "java.util.Optional",
      "Consumer": "java.util.function.Consumer"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-core\\src\\main\\java\\com\\netflix\\client\\config\\IClientConfig.java": {
    "TypeDeclarations": [
      "IClientConfig",
      "Builder"
    ],
    "MethodDeclarations": [
      "IClientConfig.getClientName()",
      "IClientConfig.getNameSpace()",
      "IClientConfig.setNameSpace(String)",
      "IClientConfig.loadProperties(String)",
      "IClientConfig.loadDefaultValues()",
      "IClientConfig.getProperties()",
      "IClientConfig.forEach(BiConsumer)",
      "IClientConfig.setProperty(IClientConfigKey, Object)",
      "IClientConfig.getProperty(IClientConfigKey)",
      "IClientConfig.getProperty(IClientConfigKey, Object)",
      "IClientConfig.containsProperty(IClientConfigKey)",
      "IClientConfig.resolveDeploymentContextbasedVipAddresses()",
      "IClientConfig.getPropertyAsInteger(IClientConfigKey, BasicType(dimensions=[], name=int))",
      "IClientConfig.getPropertyAsString(IClientConfigKey, String)",
      "IClientConfig.getPropertyAsBoolean(IClientConfigKey, BasicType(dimensions=[], name=boolean))",
      "IClientConfig.get(IClientConfigKey)",
      "IClientConfig.getOrDefault(IClientConfigKey)",
      "IClientConfig.getIfSet(IClientConfigKey)",
      "IClientConfig.getGlobalProperty(IClientConfigKey)",
      "IClientConfig.getDynamicProperty(IClientConfigKey)",
      "IClientConfig.getPrefixMappedProperty(IClientConfigKey)",
      "IClientConfig.get(IClientConfigKey, T)",
      "IClientConfig.set(IClientConfigKey, T)",
      "Builder.newBuilder()",
      "Builder.newBuilder(String)",
      "Builder.newBuilder(String, String)",
      "Builder.newBuilder(Class, String)",
      "Builder.newBuilder(Class)",
      "Builder.build()",
      "Builder.withDefaultValues()",
      "Builder.withDeploymentContextBasedVipAddresses(String)",
      "Builder.withForceClientPortConfiguration(BasicType(dimensions=[], name=boolean))",
      "Builder.withMaxAutoRetries(BasicType(dimensions=[], name=int))",
      "Builder.withMaxAutoRetriesNextServer(BasicType(dimensions=[], name=int))",
      "Builder.withRetryOnAllOperations(BasicType(dimensions=[], name=boolean))",
      "Builder.withRequestSpecificRetryOn(BasicType(dimensions=[], name=boolean))",
      "Builder.withEnablePrimeConnections(BasicType(dimensions=[], name=boolean))",
      "Builder.withMaxConnectionsPerHost(BasicType(dimensions=[], name=int))",
      "Builder.withMaxTotalConnections(BasicType(dimensions=[], name=int))",
      "Builder.withSecure(BasicType(dimensions=[], name=boolean))",
      "Builder.withConnectTimeout(BasicType(dimensions=[], name=int))",
      "Builder.withReadTimeout(BasicType(dimensions=[], name=int))",
      "Builder.withConnectionManagerTimeout(BasicType(dimensions=[], name=int))",
      "Builder.withFollowRedirects(BasicType(dimensions=[], name=boolean))",
      "Builder.withConnectionPoolCleanerTaskEnabled(BasicType(dimensions=[], name=boolean))",
      "Builder.withConnIdleEvictTimeMilliSeconds(BasicType(dimensions=[], name=int))",
      "Builder.withConnectionCleanerRepeatIntervalMills(BasicType(dimensions=[], name=int))",
      "Builder.withGZIPContentEncodingFilterEnabled(BasicType(dimensions=[], name=boolean))",
      "Builder.withProxyHost(String)",
      "Builder.withProxyPort(BasicType(dimensions=[], name=int))",
      "Builder.withKeyStore(String)",
      "Builder.withKeyStorePassword(String)",
      "Builder.withTrustStore(String)",
      "Builder.withTrustStorePassword(String)",
      "Builder.withClientAuthRequired(BasicType(dimensions=[], name=boolean))",
      "Builder.withCustomSSLSocketFactoryClassName(String)",
      "Builder.withHostnameValidationRequired(BasicType(dimensions=[], name=boolean))",
      "Builder.ignoreUserTokenInConnectionPoolForSecureClient(BasicType(dimensions=[], name=boolean))",
      "Builder.withLoadBalancerEnabled(BasicType(dimensions=[], name=boolean))",
      "Builder.withServerListRefreshIntervalMills(BasicType(dimensions=[], name=int))",
      "Builder.withZoneAffinityEnabled(BasicType(dimensions=[], name=boolean))",
      "Builder.withZoneExclusivityEnabled(BasicType(dimensions=[], name=boolean))",
      "Builder.prioritizeVipAddressBasedServers(BasicType(dimensions=[], name=boolean))",
      "Builder.withTargetRegion(String)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "get",
        "get",
        "newConfig",
        "newConfig",
        "newConfig"
      ]
    },
    "Imports": {
      "Map": "java.util.Map",
      "Optional": "java.util.Optional",
      "BiConsumer": "java.util.function.BiConsumer"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-core\\src\\main\\java\\com\\netflix\\client\\config\\IClientConfigKey.java": {
    "TypeDeclarations": [
      "IClientConfigKey",
      "Keys"
    ],
    "MethodDeclarations": [
      "IClientConfigKey.key()",
      "IClientConfigKey.type()",
      "IClientConfigKey.defaultValue()",
      "IClientConfigKey.format(Object)",
      "IClientConfigKey.create(String, Class, T)"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.lang.hashCode",
        "java.lang.equals"
      ],
      "UserDefined": [],
      "Unresolved": [
        "create",
        "key",
        "type",
        "defaultValue",
        "key",
        "key",
        "key"
      ]
    },
    "Imports": {},
    "FieldTypes": {}
  },
  "ribbon\\ribbon-core\\src\\main\\java\\com\\netflix\\client\\config\\Property.java": {
    "TypeDeclarations": [
      "Property"
    ],
    "MethodDeclarations": [
      "Property.onChange(Consumer)",
      "Property.get()",
      "Property.getOrDefault()",
      "Property.fallbackWith(Property)",
      "Property.of(T)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "Optional": "java.util.Optional",
      "Consumer": "java.util.function.Consumer"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-core\\src\\main\\java\\com\\netflix\\client\\config\\PropertyResolver.java": {
    "TypeDeclarations": [
      "PropertyResolver"
    ],
    "MethodDeclarations": [
      "PropertyResolver.get(String, Class)",
      "PropertyResolver.forEach(String, BiConsumer)",
      "PropertyResolver.onChange(Runnable)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "Optional": "java.util.Optional",
      "BiConsumer": "java.util.function.BiConsumer"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-core\\src\\main\\java\\com\\netflix\\client\\config\\PropertyUtils.java": {
    "TypeDeclarations": [
      "PropertyUtils"
    ],
    "MethodDeclarations": [
      "PropertyUtils.resolveWithValueOf(Class, String)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "java.util.Map.computeIfAbsent",
        "map",
        "org.slf4j.Logger.warn"
      ]
    },
    "Imports": {
      "Logger": "org.slf4j.Logger",
      "LoggerFactory": "org.slf4j.LoggerFactory",
      "Method": "java.lang.reflect.Method",
      "Map": "java.util.Map",
      "Optional": "java.util.Optional",
      "ConcurrentHashMap": "java.util.concurrent.ConcurrentHashMap"
    },
    "FieldTypes": {
      "LOG": "org.slf4j.Logger",
      "valueOfMethods": "java.util.Map"
    }
  },
  "ribbon\\ribbon-core\\src\\main\\java\\com\\netflix\\client\\config\\ReloadableClientConfig.java": {
    "TypeDeclarations": [
      "ReloadableClientConfig",
      "ReloadableProperty"
    ],
    "MethodDeclarations": [
      "ReloadableClientConfig.getPropertyResolver()",
      "ReloadableClientConfig.reload()",
      "ReloadableClientConfig.setClientName(String)",
      "ReloadableClientConfig.getClientName()",
      "ReloadableClientConfig.getNameSpace()",
      "ReloadableClientConfig.setNameSpace(String)",
      "ReloadableClientConfig.loadProperties(String)",
      "ReloadableClientConfig.getProperties()",
      "ReloadableClientConfig.forEach(BiConsumer)",
      "ReloadableClientConfig.autoRefreshFromPropertyResolver(IClientConfigKey)",
      "ReloadableProperty.reload()",
      "ReloadableClientConfig.getOrCreateProperty(IClientConfigKey, Supplier, Supplier)",
      "ReloadableClientConfig.get(IClientConfigKey)",
      "ReloadableClientConfig.getGlobalProperty(IClientConfigKey)",
      "ReloadableClientConfig.getDynamicProperty(IClientConfigKey)",
      "ReloadableClientConfig.getPrefixMappedProperty(IClientConfigKey)",
      "ReloadableClientConfig.resolveFromPropertyResolver(IClientConfigKey)",
      "ReloadableClientConfig.getIfSet(IClientConfigKey)",
      "ReloadableClientConfig.resolveValueToType(IClientConfigKey, Object)",
      "ReloadableClientConfig.getPrefixedMapPropertySupplier(IClientConfigKey)",
      "ReloadableClientConfig.get(IClientConfigKey, T)",
      "ReloadableClientConfig.setDefault(IClientConfigKey)",
      "ReloadableClientConfig.setDefault(IClientConfigKey, T)",
      "ReloadableClientConfig.set(IClientConfigKey, T)",
      "ReloadableClientConfig.setProperty(IClientConfigKey, Object)",
      "ReloadableClientConfig.getProperty(IClientConfigKey)",
      "ReloadableClientConfig.getProperty(IClientConfigKey, Object)",
      "ReloadableClientConfig.containsProperty(IClientConfigKey)",
      "ReloadableClientConfig.getPropertyAsInteger(IClientConfigKey, BasicType(dimensions=[], name=int))",
      "ReloadableClientConfig.getPropertyAsString(IClientConfigKey, String)",
      "ReloadableClientConfig.getPropertyAsBoolean(IClientConfigKey, BasicType(dimensions=[], name=boolean))",
      "ReloadableClientConfig.applyOverride(IClientConfig)",
      "ReloadableClientConfig.toString()",
      "ReloadableClientConfig.getRefreshCount()",
      "ReloadableClientConfig.generateToString()"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.util.Map.values",
        "java.util.Map.values",
        "java.util.Map.size",
        "java.util.Map.put",
        "java.util.Map.put",
        "java.util.List.add",
        "java.util.Map.get",
        "java.util.Map.get",
        "java.lang.equals",
        "java.lang.equals",
        "java.lang.equals",
        "java.lang.equals",
        "java.lang.equals",
        "java.lang.equals",
        "java.lang.equals",
        "java.lang.equals",
        "java.util.Map.put",
        "java.util.Map.put",
        "java.util.Map.put",
        "java.util.Map.containsKey",
        "java.util.Map.entrySet"
      ],
      "UserDefined": [
        "ReloadableProperty.reload"
      ],
      "Unresolved": [
        "forEach",
        "forEach",
        "org.slf4j.Logger.info",
        "loadDefaultValues",
        "java.util.Map.forEach",
        "org.slf4j.Logger.info",
        "forEach",
        "java.util.Map.forEach",
        "java.util.Map.computeIfAbsent",
        "resolveFromPropertyResolver",
        "java.util.Optional.isPresent",
        "org.slf4j.Logger.info",
        "java.util.Map.computeIfAbsent",
        "java.util.Optional.orElse",
        "java.util.concurrent.atomic.AtomicLong.incrementAndGet",
        "java.util.List.forEach",
        "get",
        "set",
        "org.slf4j.Logger.debug",
        "getOrCreateProperty",
        "org.slf4j.Logger.debug",
        "getNameSpace",
        "get",
        "getOrCreateProperty",
        "java.util.Map.getOrDefault",
        "org.slf4j.Logger.debug",
        "getNameSpace",
        "getOrCreateProperty",
        "getPrefixedMapPropertySupplier",
        "getNameSpace",
        "getNameSpace",
        "java.util.Map.getOrDefault",
        "orElseThrow",
        "orElseThrow",
        "getDeclaredMethod",
        "getName",
        "getNameSpace",
        "getNameSpace",
        "org.slf4j.Logger.warn",
        "orElse",
        "get",
        "setDefault",
        "resolveFromPropertyResolver",
        "orElse",
        "autoRefreshFromPropertyResolver",
        "resolveValueToType",
        "resolveFromPropertyResolver",
        "orElse",
        "autoRefreshFromPropertyResolver",
        "set",
        "get",
        "orElse",
        "get",
        "map",
        "orElse",
        "getProperty",
        "map",
        "orElse",
        "getProperty",
        "map",
        "orElse",
        "getProperty",
        "setProperty",
        "generateToString",
        "java.util.concurrent.atomic.AtomicLong.get",
        "stream",
        "map",
        "key",
        "endsWith",
        "isPresent",
        "orElse",
        "collect"
      ]
    },
    "Imports": {
      "Preconditions": "com.google.common.base.Preconditions",
      "StringUtils": "org.apache.commons.lang.StringUtils",
      "Logger": "org.slf4j.Logger",
      "LoggerFactory": "org.slf4j.LoggerFactory",
      "Method": "java.lang.reflect.Method",
      "HashMap": "java.util.HashMap",
      "List": "java.util.List",
      "Map": "java.util.Map",
      "Optional": "java.util.Optional",
      "ConcurrentHashMap": "java.util.concurrent.ConcurrentHashMap",
      "CopyOnWriteArrayList": "java.util.concurrent.CopyOnWriteArrayList",
      "TimeUnit": "java.util.concurrent.TimeUnit",
      "AtomicLong": "java.util.concurrent.atomic.AtomicLong",
      "AtomicReference": "java.util.concurrent.atomic.AtomicReference",
      "BiConsumer": "java.util.function.BiConsumer",
      "Consumer": "java.util.function.Consumer",
      "Supplier": "java.util.function.Supplier",
      "Collectors": "java.util.stream.Collectors"
    },
    "FieldTypes": {
      "LOG": "org.slf4j.Logger",
      "internalProperties": "java.util.Map",
      "dynamicProperties": "java.util.Map",
      "changeActions": "java.util.Map",
      "refreshCounter": "java.util.concurrent.atomic.AtomicLong",
      "current": "java.util.Optional",
      "consumers": "java.util.List"
    }
  },
  "ribbon\\ribbon-core\\src\\main\\java\\com\\netflix\\client\\config\\UnboxedIntProperty.java": {
    "TypeDeclarations": [
      "UnboxedIntProperty"
    ],
    "MethodDeclarations": [
      "UnboxedIntProperty.get()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {},
    "FieldTypes": {}
  },
  "ribbon\\ribbon-core\\src\\main\\java\\com\\netflix\\client\\http\\UnexpectedHttpResponseException.java": {
    "TypeDeclarations": [
      "UnexpectedHttpResponseException"
    ],
    "MethodDeclarations": [
      "UnexpectedHttpResponseException.getStatusCode()",
      "UnexpectedHttpResponseException.getStatusLine()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {},
    "FieldTypes": {}
  },
  "ribbon\\ribbon-core\\src\\main\\java\\com\\netflix\\client\\ssl\\AbstractSslContextFactory.java": {
    "TypeDeclarations": [
      "AbstractSslContextFactory"
    ],
    "MethodDeclarations": [
      "AbstractSslContextFactory.getKeyStore()",
      "AbstractSslContextFactory.getTrustStore()",
      "AbstractSslContextFactory.getKeyStorePasswordLength()",
      "AbstractSslContextFactory.getTrustStorePasswordLength()",
      "AbstractSslContextFactory.createSSLContext()",
      "AbstractSslContextFactory.createKeyManagers()",
      "AbstractSslContextFactory.createTrustManagers()",
      "AbstractSslContextFactory.getSSLContext()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "AbstractSslContextFactory.createKeyManagers",
        "AbstractSslContextFactory.createTrustManagers",
        "AbstractSslContextFactory.createSSLContext"
      ],
      "Unresolved": [
        "toCharArray",
        "org.slf4j.Logger.debug",
        "org.slf4j.Logger.debug"
      ]
    },
    "Imports": {
      "KeyManagementException": "java.security.KeyManagementException",
      "KeyStore": "java.security.KeyStore",
      "KeyStoreException": "java.security.KeyStoreException",
      "NoSuchAlgorithmException": "java.security.NoSuchAlgorithmException",
      "UnrecoverableKeyException": "java.security.UnrecoverableKeyException",
      "KeyManager": "javax.net.ssl.KeyManager",
      "KeyManagerFactory": "javax.net.ssl.KeyManagerFactory",
      "SSLContext": "javax.net.ssl.SSLContext",
      "TrustManager": "javax.net.ssl.TrustManager",
      "TrustManagerFactory": "javax.net.ssl.TrustManagerFactory",
      "Logger": "org.slf4j.Logger",
      "LoggerFactory": "org.slf4j.LoggerFactory"
    },
    "FieldTypes": {
      "LOGGER": "org.slf4j.Logger",
      "keyStore": "java.security.KeyStore",
      "trustStore": "java.security.KeyStore"
    }
  },
  "ribbon\\ribbon-core\\src\\main\\java\\com\\netflix\\client\\ssl\\ClientSslSocketFactoryException.java": {
    "TypeDeclarations": [
      "ClientSslSocketFactoryException"
    ],
    "MethodDeclarations": [],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {},
    "FieldTypes": {}
  },
  "ribbon\\ribbon-core\\src\\main\\java\\com\\netflix\\client\\ssl\\URLSslContextFactory.java": {
    "TypeDeclarations": [
      "URLSslContextFactory"
    ],
    "MethodDeclarations": [
      "URLSslContextFactory.createKeyStore(URL, String)",
      "URLSslContextFactory.toString()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "URLSslContextFactory.createKeyStore",
        "URLSslContextFactory.createKeyStore"
      ],
      "Unresolved": [
        "org.slf4j.Logger.info",
        "org.slf4j.Logger.info",
        "append",
        "getTrustStorePasswordLength",
        "append",
        "getKeyStorePasswordLength"
      ]
    },
    "Imports": {
      "IOException": "java.io.IOException",
      "InputStream": "java.io.InputStream",
      "URL": "java.net.URL",
      "KeyStore": "java.security.KeyStore",
      "KeyStoreException": "java.security.KeyStoreException",
      "NoSuchAlgorithmException": "java.security.NoSuchAlgorithmException",
      "CertificateException": "java.security.cert.CertificateException",
      "StringUtils": "org.apache.commons.lang.StringUtils",
      "Logger": "org.slf4j.Logger",
      "LoggerFactory": "org.slf4j.LoggerFactory",
      "Preconditions": "com.google.common.base.Preconditions",
      "Strings": "com.google.common.base.Strings"
    },
    "FieldTypes": {
      "LOGGER": "org.slf4j.Logger",
      "keyStoreUrl": "java.net.URL",
      "trustStoreUrl": "java.net.URL"
    }
  },
  "ribbon\\ribbon-core\\src\\main\\java\\com\\netflix\\client\\util\\Resources.java": {
    "TypeDeclarations": [
      "Resources"
    ],
    "MethodDeclarations": [
      "Resources.getResource(String)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "getContextClassLoader",
        "toURI",
        "toURL",
        "org.slf4j.Logger.error"
      ]
    },
    "Imports": {
      "File": "java.io.File",
      "URL": "java.net.URL",
      "URLDecoder": "java.net.URLDecoder",
      "Logger": "org.slf4j.Logger",
      "LoggerFactory": "org.slf4j.LoggerFactory"
    },
    "FieldTypes": {
      "logger": "org.slf4j.Logger"
    }
  },
  "ribbon\\ribbon-core\\src\\test\\java\\com\\netflix\\client\\config\\ArchaiusPropertyResolverTest.java": {
    "TypeDeclarations": [
      "ArchaiusPropertyResolverTest"
    ],
    "MethodDeclarations": [
      "ArchaiusPropertyResolverTest.mapFromPrefixedKeys()",
      "ArchaiusPropertyResolverTest.noCallbackIfNoValues()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "org.junit.rules.TestName.getMethodName",
        "org.junit.rules.TestName.getMethodName"
      ]
    },
    "Imports": {
      "ConfigurationManager": "com.netflix.config.ConfigurationManager",
      "AbstractConfiguration": "org.apache.commons.configuration.AbstractConfiguration",
      "Assert": "org.junit.Assert",
      "Rule": "org.junit.Rule",
      "Test": "org.junit.Test",
      "TestName": "org.junit.rules.TestName",
      "Map": "java.util.Map",
      "TreeMap": "java.util.TreeMap"
    },
    "FieldTypes": {
      "testName": "org.junit.rules.TestName"
    }
  },
  "ribbon\\ribbon-core\\src\\test\\java\\com\\netflix\\client\\config\\ClientConfigTest.java": {
    "TypeDeclarations": [
      "ClientConfigTest",
      "CustomValueOf"
    ],
    "MethodDeclarations": [
      "ClientConfigTest.setUp()",
      "ClientConfigTest.shutdown()",
      "ClientConfigTest.testNiwsConfigViaProperties()",
      "ClientConfigTest.testresolveDeploymentContextbasedVipAddresses()",
      "ClientConfigTest.testFallback_noneSet()",
      "ClientConfigTest.testFallback_fallbackSet()",
      "ClientConfigTest.testFallback_primarySet()",
      "CustomValueOf.valueOf(String)",
      "CustomValueOf.getValue()",
      "CustomValueOf.toString()",
      "CustomValueOf.equals(Object)",
      "CustomValueOf.hashCode()",
      "ClientConfigTest.testValueOfWithDefault()",
      "ClientConfigTest.testValueOf()",
      "ClientConfigTest.testDynamicConfig()"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.lang.getClass"
      ],
      "UserDefined": [
        "CustomValueOf.getValue",
        "CustomValueOf.getValue",
        "CustomValueOf.getValue",
        "CustomValueOf.getValue"
      ],
      "Unresolved": [
        "org.junit.rules.TestName.getMethodName",
        "org.junit.rules.TestName.getMethodName",
        "setProperty",
        "longValue",
        "longValue",
        "setProperty",
        "assertEquals",
        "setProperty",
        "assertEquals",
        "clearProperty",
        "assertNull",
        "assertFalse",
        "fallbackWith",
        "org.junit.rules.TestName.getMethodName",
        "intValue",
        "setProperty",
        "fallbackWith",
        "org.junit.rules.TestName.getMethodName",
        "intValue",
        "setProperty",
        "key",
        "org.junit.rules.TestName.getMethodName",
        "fallbackWith",
        "org.junit.rules.TestName.getMethodName",
        "intValue",
        "setProperty",
        "setProperty",
        "setProperty",
        "setProperty",
        "clearProperty"
      ]
    },
    "Imports": {
      "org.junit.Assert.*": "org.junit.Assert",
      "ConfigurationManager": "com.netflix.config.ConfigurationManager",
      "AfterClass": "org.junit.AfterClass",
      "Assert": "org.junit.Assert",
      "Before": "org.junit.Before",
      "BeforeClass": "org.junit.BeforeClass",
      "FixMethodOrder": "org.junit.FixMethodOrder",
      "Rule": "org.junit.Rule",
      "Test": "org.junit.Test",
      "TestName": "org.junit.rules.TestName",
      "MethodSorters": "org.junit.runners.MethodSorters",
      "Logger": "org.slf4j.Logger",
      "LoggerFactory": "org.slf4j.LoggerFactory",
      "Objects": "java.util.Objects",
      "Properties": "java.util.Properties"
    },
    "FieldTypes": {
      "LOG": "org.slf4j.Logger",
      "testName": "org.junit.rules.TestName"
    }
  },
  "ribbon\\ribbon-core\\src\\test\\java\\com\\netflix\\client\\config\\CommonClientConfigKeyTest.java": {
    "TypeDeclarations": [
      "CommonClientConfigKeyTest"
    ],
    "MethodDeclarations": [
      "CommonClientConfigKeyTest.testCommonKeys()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "assertTrue",
        "assertEquals",
        "assertTrue",
        "contains"
      ]
    },
    "Imports": {
      "org.junit.Assert.*": "org.junit.Assert",
      "Test": "org.junit.Test",
      "Sets": "com.google.common.collect.Sets"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-core\\src\\test\\java\\com\\netflix\\client\\config\\DefaultClientConfigImplTest.java": {
    "TypeDeclarations": [
      "DefaultClientConfigImplTest",
      "NewConfigKey",
      "CustomType"
    ],
    "MethodDeclarations": [
      "DefaultClientConfigImplTest.testTypedValue()",
      "DefaultClientConfigImplTest.testNewType()",
      "DefaultClientConfigImplTest.testSubClass()",
      "CustomType.valueOf(Map)",
      "DefaultClientConfigImplTest.testMappedProperties()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "setProperty",
        "assertEquals",
        "intValue",
        "assertEquals",
        "intValue",
        "assertEquals",
        "assertEquals",
        "org.junit.rules.TestName.getMethodName",
        "setProperty",
        "setProperty",
        "setProperty",
        "setProperty",
        "setProperty",
        "setProperty",
        "get",
        "get"
      ]
    },
    "Imports": {
      "org.junit.Assert.*": "org.junit.Assert",
      "Collections": "java.util.Collections",
      "Date": "java.util.Date",
      "Map": "java.util.Map",
      "TreeMap": "java.util.TreeMap",
      "Assert": "org.junit.Assert",
      "Rule": "org.junit.Rule",
      "Test": "org.junit.Test",
      "ConfigurationManager": "com.netflix.config.ConfigurationManager",
      "TestName": "org.junit.rules.TestName"
    },
    "FieldTypes": {
      "testName": "org.junit.rules.TestName",
      "value": "java.util.Map"
    }
  },
  "ribbon\\ribbon-core\\src\\test\\java\\com\\netflix\\client\\config\\ReloadableClientConfigTest.java": {
    "TypeDeclarations": [
      "ReloadableClientConfigTest"
    ],
    "MethodDeclarations": [
      "ReloadableClientConfigTest.before()",
      "ReloadableClientConfigTest.testOverrideLoadedConfig()",
      "ReloadableClientConfigTest.setBeforeLoading()",
      "ReloadableClientConfigTest.setAfterLoading()"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.lang.getClass"
      ],
      "UserDefined": [],
      "Unresolved": [
        "getName",
        "org.junit.rules.TestName.getMethodName",
        "intValue",
        "setProperty",
        "intValue",
        "clearProperty",
        "setProperty",
        "intValue",
        "setProperty",
        "intValue"
      ]
    },
    "Imports": {
      "ConfigurationManager": "com.netflix.config.ConfigurationManager",
      "Assert": "org.junit.Assert",
      "Before": "org.junit.Before",
      "Rule": "org.junit.Rule",
      "Test": "org.junit.Test",
      "TestName": "org.junit.rules.TestName"
    },
    "FieldTypes": {
      "testName": "org.junit.rules.TestName"
    }
  },
  "ribbon\\ribbon-eureka\\src\\main\\java\\com\\netflix\\niws\\loadbalancer\\DiscoveryEnabledNIWSServerList.java": {
    "TypeDeclarations": [
      "DiscoveryEnabledNIWSServerList"
    ],
    "MethodDeclarations": [
      "DiscoveryEnabledNIWSServerList.initWithNiwsConfig(IClientConfig)",
      "DiscoveryEnabledNIWSServerList.getInitialListOfServers()",
      "DiscoveryEnabledNIWSServerList.getUpdatedListOfServers()",
      "DiscoveryEnabledNIWSServerList.obtainServersViaDiscovery()",
      "DiscoveryEnabledNIWSServerList.createServer(InstanceInfo, BasicType(dimensions=[], name=boolean), BasicType(dimensions=[], name=boolean))",
      "DiscoveryEnabledNIWSServerList.getVipAddresses()",
      "DiscoveryEnabledNIWSServerList.setVipAddresses(String)",
      "DiscoveryEnabledNIWSServerList.toString()",
      "DiscoveryEnabledNIWSServerList.createClientConfig(String)"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.lang.equals"
      ],
      "UserDefined": [
        "DiscoveryEnabledNIWSServerList.createClientConfig",
        "DiscoveryEnabledNIWSServerList.initWithNiwsConfig",
        "DiscoveryEnabledNIWSServerList.obtainServersViaDiscovery",
        "DiscoveryEnabledNIWSServerList.obtainServersViaDiscovery",
        "DiscoveryEnabledNIWSServerList.createServer"
      ],
      "Unresolved": [
        "getBoolean",
        "getDeploymentDatacenter",
        "org.slf4j.Logger.warn",
        "org.slf4j.Logger.warn",
        "javax.inject.Provider.get",
        "org.slf4j.Logger.warn",
        "javax.inject.Provider.get",
        "org.slf4j.Logger.isDebugEnabled",
        "org.slf4j.Logger.debug",
        "setSecurePort",
        "build",
        "setPort",
        "build",
        "javax.inject.Provider.get",
        "getEurekaClientConfig",
        "append",
        "append",
        "append",
        "append"
      ]
    },
    "Imports": {
      "ArrayList": "java.util.ArrayList",
      "List": "java.util.List",
      "Optional": "java.util.Optional",
      "InstanceInfo": "com.netflix.appinfo.InstanceInfo",
      "InstanceStatus": "com.netflix.appinfo.InstanceInfo.InstanceStatus",
      "ClientConfigFactory": "com.netflix.client.config.ClientConfigFactory",
      "CommonClientConfigKey": "com.netflix.client.config.CommonClientConfigKey",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "Keys": "com.netflix.client.config.IClientConfigKey.Keys",
      "ConfigurationManager": "com.netflix.config.ConfigurationManager",
      "EurekaClient": "com.netflix.discovery.EurekaClient",
      "EurekaClientConfig": "com.netflix.discovery.EurekaClientConfig",
      "AbstractServerList": "com.netflix.loadbalancer.AbstractServerList",
      "DynamicServerListLoadBalancer": "com.netflix.loadbalancer.DynamicServerListLoadBalancer",
      "Logger": "org.slf4j.Logger",
      "LoggerFactory": "org.slf4j.LoggerFactory",
      "Provider": "javax.inject.Provider"
    },
    "FieldTypes": {
      "logger": "org.slf4j.Logger",
      "eurekaClientProvider": "javax.inject.Provider"
    }
  },
  "ribbon\\ribbon-eureka\\src\\main\\java\\com\\netflix\\niws\\loadbalancer\\DiscoveryEnabledServer.java": {
    "TypeDeclarations": [
      "DiscoveryEnabledServer"
    ],
    "MethodDeclarations": [
      "DiscoveryEnabledServer.getInstanceInfo()",
      "DiscoveryEnabledServer.getMetaInfo()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "com.netflix.appinfo.InstanceInfo.getIPAddr",
        "com.netflix.appinfo.InstanceInfo.getHostName",
        "com.netflix.appinfo.InstanceInfo.getPort",
        "com.netflix.appinfo.InstanceInfo.isPortEnabled",
        "com.netflix.appinfo.InstanceInfo.getSecurePort",
        "com.netflix.appinfo.InstanceInfo.getAppName",
        "com.netflix.appinfo.InstanceInfo.getASGName",
        "com.netflix.appinfo.InstanceInfo.getVIPAddress",
        "com.netflix.appinfo.InstanceInfo.getId"
      ]
    },
    "Imports": {
      "InstanceInfo": "com.netflix.appinfo.InstanceInfo",
      "PortType": "com.netflix.appinfo.InstanceInfo.PortType",
      "Server": "com.netflix.loadbalancer.Server"
    },
    "FieldTypes": {
      "instanceInfo": "com.netflix.appinfo.InstanceInfo"
    }
  },
  "ribbon\\ribbon-eureka\\src\\main\\java\\com\\netflix\\niws\\loadbalancer\\EurekaNotificationServerListUpdater.java": {
    "TypeDeclarations": [
      "EurekaNotificationServerListUpdater",
      "LazyHolder"
    ],
    "MethodDeclarations": [
      "LazyHolder.getCorePoolSize()",
      "EurekaNotificationServerListUpdater.getDefaultRefreshExecutor()",
      "EurekaNotificationServerListUpdater.start(UpdateAction)",
      "EurekaNotificationServerListUpdater.stop()",
      "EurekaNotificationServerListUpdater.getLastUpdate()",
      "EurekaNotificationServerListUpdater.getDurationSinceLastUpdateMs()",
      "EurekaNotificationServerListUpdater.getNumberMissedCycles()",
      "EurekaNotificationServerListUpdater.getCoreThreads()"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.lang.toString"
      ],
      "UserDefined": [
        "LazyHolder.getCorePoolSize",
        "LazyHolder.getCorePoolSize"
      ],
      "Unresolved": [
        "com.netflix.config.DynamicIntProperty.get",
        "setNameFormat",
        "setDaemon",
        "build",
        "com.netflix.config.DynamicIntProperty.addCallback",
        "java.util.concurrent.ThreadPoolExecutor.setCorePoolSize",
        "java.util.concurrent.ThreadPoolExecutor.setMaximumPoolSize",
        "org.slf4j.Logger.info",
        "java.util.concurrent.ThreadPoolExecutor.shutdown",
        "removeShutdownHook",
        "addShutdownHook",
        "com.netflix.config.DynamicIntProperty.get",
        "getDefaultRefreshExecutor",
        "java.util.concurrent.atomic.AtomicBoolean.compareAndSet",
        "java.util.concurrent.atomic.AtomicBoolean.compareAndSet",
        "org.slf4j.Logger.info",
        "java.util.concurrent.ExecutorService.isShutdown",
        "java.util.concurrent.ExecutorService.submit",
        "java.util.concurrent.atomic.AtomicLong.set",
        "org.slf4j.Logger.warn",
        "java.util.concurrent.atomic.AtomicBoolean.set",
        "org.slf4j.Logger.warn",
        "java.util.concurrent.atomic.AtomicBoolean.set",
        "org.slf4j.Logger.debug",
        "stop",
        "javax.inject.Provider.get",
        "com.netflix.discovery.EurekaClient.registerEventListener",
        "org.slf4j.Logger.error",
        "org.slf4j.Logger.info",
        "java.util.concurrent.atomic.AtomicBoolean.compareAndSet",
        "com.netflix.discovery.EurekaClient.unregisterEventListener",
        "org.slf4j.Logger.info",
        "java.util.concurrent.atomic.AtomicLong.get",
        "java.util.concurrent.atomic.AtomicLong.get",
        "java.util.concurrent.atomic.AtomicBoolean.get"
      ]
    },
    "Imports": {
      "ThreadFactoryBuilder": "com.google.common.util.concurrent.ThreadFactoryBuilder",
      "DynamicIntProperty": "com.netflix.config.DynamicIntProperty",
      "CacheRefreshedEvent": "com.netflix.discovery.CacheRefreshedEvent",
      "EurekaClient": "com.netflix.discovery.EurekaClient",
      "EurekaEvent": "com.netflix.discovery.EurekaEvent",
      "EurekaEventListener": "com.netflix.discovery.EurekaEventListener",
      "com.netflix.loadbalancer.*": "com.netflix.loadbalancer",
      "Logger": "org.slf4j.Logger",
      "LoggerFactory": "org.slf4j.LoggerFactory",
      "Provider": "javax.inject.Provider",
      "Date": "java.util.Date",
      "ArrayBlockingQueue": "java.util.concurrent.ArrayBlockingQueue",
      "ExecutorService": "java.util.concurrent.ExecutorService",
      "ThreadPoolExecutor": "java.util.concurrent.ThreadPoolExecutor",
      "TimeUnit": "java.util.concurrent.TimeUnit",
      "AtomicBoolean": "java.util.concurrent.atomic.AtomicBoolean",
      "AtomicLong": "java.util.concurrent.atomic.AtomicLong"
    },
    "FieldTypes": {
      "logger": "org.slf4j.Logger",
      "poolSizeProp": "com.netflix.config.DynamicIntProperty",
      "queueSizeProp": "com.netflix.config.DynamicIntProperty",
      "defaultServerListUpdateExecutor": "java.util.concurrent.ThreadPoolExecutor",
      "updateQueued": "java.util.concurrent.atomic.AtomicBoolean",
      "isActive": "java.util.concurrent.atomic.AtomicBoolean",
      "lastUpdated": "java.util.concurrent.atomic.AtomicLong",
      "eurekaClientProvider": "javax.inject.Provider",
      "refreshExecutor": "java.util.concurrent.ExecutorService",
      "updateListener": "com.netflix.discovery.EurekaEventListener",
      "eurekaClient": "com.netflix.discovery.EurekaClient"
    }
  },
  "ribbon\\ribbon-eureka\\src\\main\\java\\com\\netflix\\niws\\loadbalancer\\LegacyEurekaClientProvider.java": {
    "TypeDeclarations": [
      "LegacyEurekaClientProvider"
    ],
    "MethodDeclarations": [
      "LegacyEurekaClientProvider.get()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "getDiscoveryClient"
      ]
    },
    "Imports": {
      "DiscoveryManager": "com.netflix.discovery.DiscoveryManager",
      "EurekaClient": "com.netflix.discovery.EurekaClient",
      "Provider": "javax.inject.Provider"
    },
    "FieldTypes": {
      "eurekaClient": "com.netflix.discovery.EurekaClient"
    }
  },
  "ribbon\\ribbon-eureka\\src\\main\\java\\com\\netflix\\niws\\loadbalancer\\NIWSDiscoveryPing.java": {
    "TypeDeclarations": [
      "NIWSDiscoveryPing"
    ],
    "MethodDeclarations": [
      "NIWSDiscoveryPing.getLb()",
      "NIWSDiscoveryPing.setLb(BaseLoadBalancer)",
      "NIWSDiscoveryPing.isAlive(Server)",
      "NIWSDiscoveryPing.initWithNiwsConfig(IClientConfig)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "InstanceInfo": "com.netflix.appinfo.InstanceInfo",
      "InstanceStatus": "com.netflix.appinfo.InstanceInfo.InstanceStatus",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "AbstractLoadBalancerPing": "com.netflix.loadbalancer.AbstractLoadBalancerPing",
      "BaseLoadBalancer": "com.netflix.loadbalancer.BaseLoadBalancer",
      "Server": "com.netflix.loadbalancer.Server"
    },
    "FieldTypes": {
      "lb": "com.netflix.loadbalancer.BaseLoadBalancer"
    }
  },
  "ribbon\\ribbon-eureka\\src\\test\\java\\com\\netflix\\loadbalancer\\EurekaDynamicServerListLoadBalancerTest.java": {
    "TypeDeclarations": [
      "EurekaDynamicServerListLoadBalancerTest"
    ],
    "MethodDeclarations": [
      "EurekaDynamicServerListLoadBalancerTest.setUp()",
      "EurekaDynamicServerListLoadBalancerTest.testLoadBalancerHappyCase()",
      "EurekaDynamicServerListLoadBalancerTest.testShutdownMultiple()",
      "EurekaDynamicServerListLoadBalancerTest.verifyFinalServerListCount(BasicType(dimensions=[], name=int), DynamicServerListLoadBalancer)",
      "EurekaDynamicServerListLoadBalancerTest.setUpEurekaClientMock(List)"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.util.List.size",
        "java.util.List.get",
        "java.util.List.size"
      ],
      "UserDefined": [
        "EurekaDynamicServerListLoadBalancerTest.setUpEurekaClientMock",
        "EurekaDynamicServerListLoadBalancerTest.verifyFinalServerListCount"
      ],
      "Unresolved": [
        "build",
        "toInstanceList",
        "getVIPAddress",
        "andReturn",
        "anyTimes",
        "com.netflix.client.config.DefaultClientConfigImpl.set",
        "com.netflix.client.config.DefaultClientConfigImpl.set",
        "getName",
        "com.netflix.discovery.EurekaClient.registerEventListener",
        "onEvent",
        "com.netflix.discovery.EurekaClient.registerEventListener",
        "anyTimes",
        "andReturn",
        "anyTimes",
        "com.netflix.discovery.EurekaClient.getEurekaClientConfig",
        "andReturn",
        "java.util.List.subList",
        "times",
        "andReturn",
        "java.util.List.subList",
        "anyTimes",
        "com.netflix.discovery.EurekaClient.getInstancesByVipAddress",
        "andReturn",
        "anyTimes",
        "com.netflix.discovery.EurekaClient.unregisterEventListener"
      ]
    },
    "Imports": {
      "InstanceInfo": "com.netflix.appinfo.InstanceInfo",
      "CommonClientConfigKey": "com.netflix.client.config.CommonClientConfigKey",
      "DefaultClientConfigImpl": "com.netflix.client.config.DefaultClientConfigImpl",
      "CacheRefreshedEvent": "com.netflix.discovery.CacheRefreshedEvent",
      "DefaultEurekaClientConfig": "com.netflix.discovery.DefaultEurekaClientConfig",
      "DiscoveryClient": "com.netflix.discovery.DiscoveryClient",
      "EurekaClient": "com.netflix.discovery.EurekaClient",
      "EurekaEventListener": "com.netflix.discovery.EurekaEventListener",
      "InstanceInfoGenerator": "com.netflix.discovery.util.InstanceInfoGenerator",
      "DiscoveryEnabledNIWSServerList": "com.netflix.niws.loadbalancer.DiscoveryEnabledNIWSServerList",
      "DiscoveryEnabledServer": "com.netflix.niws.loadbalancer.DiscoveryEnabledServer",
      "EurekaNotificationServerListUpdater": "com.netflix.niws.loadbalancer.EurekaNotificationServerListUpdater",
      "Capture": "org.easymock.Capture",
      "EasyMock": "org.easymock.EasyMock",
      "Assert": "org.junit.Assert",
      "Before": "org.junit.Before",
      "Test": "org.junit.Test",
      "RunWith": "org.junit.runner.RunWith",
      "PowerMock": "org.powermock.api.easymock.PowerMock",
      "PowerMockIgnore": "org.powermock.core.classloader.annotations.PowerMockIgnore",
      "PrepareForTest": "org.powermock.core.classloader.annotations.PrepareForTest",
      "PowerMockRunner": "org.powermock.modules.junit4.PowerMockRunner",
      "Provider": "javax.inject.Provider",
      "List": "java.util.List",
      "TimeUnit": "java.util.concurrent.TimeUnit"
    },
    "FieldTypes": {
      "servers": "java.util.List",
      "config": "com.netflix.client.config.DefaultClientConfigImpl",
      "eurekaClientMock": "com.netflix.discovery.EurekaClient",
      "eurekaClientProvider": "javax.inject.Provider"
    }
  },
  "ribbon\\ribbon-eureka\\src\\test\\java\\com\\netflix\\niws\\loadbalancer\\DefaultNIWSServerListFilterTest.java": {
    "TypeDeclarations": [
      "DefaultNIWSServerListFilterTest"
    ],
    "MethodDeclarations": [
      "DefaultNIWSServerListFilterTest.init()",
      "DefaultNIWSServerListFilterTest.createServer(String, String)",
      "DefaultNIWSServerListFilterTest.createServer(String, BasicType(dimensions=[], name=int), String)",
      "DefaultNIWSServerListFilterTest.createServer(BasicType(dimensions=[], name=int), String)",
      "DefaultNIWSServerListFilterTest.testZoneAffinityEnabled()",
      "DefaultNIWSServerListFilterTest.testZoneExclusivity()",
      "DefaultNIWSServerListFilterTest.testZoneAffinityOverride()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "org.junit.Assert.assertTrue",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "org.junit.Assert.assertEquals",
        "DefaultNIWSServerListFilterTest.createServer",
        "org.junit.Assert.assertEquals",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "org.junit.Assert.assertEquals",
        "DefaultNIWSServerListFilterTest.createServer",
        "org.junit.Assert.assertEquals",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "org.junit.Assert.assertEquals",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "org.junit.Assert.assertEquals",
        "DefaultNIWSServerListFilterTest.createServer",
        "org.junit.Assert.assertEquals",
        "DefaultNIWSServerListFilterTest.createServer",
        "DefaultNIWSServerListFilterTest.createServer",
        "org.junit.Assert.assertEquals"
      ],
      "Unresolved": [
        "setProperty",
        "addMetadata",
        "build",
        "setDataCenterInfo",
        "setHostName",
        "setPort",
        "build",
        "setProperty",
        "setProperty",
        "getName",
        "setProperty",
        "getName",
        "setProperty",
        "setProperty",
        "setProperty",
        "getName",
        "setProperty",
        "setProperty",
        "getName",
        "setProperty",
        "setProperty",
        "getName",
        "setProperty",
        "setProperty",
        "getName",
        "setProperty"
      ]
    },
    "Imports": {
      "assertEquals": "org.junit.Assert.assertEquals",
      "assertTrue": "org.junit.Assert.assertTrue",
      "ArrayList": "java.util.ArrayList",
      "List": "java.util.List",
      "ConfigurationBasedDeploymentContext": "com.netflix.config.ConfigurationBasedDeploymentContext",
      "Assert": "org.junit.Assert",
      "BeforeClass": "org.junit.BeforeClass",
      "Test": "org.junit.Test",
      "AmazonInfo": "com.netflix.appinfo.AmazonInfo",
      "InstanceInfo": "com.netflix.appinfo.InstanceInfo",
      "Builder": "com.netflix.appinfo.InstanceInfo.Builder",
      "ClientFactory": "com.netflix.client.ClientFactory",
      "ConfigurationManager": "com.netflix.config.ConfigurationManager",
      "ContextKey": "com.netflix.config.DeploymentContext.ContextKey",
      "AvailabilityFilteringRule": "com.netflix.loadbalancer.AvailabilityFilteringRule",
      "DynamicServerListLoadBalancer": "com.netflix.loadbalancer.DynamicServerListLoadBalancer",
      "LoadBalancerStats": "com.netflix.loadbalancer.LoadBalancerStats",
      "ZoneAffinityServerListFilter": "com.netflix.loadbalancer.ZoneAffinityServerListFilter"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-eureka\\src\\test\\java\\com\\netflix\\niws\\loadbalancer\\DiscoveryEnabledLoadBalancerSupportsPortOverrideTest.java": {
    "TypeDeclarations": [
      "DiscoveryEnabledLoadBalancerSupportsPortOverrideTest"
    ],
    "MethodDeclarations": [
      "DiscoveryEnabledLoadBalancerSupportsPortOverrideTest.setupMock()",
      "DiscoveryEnabledLoadBalancerSupportsPortOverrideTest.afterMock()",
      "DiscoveryEnabledLoadBalancerSupportsPortOverrideTest.testDefaultHonorsVipPortDefinition()",
      "DiscoveryEnabledLoadBalancerSupportsPortOverrideTest.testDefaultHonorsVipSecurePortDefinition()",
      "DiscoveryEnabledLoadBalancerSupportsPortOverrideTest.testVipPortCanBeOverriden()",
      "DiscoveryEnabledLoadBalancerSupportsPortOverrideTest.testSecureVipPortCanBeOverriden()",
      "DiscoveryEnabledLoadBalancerSupportsPortOverrideTest.testTwoInstancesDontStepOnEachOther()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "org.powermock.api.easymock.PowerMock.createMock",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.expect",
        "org.powermock.api.easymock.PowerMock.replay",
        "org.powermock.api.easymock.PowerMock.replay",
        "org.powermock.api.easymock.PowerMock.replay",
        "org.powermock.api.easymock.PowerMock.replay",
        "org.powermock.api.easymock.PowerMock.verify",
        "org.powermock.api.easymock.PowerMock.verify"
      ],
      "Unresolved": [
        "andReturn",
        "anyTimes",
        "andReturn",
        "anyTimes",
        "andReturn",
        "anyTimes",
        "andReturn",
        "anyTimes",
        "setProperty",
        "setProperty",
        "setProperty",
        "setProperty",
        "setProperty",
        "getName",
        "newInstance",
        "getPort",
        "getInstanceInfo",
        "getPort",
        "getInstanceInfo",
        "getSecurePort",
        "setProperty",
        "setProperty",
        "setProperty",
        "setProperty",
        "setProperty",
        "getName",
        "newInstance",
        "getPort",
        "getInstanceInfo",
        "getPort",
        "getInstanceInfo",
        "getSecurePort",
        "setProperty",
        "setProperty",
        "setProperty",
        "setProperty",
        "setProperty",
        "getName",
        "setProperty",
        "newInstance",
        "getPort",
        "getInstanceInfo",
        "getPort",
        "getInstanceInfo",
        "getSecurePort",
        "setProperty",
        "setProperty",
        "setProperty",
        "setProperty",
        "setProperty",
        "getName",
        "setProperty",
        "newInstance",
        "getPort",
        "getInstanceInfo",
        "getPort",
        "getInstanceInfo",
        "getSecurePort",
        "setProperty",
        "setProperty",
        "setProperty",
        "setProperty",
        "setProperty",
        "getName",
        "setProperty",
        "setProperty",
        "setProperty",
        "setProperty",
        "setProperty",
        "setProperty",
        "getName",
        "setProperty",
        "newInstance",
        "getPort",
        "getInstanceInfo",
        "getPort",
        "getInstanceInfo",
        "getSecurePort",
        "newInstance",
        "getPort",
        "getInstanceInfo",
        "getPort",
        "getInstanceInfo",
        "getSecurePort"
      ]
    },
    "Imports": {
      "InstanceInfo": "com.netflix.appinfo.InstanceInfo",
      "DefaultClientConfigImpl": "com.netflix.client.config.DefaultClientConfigImpl",
      "ConfigurationManager": "com.netflix.config.ConfigurationManager",
      "DiscoveryClient": "com.netflix.discovery.DiscoveryClient",
      "DiscoveryManager": "com.netflix.discovery.DiscoveryManager",
      "After": "org.junit.After",
      "Assert": "org.junit.Assert",
      "Before": "org.junit.Before",
      "Test": "org.junit.Test",
      "RunWith": "org.junit.runner.RunWith",
      "PowerMock": "org.powermock.api.easymock.PowerMock",
      "PowerMockIgnore": "org.powermock.core.classloader.annotations.PowerMockIgnore",
      "PrepareForTest": "org.powermock.core.classloader.annotations.PrepareForTest",
      "PowerMockRunner": "org.powermock.modules.junit4.PowerMockRunner",
      "List": "java.util.List",
      "expect": "org.easymock.EasyMock.expect",
      "createMock": "org.powermock.api.easymock.PowerMock.createMock",
      "replay": "org.powermock.api.easymock.PowerMock.replay",
      "verify": "org.powermock.api.easymock.PowerMock.verify"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-eureka\\src\\test\\java\\com\\netflix\\niws\\loadbalancer\\DiscoveryEnabledLoadBalancerSupportsUseIpAddrTest.java": {
    "TypeDeclarations": [
      "DiscoveryEnabledLoadBalancerSupportsUseIpAddrTest"
    ],
    "MethodDeclarations": [
      "DiscoveryEnabledLoadBalancerSupportsUseIpAddrTest.setupMock()",
      "DiscoveryEnabledLoadBalancerSupportsUseIpAddrTest.testUsesIpAddr(BasicType(dimensions=[], name=boolean), BasicType(dimensions=[], name=boolean), BasicType(dimensions=[], name=boolean), BasicType(dimensions=[], name=boolean))",
      "DiscoveryEnabledLoadBalancerSupportsUseIpAddrTest.testUsesIpAddrByWhenClientTrueOnly()",
      "DiscoveryEnabledLoadBalancerSupportsUseIpAddrTest.testUsesIpAddrByWhenClientFalseOnly()",
      "DiscoveryEnabledLoadBalancerSupportsUseIpAddrTest.testUsesIpAddrByWhenGlobalTrueOnly()",
      "DiscoveryEnabledLoadBalancerSupportsUseIpAddrTest.testUsesIpAddrByWhenGlobalFalseOnly()",
      "DiscoveryEnabledLoadBalancerSupportsUseIpAddrTest.testUsesHostnameByDefault()",
      "DiscoveryEnabledLoadBalancerSupportsUseIpAddrTest.afterMock()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "org.powermock.api.easymock.PowerMock.createMock",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.expect",
        "org.powermock.api.easymock.PowerMock.replay",
        "org.powermock.api.easymock.PowerMock.replay",
        "org.powermock.api.easymock.PowerMock.replay",
        "org.powermock.api.easymock.PowerMock.replay",
        "DiscoveryEnabledLoadBalancerSupportsUseIpAddrTest.testUsesIpAddr",
        "DiscoveryEnabledLoadBalancerSupportsUseIpAddrTest.testUsesIpAddr",
        "DiscoveryEnabledLoadBalancerSupportsUseIpAddrTest.testUsesIpAddr",
        "DiscoveryEnabledLoadBalancerSupportsUseIpAddrTest.testUsesIpAddr",
        "DiscoveryEnabledLoadBalancerSupportsUseIpAddrTest.testUsesIpAddr",
        "org.powermock.api.easymock.PowerMock.verify",
        "org.powermock.api.easymock.PowerMock.verify"
      ],
      "Unresolved": [
        "andReturn",
        "anyTimes",
        "andReturn",
        "anyTimes",
        "andReturn",
        "anyTimes",
        "setProperty",
        "clearProperty",
        "setProperty",
        "clearProperty",
        "getProperty",
        "getProperty",
        "setProperty",
        "getName",
        "setProperty",
        "setProperty",
        "newInstance",
        "getHost",
        "getHost",
        "getHost",
        "getHost",
        "getHost",
        "getHost",
        "getHost",
        "getHost",
        "getHost",
        "getHost"
      ]
    },
    "Imports": {
      "expect": "org.easymock.EasyMock.expect",
      "createMock": "org.powermock.api.easymock.PowerMock.createMock",
      "replay": "org.powermock.api.easymock.PowerMock.replay",
      "verify": "org.powermock.api.easymock.PowerMock.verify",
      "ArrayList": "java.util.ArrayList",
      "List": "java.util.List",
      "After": "org.junit.After",
      "Assert": "org.junit.Assert",
      "Before": "org.junit.Before",
      "Test": "org.junit.Test",
      "RunWith": "org.junit.runner.RunWith",
      "PowerMock": "org.powermock.api.easymock.PowerMock",
      "PowerMockIgnore": "org.powermock.core.classloader.annotations.PowerMockIgnore",
      "PrepareForTest": "org.powermock.core.classloader.annotations.PrepareForTest",
      "PowerMockRunner": "org.powermock.modules.junit4.PowerMockRunner",
      "InstanceInfo": "com.netflix.appinfo.InstanceInfo",
      "DefaultClientConfigImpl": "com.netflix.client.config.DefaultClientConfigImpl",
      "ConfigurationManager": "com.netflix.config.ConfigurationManager",
      "DiscoveryClient": "com.netflix.discovery.DiscoveryClient",
      "DiscoveryManager": "com.netflix.discovery.DiscoveryManager",
      "Server": "com.netflix.loadbalancer.Server"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-eureka\\src\\test\\java\\com\\netflix\\niws\\loadbalancer\\EurekaNotificationServerListUpdaterTest.java": {
    "TypeDeclarations": [
      "EurekaNotificationServerListUpdaterTest"
    ],
    "MethodDeclarations": [
      "EurekaNotificationServerListUpdaterTest.setUp()",
      "EurekaNotificationServerListUpdaterTest.testUpdating()",
      "EurekaNotificationServerListUpdaterTest.testStopWithCommonExecutor()",
      "EurekaNotificationServerListUpdaterTest.testTaskAlreadyQueued()",
      "EurekaNotificationServerListUpdaterTest.testSubmitExceptionClearQueued()",
      "EurekaNotificationServerListUpdaterTest.testEurekaClientUnregister()",
      "EurekaNotificationServerListUpdaterTest.testFailIfDiscoveryIsNotAvailable()",
      "EurekaNotificationServerListUpdaterTest.setUpEurekaClientMock()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "EurekaNotificationServerListUpdaterTest.setUpEurekaClientMock",
        "EurekaNotificationServerListUpdaterTest.setUpEurekaClientMock"
      ],
      "Unresolved": [
        "setNameFormat",
        "setDaemon",
        "build",
        "com.netflix.discovery.EurekaClient.registerEventListener",
        "onEvent",
        "onEvent",
        "com.netflix.discovery.EurekaClient.registerEventListener",
        "com.netflix.discovery.EurekaClient.registerEventListener",
        "onEvent",
        "onEvent",
        "com.netflix.discovery.EurekaClient.registerEventListener",
        "onEvent",
        "onEvent",
        "andThrow",
        "andReturn",
        "com.netflix.discovery.EurekaClient.registerEventListener",
        "onEvent",
        "andReturn",
        "com.netflix.discovery.EurekaClient.registerEventListener",
        "onEvent",
        "andReturn",
        "times",
        "com.netflix.discovery.EurekaClient.unregisterEventListener"
      ]
    },
    "Imports": {
      "ThreadFactoryBuilder": "com.google.common.util.concurrent.ThreadFactoryBuilder",
      "CacheRefreshedEvent": "com.netflix.discovery.CacheRefreshedEvent",
      "EurekaClient": "com.netflix.discovery.EurekaClient",
      "EurekaEventListener": "com.netflix.discovery.EurekaEventListener",
      "ServerListUpdater": "com.netflix.loadbalancer.ServerListUpdater",
      "Capture": "org.easymock.Capture",
      "EasyMock": "org.easymock.EasyMock",
      "Assert": "org.junit.Assert",
      "Before": "org.junit.Before",
      "Test": "org.junit.Test",
      "Provider": "javax.inject.Provider",
      "Queue": "java.util.Queue",
      "ArrayBlockingQueue": "java.util.concurrent.ArrayBlockingQueue",
      "CountDownLatch": "java.util.concurrent.CountDownLatch",
      "RejectedExecutionException": "java.util.concurrent.RejectedExecutionException",
      "ThreadPoolExecutor": "java.util.concurrent.ThreadPoolExecutor",
      "TimeUnit": "java.util.concurrent.TimeUnit",
      "AtomicBoolean": "java.util.concurrent.atomic.AtomicBoolean"
    },
    "FieldTypes": {
      "eurekaClientMock": "com.netflix.discovery.EurekaClient",
      "eurekaClientMock2": "com.netflix.discovery.EurekaClient",
      "testExecutor": "java.util.concurrent.ThreadPoolExecutor"
    }
  },
  "ribbon\\ribbon-eureka\\src\\test\\java\\com\\netflix\\niws\\loadbalancer\\LBBuilderTest.java": {
    "TypeDeclarations": [
      "LBBuilderTest",
      "NiwsClientConfig"
    ],
    "MethodDeclarations": [
      "NiwsClientConfig.getNameSpace()",
      "LBBuilderTest.setupMock()",
      "LBBuilderTest.testBuildWithDiscoveryEnabledNIWSServerList()",
      "LBBuilderTest.testBuildWithDiscoveryEnabledNIWSServerListAndUpdater()",
      "LBBuilderTest.testBuildWithArchaiusProperties()",
      "LBBuilderTest.testBuildStaticServerListLoadBalancer()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "org.powermock.api.easymock.PowerMock.createMock",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.expect",
        "org.powermock.api.easymock.PowerMock.replay",
        "org.powermock.api.easymock.PowerMock.replay",
        "org.powermock.api.easymock.PowerMock.replay",
        "org.powermock.api.easymock.PowerMock.replay",
        "com.netflix.loadbalancer.LoadBalancerBuilder",
        "com.netflix.loadbalancer.LoadBalancerBuilder"
      ],
      "Unresolved": [
        "com.netflix.loadbalancer.Server.getHost",
        "com.netflix.loadbalancer.Server.getPort",
        "andReturn",
        "anyTimes",
        "andReturn",
        "anyTimes",
        "andReturn",
        "anyTimes",
        "withDynamicServerList",
        "withRule",
        "withServerListFilter",
        "buildDynamicServerListLoadBalancer",
        "assertNotNull",
        "assertEquals",
        "assertSame",
        "assertSame",
        "assertTrue",
        "withDynamicServerList",
        "withRule",
        "withServerListFilter",
        "withServerListUpdater",
        "buildDynamicServerListLoadBalancerWithUpdater",
        "assertNotNull",
        "assertEquals",
        "assertSame",
        "assertSame",
        "assertSame",
        "assertTrue",
        "getName",
        "getName",
        "getName",
        "getName",
        "getName",
        "build",
        "withClientConfig",
        "buildLoadBalancerFromConfigWithReflection",
        "assertNotNull",
        "assertEquals",
        "getName",
        "getName",
        "assertTrue",
        "assertTrue",
        "assertTrue",
        "assertTrue",
        "assertEquals",
        "withDefaultValues",
        "withMaxAutoRetriesNextServer",
        "build",
        "assertEquals",
        "intValue",
        "withRule",
        "buildFixedServerListLoadBalancer",
        "assertEquals",
        "assertSame"
      ]
    },
    "Imports": {
      "Lists": "com.google.common.collect.Lists",
      "InstanceInfo": "com.netflix.appinfo.InstanceInfo",
      "DefaultClientConfigImpl": "com.netflix.client.config.DefaultClientConfigImpl",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "Keys": "com.netflix.client.config.IClientConfigKey.Keys",
      "ConfigurationManager": "com.netflix.config.ConfigurationManager",
      "DiscoveryClient": "com.netflix.discovery.DiscoveryClient",
      "DiscoveryManager": "com.netflix.discovery.DiscoveryManager",
      "AvailabilityFilteringRule": "com.netflix.loadbalancer.AvailabilityFilteringRule",
      "BaseLoadBalancer": "com.netflix.loadbalancer.BaseLoadBalancer",
      "DummyPing": "com.netflix.loadbalancer.DummyPing",
      "DynamicServerListLoadBalancer": "com.netflix.loadbalancer.DynamicServerListLoadBalancer",
      "ILoadBalancer": "com.netflix.loadbalancer.ILoadBalancer",
      "IRule": "com.netflix.loadbalancer.IRule",
      "LoadBalancerBuilder": "com.netflix.loadbalancer.LoadBalancerBuilder",
      "PollingServerListUpdater": "com.netflix.loadbalancer.PollingServerListUpdater",
      "RoundRobinRule": "com.netflix.loadbalancer.RoundRobinRule",
      "Server": "com.netflix.loadbalancer.Server",
      "ServerList": "com.netflix.loadbalancer.ServerList",
      "ServerListFilter": "com.netflix.loadbalancer.ServerListFilter",
      "ServerListUpdater": "com.netflix.loadbalancer.ServerListUpdater",
      "ZoneAffinityServerListFilter": "com.netflix.loadbalancer.ZoneAffinityServerListFilter",
      "ZoneAwareLoadBalancer": "com.netflix.loadbalancer.ZoneAwareLoadBalancer",
      "Configuration": "org.apache.commons.configuration.Configuration",
      "Before": "org.junit.Before",
      "Ignore": "org.junit.Ignore",
      "Test": "org.junit.Test",
      "RunWith": "org.junit.runner.RunWith",
      "PowerMock": "org.powermock.api.easymock.PowerMock",
      "PowerMockIgnore": "org.powermock.core.classloader.annotations.PowerMockIgnore",
      "PrepareForTest": "org.powermock.core.classloader.annotations.PrepareForTest",
      "PowerMockRunner": "org.powermock.modules.junit4.PowerMockRunner",
      "List": "java.util.List",
      "expect": "org.easymock.EasyMock.expect",
      "org.junit.Assert.*": "org.junit.Assert",
      "createMock": "org.powermock.api.easymock.PowerMock.createMock",
      "replay": "org.powermock.api.easymock.PowerMock.replay"
    },
    "FieldTypes": {
      "expected": "com.netflix.loadbalancer.Server"
    }
  },
  "ribbon\\ribbon-eureka\\src\\test\\java\\com\\netflix\\niws\\loadbalancer\\LoadBalancerTestUtils.java": {
    "TypeDeclarations": [
      "LoadBalancerTestUtils"
    ],
    "MethodDeclarations": [
      "LoadBalancerTestUtils.getDummyInstanceInfo(String, String, String, BasicType(dimensions=[], name=int))",
      "LoadBalancerTestUtils.mockDiscoveryClient()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "org.powermock.api.easymock.PowerMock.createMock",
        "org.easymock.EasyMock.expect"
      ],
      "Unresolved": [
        "setAppName",
        "setHostName",
        "setIPAddr",
        "setPort",
        "setDataCenterInfo",
        "build",
        "andReturn",
        "anyTimes"
      ]
    },
    "Imports": {
      "DataCenterInfo": "com.netflix.appinfo.DataCenterInfo",
      "InstanceInfo": "com.netflix.appinfo.InstanceInfo",
      "MyDataCenterInfo": "com.netflix.appinfo.MyDataCenterInfo",
      "DefaultEurekaClientConfig": "com.netflix.discovery.DefaultEurekaClientConfig",
      "DiscoveryClient": "com.netflix.discovery.DiscoveryClient",
      "DiscoveryManager": "com.netflix.discovery.DiscoveryManager",
      "ArrayList": "java.util.ArrayList",
      "List": "java.util.List",
      "expect": "org.easymock.EasyMock.expect",
      "createMock": "org.powermock.api.easymock.PowerMock.createMock"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-evcache\\src\\main\\java\\com\\netflix\\ribbon\\evache\\CacheFaultException.java": {
    "TypeDeclarations": [
      "CacheFaultException"
    ],
    "MethodDeclarations": [],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {},
    "FieldTypes": {}
  },
  "ribbon\\ribbon-evcache\\src\\main\\java\\com\\netflix\\ribbon\\evache\\CacheMissException.java": {
    "TypeDeclarations": [
      "CacheMissException"
    ],
    "MethodDeclarations": [],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {},
    "FieldTypes": {}
  },
  "ribbon\\ribbon-evcache\\src\\main\\java\\com\\netflix\\ribbon\\evache\\EvCacheOptions.java": {
    "TypeDeclarations": [
      "EvCacheOptions"
    ],
    "MethodDeclarations": [
      "EvCacheOptions.getAppName()",
      "EvCacheOptions.getCacheName()",
      "EvCacheOptions.isEnableZoneFallback()",
      "EvCacheOptions.getTimeToLive()",
      "EvCacheOptions.getTranscoder()",
      "EvCacheOptions.getCacheKeyTemplate()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "EVCacheTranscoder": "com.netflix.evcache.EVCacheTranscoder"
    },
    "FieldTypes": {
      "transcoder": "com.netflix.evcache.EVCacheTranscoder"
    }
  },
  "ribbon\\ribbon-evcache\\src\\main\\java\\com\\netflix\\ribbon\\evache\\EvCacheProvider.java": {
    "TypeDeclarations": [
      "EvCacheProvider",
      "FutureObserver"
    ],
    "MethodDeclarations": [
      "EvCacheProvider.get(String, Map)",
      "FutureObserver.run()",
      "FutureObserver.handleCompletedFuture(Future, Subscriber)",
      "FutureObserver.watchFuture(Future, Subscriber)"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.util.Map.entrySet",
        "java.util.Map.remove",
        "java.util.Map.remove",
        "java.util.Map.put"
      ],
      "UserDefined": [
        "FutureObserver.handleCompletedFuture"
      ],
      "Unresolved": [
        "com.netflix.evcache.EVCache.getAsynchronous",
        "com.netflix.evcache.EVCache.getAsynchronous",
        "setDaemon",
        "interrupt"
      ]
    },
    "Imports": {
      "EVCache": "com.netflix.evcache.EVCache",
      "EVCacheException": "com.netflix.evcache.EVCacheException",
      "CacheProvider": "com.netflix.ribbon.CacheProvider",
      "Logger": "org.slf4j.Logger",
      "LoggerFactory": "org.slf4j.LoggerFactory",
      "Map": "java.util.Map",
      "ConcurrentHashMap": "java.util.concurrent.ConcurrentHashMap",
      "ExecutionException": "java.util.concurrent.ExecutionException",
      "Future": "java.util.concurrent.Future",
      "Observable": "rx.Observable",
      "OnSubscribe": "rx.Observable.OnSubscribe",
      "Subscriber": "rx.Subscriber"
    },
    "FieldTypes": {
      "LOGGER": "org.slf4j.Logger",
      "evCache": "com.netflix.evcache.EVCache",
      "futureMap": "java.util.Map"
    }
  },
  "ribbon\\ribbon-evcache\\src\\main\\java\\com\\netflix\\ribbon\\proxy\\annotation\\EvCache.java": {
    "TypeDeclarations": [
      "EvCache"
    ],
    "MethodDeclarations": [],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "EVCacheTranscoder": "com.netflix.evcache.EVCacheTranscoder",
      "ElementType": "java.lang.annotation.ElementType",
      "Retention": "java.lang.annotation.Retention",
      "RetentionPolicy": "java.lang.annotation.RetentionPolicy",
      "Target": "java.lang.annotation.Target"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-evcache\\src\\main\\java\\com\\netflix\\ribbon\\proxy\\processor\\EVCacheAnnotationProcessor.java": {
    "TypeDeclarations": [
      "EVCacheAnnotationProcessor",
      "CacheId"
    ],
    "MethodDeclarations": [
      "CacheId.equals(Object)",
      "CacheId.hashCode()",
      "EVCacheAnnotationProcessor.process(String, TemplateBuilder, Method)",
      "EVCacheAnnotationProcessor.process(String, GroupBuilder, RibbonResourceFactory, Class)"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.lang.getClass",
        "java.util.Map.get",
        "java.util.Map.put"
      ],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "EVCacheTranscoder": "com.netflix.evcache.EVCacheTranscoder",
      "GroupBuilder": "com.netflix.ribbon.ResourceGroup.GroupBuilder",
      "TemplateBuilder": "com.netflix.ribbon.ResourceGroup.TemplateBuilder",
      "RibbonResourceFactory": "com.netflix.ribbon.RibbonResourceFactory",
      "EvCacheOptions": "com.netflix.ribbon.evache.EvCacheOptions",
      "EvCacheProvider": "com.netflix.ribbon.evache.EvCacheProvider",
      "ProxyAnnotationException": "com.netflix.ribbon.proxy.ProxyAnnotationException",
      "Utils": "com.netflix.ribbon.proxy.Utils",
      "EvCache": "com.netflix.ribbon.proxy.annotation.EvCache",
      "Method": "java.lang.reflect.Method",
      "HashMap": "java.util.HashMap",
      "Map": "java.util.Map"
    },
    "FieldTypes": {
      "evCacheProviderPool": "java.util.Map"
    }
  },
  "ribbon\\ribbon-evcache\\src\\test\\java\\com\\netflix\\ribbon\\evache\\EvCacheProviderTest.java": {
    "TypeDeclarations": [
      "EvCacheProviderTest"
    ],
    "MethodDeclarations": [
      "EvCacheProviderTest.setUp()",
      "EvCacheProviderTest.testAsynchronousAccessFromCache()",
      "EvCacheProviderTest.testAsynchronousAccessWithTranscoderFromCache()",
      "EvCacheProviderTest.testCacheMiss()",
      "EvCacheProviderTest.testFailedAsynchronousAccessFromCache()",
      "EvCacheProviderTest.testCanceledFuture()",
      "EvCacheProviderTest.testExceptionResultInFuture()",
      "EvCacheProviderTest.testUnsubscribedBeforeFutureCompletes()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "junit.framework.Assert.assertEquals",
        "junit.framework.Assert.assertEquals",
        "junit.framework.Assert.assertTrue",
        "junit.framework.Assert.assertTrue",
        "junit.framework.Assert.assertTrue",
        "junit.framework.Assert.assertTrue"
      ],
      "Unresolved": [
        "expectNew",
        "andReturn",
        "anyObject",
        "anyObject",
        "anyInt",
        "anyObject",
        "anyBoolean",
        "expect",
        "andReturn",
        "evCacheImplMock",
        "expect",
        "andReturn",
        "java.util.concurrent.Future.isDone",
        "expect",
        "andReturn",
        "java.util.concurrent.Future.isCancelled",
        "expect",
        "andReturn",
        "java.util.concurrent.Future.get",
        "replayAll",
        "first",
        "expect",
        "andReturn",
        "com.netflix.evcache.EVCacheImpl.getAsynchronous",
        "expect",
        "andReturn",
        "java.util.concurrent.Future.isDone",
        "expect",
        "andReturn",
        "java.util.concurrent.Future.isCancelled",
        "expect",
        "andReturn",
        "java.util.concurrent.Future.get",
        "replayAll",
        "first",
        "expect",
        "andReturn",
        "evCacheImplMock",
        "expect",
        "andReturn",
        "java.util.concurrent.Future.isDone",
        "expect",
        "andReturn",
        "java.util.concurrent.Future.isCancelled",
        "expect",
        "andReturn",
        "java.util.concurrent.Future.get",
        "replayAll",
        "toBlocking",
        "first",
        "getThrowable",
        "expect",
        "andThrow",
        "evCacheImplMock",
        "replayAll",
        "toBlocking",
        "first",
        "expect",
        "andReturn",
        "com.netflix.evcache.EVCacheImpl.getAsynchronous",
        "expect",
        "andReturn",
        "java.util.concurrent.Future.isDone",
        "expect",
        "andReturn",
        "java.util.concurrent.Future.isCancelled",
        "replayAll",
        "toBlocking",
        "first",
        "getThrowable",
        "expect",
        "andReturn",
        "com.netflix.evcache.EVCacheImpl.getAsynchronous",
        "expect",
        "andReturn",
        "java.util.concurrent.Future.isDone",
        "expect",
        "andReturn",
        "java.util.concurrent.Future.isCancelled",
        "expect",
        "andThrow",
        "java.util.concurrent.Future.get",
        "replayAll",
        "toBlocking",
        "first",
        "getThrowable",
        "expect",
        "andReturn",
        "com.netflix.evcache.EVCacheImpl.getAsynchronous",
        "expect",
        "andReturn",
        "java.util.concurrent.Future.cancel",
        "replayAll",
        "verifyAll"
      ]
    },
    "Imports": {
      "EVCache": "com.netflix.evcache.EVCache",
      "EVCacheException": "com.netflix.evcache.EVCacheException",
      "EVCacheImpl": "com.netflix.evcache.EVCacheImpl",
      "EVCacheTranscoder": "com.netflix.evcache.EVCacheTranscoder",
      "TestUtils": "com.netflix.ribbon.testutils.TestUtils",
      "Before": "org.junit.Before",
      "Test": "org.junit.Test",
      "RunWith": "org.junit.runner.RunWith",
      "PowerMock": "org.powermock.api.easymock.PowerMock",
      "Mock": "org.powermock.api.easymock.annotation.Mock",
      "PrepareForTest": "org.powermock.core.classloader.annotations.PrepareForTest",
      "PowerMockRunner": "org.powermock.modules.junit4.PowerMockRunner",
      "Notification": "rx.Notification",
      "Observable": "rx.Observable",
      "Subscription": "rx.Subscription",
      "Func0": "rx.functions.Func0",
      "ExecutionException": "java.util.concurrent.ExecutionException",
      "Future": "java.util.concurrent.Future",
      "assertEquals": "junit.framework.Assert.assertEquals",
      "assertTrue": "junit.framework.Assert.assertTrue",
      "org.easymock.EasyMock.*": "org.easymock.EasyMock",
      "org.powermock.api.easymock.PowerMock.*": "org.powermock.api.easymock.PowerMock"
    },
    "FieldTypes": {
      "evCacheImplMock": "com.netflix.evcache.EVCacheImpl",
      "cacheFutureMock": "java.util.concurrent.Future",
      "transcoderMock": "com.netflix.evcache.EVCacheTranscoder"
    }
  },
  "ribbon\\ribbon-evcache\\src\\test\\java\\com\\netflix\\ribbon\\evache\\ServiceLoaderTest.java": {
    "TypeDeclarations": [
      "ServiceLoaderTest"
    ],
    "MethodDeclarations": [
      "ServiceLoaderTest.testServiceLoader()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "junit.framework.TestCase.assertTrue"
      ],
      "Unresolved": []
    },
    "Imports": {
      "AnnotationProcessor": "com.netflix.ribbon.proxy.processor.AnnotationProcessor",
      "AnnotationProcessorsProvider": "com.netflix.ribbon.proxy.processor.AnnotationProcessorsProvider",
      "EVCacheAnnotationProcessor": "com.netflix.ribbon.proxy.processor.EVCacheAnnotationProcessor",
      "Test": "org.junit.Test",
      "List": "java.util.List",
      "assertTrue": "junit.framework.TestCase.assertTrue"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-evcache\\src\\test\\java\\com\\netflix\\ribbon\\proxy\\EvCacheAnnotationTest.java": {
    "TypeDeclarations": [
      "EvCacheAnnotationTest"
    ],
    "MethodDeclarations": [
      "EvCacheAnnotationTest.setup()",
      "EvCacheAnnotationTest.setUp()",
      "EvCacheAnnotationTest.testGetQueryWithDomainObjectResult()",
      "EvCacheAnnotationTest.expectUrlBase(String, String)",
      "EvCacheAnnotationTest.createExecutor(Class, String)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.expect",
        "EvCacheAnnotationTest.expectUrlBase",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.anyObject",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.anyObject",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.anyObject",
        "org.easymock.EasyMock.anyObject",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.anyObject",
        "org.easymock.EasyMock.anyObject",
        "EvCacheAnnotationTest.createExecutor",
        "junit.framework.Assert.assertEquals",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.expect",
        "com.netflix.ribbon.proxy.Utils.methodByName"
      ],
      "Unresolved": [
        "createMock",
        "createMock",
        "createMock",
        "createMock",
        "createMock",
        "andReturn",
        "com.netflix.ribbon.http.HttpRequestBuilder.build",
        "andReturn",
        "com.netflix.ribbon.http.HttpRequestTemplate.Builder.build",
        "andReturn",
        "com.netflix.ribbon.http.HttpRequestTemplate.requestBuilder",
        "andReturn",
        "com.netflix.ribbon.http.HttpRequestBuilder.withRequestProperty",
        "andReturn",
        "com.netflix.ribbon.http.HttpResourceGroup.newTemplateBuilder",
        "andReturn",
        "com.netflix.ribbon.http.HttpRequestTemplate.Builder.withHeader",
        "andReturn",
        "com.netflix.ribbon.http.HttpRequestTemplate.Builder.withHeader",
        "andReturn",
        "com.netflix.ribbon.http.HttpRequestTemplate.Builder.withHeader",
        "andReturn",
        "com.netflix.ribbon.http.HttpRequestTemplate.Builder.withRequestCacheKey",
        "andReturn",
        "com.netflix.ribbon.http.HttpRequestTemplate.Builder.withFallbackProvider",
        "andReturn",
        "com.netflix.ribbon.http.HttpRequestTemplate.Builder.withResponseValidator",
        "andReturn",
        "com.netflix.ribbon.http.HttpRequestTemplate.Builder.withCacheProvider",
        "andReturn",
        "com.netflix.ribbon.http.HttpRequestTemplate.Builder.withCacheProvider",
        "replayAll",
        "verifyAll",
        "andReturn",
        "com.netflix.ribbon.http.HttpRequestTemplate.Builder.withMethod",
        "andReturn",
        "com.netflix.ribbon.http.HttpRequestTemplate.Builder.withUriTemplate"
      ]
    },
    "Imports": {
      "CacheProvider": "com.netflix.ribbon.CacheProvider",
      "RibbonRequest": "com.netflix.ribbon.RibbonRequest",
      "EvCacheProvider": "com.netflix.ribbon.evache.EvCacheProvider",
      "HttpRequestBuilder": "com.netflix.ribbon.http.HttpRequestBuilder",
      "HttpRequestTemplate": "com.netflix.ribbon.http.HttpRequestTemplate",
      "Builder": "com.netflix.ribbon.http.HttpRequestTemplate.Builder",
      "HttpResourceGroup": "com.netflix.ribbon.http.HttpResourceGroup",
      "AnnotationProcessorsProvider": "com.netflix.ribbon.proxy.processor.AnnotationProcessorsProvider",
      "MovieFallbackHandler": "com.netflix.ribbon.proxy.sample.HystrixHandlers.MovieFallbackHandler",
      "SampleHttpResponseValidator": "com.netflix.ribbon.proxy.sample.HystrixHandlers.SampleHttpResponseValidator",
      "SampleMovieServiceWithEVCache": "com.netflix.ribbon.proxy.sample.SampleMovieServiceWithEVCache",
      "Before": "org.junit.Before",
      "BeforeClass": "org.junit.BeforeClass",
      "Test": "org.junit.Test",
      "RunWith": "org.junit.runner.RunWith",
      "Mock": "org.powermock.api.easymock.annotation.Mock",
      "PowerMockIgnore": "org.powermock.core.classloader.annotations.PowerMockIgnore",
      "PrepareForTest": "org.powermock.core.classloader.annotations.PrepareForTest",
      "PowerMockRunner": "org.powermock.modules.junit4.PowerMockRunner",
      "methodByName": "com.netflix.ribbon.proxy.Utils.methodByName",
      "assertEquals": "junit.framework.Assert.assertEquals",
      "anyObject": "org.easymock.EasyMock.anyObject",
      "expect": "org.easymock.EasyMock.expect",
      "org.powermock.api.easymock.PowerMock.*": "org.powermock.api.easymock.PowerMock"
    },
    "FieldTypes": {
      "ribbonRequestMock": "com.netflix.ribbon.RibbonRequest",
      "requestBuilderMock": "com.netflix.ribbon.http.HttpRequestBuilder",
      "httpRequestTemplateBuilderMock": "com.netflix.ribbon.http.HttpRequestTemplate.Builder",
      "httpRequestTemplateMock": "com.netflix.ribbon.http.HttpRequestTemplate",
      "httpResourceGroupMock": "com.netflix.ribbon.http.HttpResourceGroup"
    }
  },
  "ribbon\\ribbon-evcache\\src\\test\\java\\com\\netflix\\ribbon\\proxy\\sample\\EvCacheClasses.java": {
    "TypeDeclarations": [
      "EvCacheClasses",
      "SampleEVCacheTranscoder"
    ],
    "MethodDeclarations": [
      "SampleEVCacheTranscoder.asyncDecode(CachedData)",
      "SampleEVCacheTranscoder.encode(Object)",
      "SampleEVCacheTranscoder.decode(CachedData)",
      "SampleEVCacheTranscoder.getMaxSize()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "EVCacheTranscoder": "com.netflix.evcache.EVCacheTranscoder",
      "CachedData": "net.spy.memcached.CachedData"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-evcache\\src\\test\\java\\com\\netflix\\ribbon\\proxy\\sample\\HystrixHandlers.java": {
    "TypeDeclarations": [
      "HystrixHandlers",
      "SampleHttpResponseValidator",
      "MovieFallbackHandler"
    ],
    "MethodDeclarations": [
      "SampleHttpResponseValidator.validate(HttpClientResponse)",
      "MovieFallbackHandler.getFallback(HystrixInvokableInfo, Map)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "HystrixInvokableInfo": "com.netflix.hystrix.HystrixInvokableInfo",
      "ServerError": "com.netflix.ribbon.ServerError",
      "UnsuccessfulResponseException": "com.netflix.ribbon.UnsuccessfulResponseException",
      "HttpResponseValidator": "com.netflix.ribbon.http.HttpResponseValidator",
      "FallbackHandler": "com.netflix.ribbon.hystrix.FallbackHandler",
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "HttpClientResponse": "io.reactivex.netty.protocol.http.client.HttpClientResponse",
      "Observable": "rx.Observable",
      "Map": "java.util.Map"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-evcache\\src\\test\\java\\com\\netflix\\ribbon\\proxy\\sample\\Movie.java": {
    "TypeDeclarations": [
      "Movie"
    ],
    "MethodDeclarations": [],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {},
    "FieldTypes": {}
  },
  "ribbon\\ribbon-evcache\\src\\test\\java\\com\\netflix\\ribbon\\proxy\\sample\\MovieServiceInterfaces.java": {
    "TypeDeclarations": [
      "MovieServiceInterfaces",
      "SampleMovieService",
      "ShortMovieService",
      "BrokenMovieService",
      "SampleMovieServiceWithResourceGroupNameAnnotation",
      "SampleMovieServiceWithResourceGroupClassAnnotation",
      "BrokenMovieServiceWithResourceGroupNameAndClassAnnotation",
      "TemplateNameDerivedFromMethodName",
      "HystrixOptionalAnnotationValues",
      "PostsWithDifferentContentTypes"
    ],
    "MethodDeclarations": [
      "SampleMovieService.findMovieById(String)",
      "SampleMovieService.findRawMovieById(String)",
      "SampleMovieService.findMovie(String, String)",
      "SampleMovieService.registerMovie(Movie)",
      "SampleMovieService.updateMovie(String, Movie)",
      "SampleMovieService.updateMoviePartial(String, Movie)",
      "SampleMovieService.registerTitle(String)",
      "SampleMovieService.registerByteBufBinary(ByteBuf)",
      "SampleMovieService.registerByteArrayBinary(BasicType(dimensions=[None], name=byte))",
      "SampleMovieService.deleteMovie(String)",
      "ShortMovieService.findMovieById(String)",
      "ShortMovieService.findAll()",
      "BrokenMovieService.returnTypeNotRibbonRequest()",
      "BrokenMovieService.missingHttpAnnotation()",
      "BrokenMovieService.multipleContentParameters(Movie, Movie)",
      "TemplateNameDerivedFromMethodName.myTemplateName()",
      "HystrixOptionalAnnotationValues.hystrixWithCacheKeyOnly()",
      "HystrixOptionalAnnotationValues.hystrixWithValidatorOnly()",
      "HystrixOptionalAnnotationValues.hystrixWithFallbackHandlerOnly()",
      "PostsWithDifferentContentTypes.postwithRawContentSource(AtomicReference, BasicType(dimensions=[], name=int), Observable)",
      "PostsWithDifferentContentTypes.postwithByteBufContent(ByteBuf)",
      "PostsWithDifferentContentTypes.postwithByteArrayContent(BasicType(dimensions=[None], name=byte))",
      "PostsWithDifferentContentTypes.postwithStringContent(String)",
      "PostsWithDifferentContentTypes.postwithMovieContent(Movie)",
      "PostsWithDifferentContentTypes.postwithMovieContentBroken(Movie)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "RibbonRequest": "com.netflix.ribbon.RibbonRequest",
      "com.netflix.ribbon.proxy.annotation.*": "com.netflix.ribbon.proxy.annotation",
      "Property": "com.netflix.ribbon.proxy.annotation.ClientProperties.Property",
      "Header": "com.netflix.ribbon.proxy.annotation.Http.Header",
      "HttpMethod": "com.netflix.ribbon.proxy.annotation.Http.HttpMethod",
      "MovieFallbackHandler": "com.netflix.ribbon.proxy.sample.HystrixHandlers.MovieFallbackHandler",
      "SampleHttpResponseValidator": "com.netflix.ribbon.proxy.sample.HystrixHandlers.SampleHttpResponseValidator",
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "Observable": "rx.Observable",
      "AtomicReference": "java.util.concurrent.atomic.AtomicReference",
      "SampleHttpResourceGroup": "com.netflix.ribbon.proxy.sample.ResourceGroupClasses.SampleHttpResourceGroup"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-evcache\\src\\test\\java\\com\\netflix\\ribbon\\proxy\\sample\\MovieTransformer.java": {
    "TypeDeclarations": [
      "MovieTransformer"
    ],
    "MethodDeclarations": [
      "MovieTransformer.call(MovieTransformer, ByteBufAllocator)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "ByteBufAllocator": "io.netty.buffer.ByteBufAllocator",
      "ContentTransformer": "io.reactivex.netty.channel.ContentTransformer"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-evcache\\src\\test\\java\\com\\netflix\\ribbon\\proxy\\sample\\ResourceGroupClasses.java": {
    "TypeDeclarations": [
      "ResourceGroupClasses",
      "SampleHttpResourceGroup"
    ],
    "MethodDeclarations": [],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "HttpResourceGroup": "com.netflix.ribbon.http.HttpResourceGroup"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-evcache\\src\\test\\java\\com\\netflix\\ribbon\\proxy\\sample\\SampleCacheProviderFactory.java": {
    "TypeDeclarations": [
      "SampleCacheProviderFactory",
      "SampleCacheProvider"
    ],
    "MethodDeclarations": [
      "SampleCacheProviderFactory.createCacheProvider()",
      "SampleCacheProvider.get(String, Map)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "CacheProvider": "com.netflix.ribbon.CacheProvider",
      "CacheProviderFactory": "com.netflix.ribbon.CacheProviderFactory",
      "Observable": "rx.Observable",
      "Map": "java.util.Map"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-evcache\\src\\test\\java\\com\\netflix\\ribbon\\proxy\\sample\\SampleMovieServiceWithEVCache.java": {
    "TypeDeclarations": [
      "SampleMovieServiceWithEVCache"
    ],
    "MethodDeclarations": [
      "SampleMovieServiceWithEVCache.findMovieById(String)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "RibbonRequest": "com.netflix.ribbon.RibbonRequest",
      "CacheProvider": "com.netflix.ribbon.proxy.annotation.CacheProvider",
      "EvCache": "com.netflix.ribbon.proxy.annotation.EvCache",
      "Http": "com.netflix.ribbon.proxy.annotation.Http",
      "Header": "com.netflix.ribbon.proxy.annotation.Http.Header",
      "HttpMethod": "com.netflix.ribbon.proxy.annotation.Http.HttpMethod",
      "Hystrix": "com.netflix.ribbon.proxy.annotation.Hystrix",
      "TemplateName": "com.netflix.ribbon.proxy.annotation.TemplateName",
      "Var": "com.netflix.ribbon.proxy.annotation.Var",
      "SampleEVCacheTranscoder": "com.netflix.ribbon.proxy.sample.EvCacheClasses.SampleEVCacheTranscoder",
      "MovieFallbackHandler": "com.netflix.ribbon.proxy.sample.HystrixHandlers.MovieFallbackHandler",
      "SampleHttpResponseValidator": "com.netflix.ribbon.proxy.sample.HystrixHandlers.SampleHttpResponseValidator",
      "SampleMovieService": "com.netflix.ribbon.proxy.sample.MovieServiceInterfaces.SampleMovieService",
      "ByteBuf": "io.netty.buffer.ByteBuf"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-examples\\src\\main\\java\\com\\netflix\\ribbon\\examples\\ExampleAppWithLocalResource.java": {
    "TypeDeclarations": [
      "ExampleAppWithLocalResource"
    ],
    "MethodDeclarations": [
      "ExampleAppWithLocalResource.run()",
      "ExampleAppWithLocalResource.runApp()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "ExampleAppWithLocalResource.run"
      ],
      "Unresolved": [
        "nextInt",
        "com.sun.net.httpserver.HttpServer.setExecutor",
        "com.sun.net.httpserver.HttpServer.start",
        "com.sun.net.httpserver.HttpServer.stop"
      ]
    },
    "Imports": {
      "Random": "java.util.Random",
      "ExecutorService": "java.util.concurrent.ExecutorService",
      "Executors": "java.util.concurrent.Executors",
      "HttpServerFactory": "com.sun.jersey.api.container.httpserver.HttpServerFactory",
      "PackagesResourceConfig": "com.sun.jersey.api.core.PackagesResourceConfig",
      "HttpServer": "com.sun.net.httpserver.HttpServer"
    },
    "FieldTypes": {
      "server": "com.sun.net.httpserver.HttpServer"
    }
  },
  "ribbon\\ribbon-examples\\src\\main\\java\\com\\netflix\\ribbon\\examples\\loadbalancer\\URLConnectionLoadBalancer.java": {
    "TypeDeclarations": [
      "URLConnectionLoadBalancer"
    ],
    "MethodDeclarations": [
      "URLConnectionLoadBalancer.call(String)",
      "URLConnectionLoadBalancer.getLoadBalancerStats()",
      "URLConnectionLoadBalancer.main(String)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "com.netflix.loadbalancer.reactive.LoadBalancerCommand"
      ],
      "Unresolved": [
        "buildFixedServerListLoadBalancer",
        "withLoadBalancer",
        "build",
        "submit",
        "toBlocking",
        "first"
      ]
    },
    "Imports": {
      "HttpURLConnection": "java.net.HttpURLConnection",
      "MalformedURLException": "java.net.MalformedURLException",
      "URL": "java.net.URL",
      "List": "java.util.List",
      "Observable": "rx.Observable",
      "Lists": "com.google.common.collect.Lists",
      "DefaultLoadBalancerRetryHandler": "com.netflix.client.DefaultLoadBalancerRetryHandler",
      "RetryHandler": "com.netflix.client.RetryHandler",
      "BaseLoadBalancer": "com.netflix.loadbalancer.BaseLoadBalancer",
      "ILoadBalancer": "com.netflix.loadbalancer.ILoadBalancer",
      "LoadBalancerBuilder": "com.netflix.loadbalancer.LoadBalancerBuilder",
      "LoadBalancerStats": "com.netflix.loadbalancer.LoadBalancerStats",
      "Server": "com.netflix.loadbalancer.Server",
      "LoadBalancerCommand": "com.netflix.loadbalancer.reactive.LoadBalancerCommand",
      "ServerOperation": "com.netflix.loadbalancer.reactive.ServerOperation"
    },
    "FieldTypes": {
      "loadBalancer": "com.netflix.loadbalancer.ILoadBalancer",
      "retryHandler": "com.netflix.client.RetryHandler"
    }
  },
  "ribbon\\ribbon-examples\\src\\main\\java\\com\\netflix\\ribbon\\examples\\netty\\http\\LoadBalancingExample.java": {
    "TypeDeclarations": [
      "LoadBalancingExample"
    ],
    "MethodDeclarations": [
      "LoadBalancingExample.main(String)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "buildFixedServerListLoadBalancer",
        "subscribe"
      ]
    },
    "Imports": {
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "HttpClientRequest": "io.reactivex.netty.protocol.http.client.HttpClientRequest",
      "HttpClientResponse": "io.reactivex.netty.protocol.http.client.HttpClientResponse",
      "List": "java.util.List",
      "CountDownLatch": "java.util.concurrent.CountDownLatch",
      "Observer": "rx.Observer",
      "Lists": "com.google.common.collect.Lists",
      "RibbonTransport": "com.netflix.ribbon.transport.netty.RibbonTransport",
      "LoadBalancingHttpClient": "com.netflix.ribbon.transport.netty.http.LoadBalancingHttpClient",
      "BaseLoadBalancer": "com.netflix.loadbalancer.BaseLoadBalancer",
      "LoadBalancerBuilder": "com.netflix.loadbalancer.LoadBalancerBuilder",
      "Server": "com.netflix.loadbalancer.Server"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-examples\\src\\main\\java\\com\\netflix\\ribbon\\examples\\netty\\http\\SimpleGet.java": {
    "TypeDeclarations": [
      "SimpleGet"
    ],
    "MethodDeclarations": [
      "SimpleGet.main(String)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "toBlocking",
        "forEach",
        "subscribe"
      ]
    },
    "Imports": {
      "RibbonTransport": "com.netflix.ribbon.transport.netty.RibbonTransport",
      "LoadBalancingHttpClient": "com.netflix.ribbon.transport.netty.http.LoadBalancingHttpClient",
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "HttpClientRequest": "io.reactivex.netty.protocol.http.client.HttpClientRequest",
      "HttpClientResponse": "io.reactivex.netty.protocol.http.client.HttpClientResponse",
      "Action1": "rx.functions.Action1",
      "Charset": "java.nio.charset.Charset",
      "CountDownLatch": "java.util.concurrent.CountDownLatch",
      "TimeUnit": "java.util.concurrent.TimeUnit"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-examples\\src\\main\\java\\com\\netflix\\ribbon\\examples\\restclient\\SampleApp.java": {
    "TypeDeclarations": [
      "SampleApp"
    ],
    "MethodDeclarations": [
      "SampleApp.main(String)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "getProperty",
        "uri",
        "build",
        "setProperty"
      ]
    },
    "Imports": {
      "URI": "java.net.URI",
      "ClientFactory": "com.netflix.client.ClientFactory",
      "HttpRequest": "com.netflix.client.http.HttpRequest",
      "HttpResponse": "com.netflix.client.http.HttpResponse",
      "ConfigurationManager": "com.netflix.config.ConfigurationManager",
      "ZoneAwareLoadBalancer": "com.netflix.loadbalancer.ZoneAwareLoadBalancer",
      "RestClient": "com.netflix.niws.client.http.RestClient"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-examples\\src\\main\\java\\com\\netflix\\ribbon\\examples\\rx\\AbstractRxMovieClient.java": {
    "TypeDeclarations": [
      "AbstractRxMovieClient"
    ],
    "MethodDeclarations": [
      "AbstractRxMovieClient.triggerMoviesRegistration()",
      "AbstractRxMovieClient.triggerRecommendationsUpdate()",
      "AbstractRxMovieClient.triggerRecommendationsSearch()",
      "AbstractRxMovieClient.registerMovies()",
      "AbstractRxMovieClient.updateRecommendations()",
      "AbstractRxMovieClient.searchCatalog()",
      "AbstractRxMovieClient.runExample()",
      "AbstractRxMovieClient.executeServerCalls()",
      "AbstractRxMovieClient.shutdown()",
      "AbstractRxMovieClient.verifyStatus(Notification)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "AbstractRxMovieClient.triggerMoviesRegistration",
        "AbstractRxMovieClient.triggerRecommendationsUpdate",
        "AbstractRxMovieClient.triggerRecommendationsSearch",
        "AbstractRxMovieClient.executeServerCalls",
        "AbstractRxMovieClient.shutdown",
        "AbstractRxMovieClient.registerMovies",
        "AbstractRxMovieClient.verifyStatus",
        "AbstractRxMovieClient.updateRecommendations",
        "AbstractRxMovieClient.verifyStatus",
        "AbstractRxMovieClient.searchCatalog"
      ],
      "Unresolved": [
        "flatMap",
        "java.util.regex.Pattern.split",
        "zipWith",
        "format",
        "printStackTrace",
        "materialize",
        "flatMap",
        "materialize",
        "flatMap",
        "toBlocking",
        "last"
      ]
    },
    "Imports": {
      "HystrixTimer": "com.netflix.hystrix.util.HystrixTimer",
      "Movie": "com.netflix.ribbon.examples.rx.common.Movie",
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "Notification": "rx.Notification",
      "Observable": "rx.Observable",
      "Func1": "rx.functions.Func1",
      "Func2": "rx.functions.Func2",
      "Charset": "java.nio.charset.Charset",
      "ArrayList": "java.util.ArrayList",
      "Collections": "java.util.Collections",
      "List": "java.util.List",
      "Pattern": "java.util.regex.Pattern",
      "java.lang.String.*": "java.lang.String"
    },
    "FieldTypes": {
      "TEST_USER": "java.lang.String",
      "NEW_LINE_SPLIT_RE": "java.util.regex.Pattern"
    }
  },
  "ribbon\\ribbon-examples\\src\\main\\java\\com\\netflix\\ribbon\\examples\\rx\\RxMovieServer.java": {
    "TypeDeclarations": [
      "RxMovieServer"
    ],
    "MethodDeclarations": [
      "RxMovieServer.createServer()",
      "RxMovieServer.handleRecommendationsByUserId(HttpServerRequest, HttpServerResponse)",
      "RxMovieServer.handleRecommendationsBy(HttpServerRequest, HttpServerResponse)",
      "RxMovieServer.handleUpdateRecommendationsForUser(HttpServerRequest, HttpServerResponse)",
      "RxMovieServer.handleRegisterMovie(HttpServerRequest, HttpServerResponse)",
      "RxMovieServer.userIdFromPath(String)",
      "RxMovieServer.main(String)"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.lang.equals",
        "java.util.Map.containsKey",
        "java.util.Map.get",
        "java.util.Map.get",
        "java.util.Map.get",
        "java.util.Map.values",
        "java.lang.equals",
        "java.lang.equals",
        "java.util.Map.values",
        "java.util.Map.containsKey",
        "java.util.Map.get",
        "java.util.Map.put",
        "java.util.Map.put"
      ],
      "UserDefined": [
        "io.reactivex.netty.pipeline.PipelineConfigurators",
        "RxMovieServer.handleRecommendationsByUserId",
        "RxMovieServer.handleUpdateRecommendationsForUser",
        "RxMovieServer.handleRecommendationsBy",
        "RxMovieServer.handleRegisterMovie",
        "RxMovieServer.userIdFromPath",
        "RxMovieServer.userIdFromPath",
        "RxMovieServer.createServer"
      ],
      "Unresolved": [
        "pipelineConfigurator",
        "enableWireLogging",
        "build",
        "contains",
        "contains",
        "contains",
        "append",
        "getBytes",
        "format",
        "get",
        "get",
        "append",
        "getBytes",
        "flatMap",
        "format",
        "flatMap",
        "java.util.regex.Pattern.matcher",
        "startAndWait"
      ]
    },
    "Imports": {
      "Charset": "java.nio.charset.Charset",
      "List": "java.util.List",
      "Map": "java.util.Map",
      "Set": "java.util.Set",
      "ConcurrentHashMap": "java.util.concurrent.ConcurrentHashMap",
      "Matcher": "java.util.regex.Matcher",
      "Pattern": "java.util.regex.Pattern",
      "Movie": "com.netflix.ribbon.examples.rx.common.Movie",
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "UnpooledByteBufAllocator": "io.netty.buffer.UnpooledByteBufAllocator",
      "HttpMethod": "io.netty.handler.codec.http.HttpMethod",
      "HttpResponseStatus": "io.netty.handler.codec.http.HttpResponseStatus",
      "LogLevel": "io.netty.handler.logging.LogLevel",
      "ConcurrentSet": "io.netty.util.internal.ConcurrentSet",
      "RxNetty": "io.reactivex.netty.RxNetty",
      "PipelineConfigurators": "io.reactivex.netty.pipeline.PipelineConfigurators",
      "HttpServer": "io.reactivex.netty.protocol.http.server.HttpServer",
      "HttpServerRequest": "io.reactivex.netty.protocol.http.server.HttpServerRequest",
      "HttpServerResponse": "io.reactivex.netty.protocol.http.server.HttpServerResponse",
      "RequestHandler": "io.reactivex.netty.protocol.http.server.RequestHandler",
      "Observable": "rx.Observable",
      "Func1": "rx.functions.Func1",
      "java.lang.String.*": "java.lang.String"
    },
    "FieldTypes": {
      "USER_RECOMMENDATIONS_PATH_RE": "java.util.regex.Pattern",
      "movies": "java.util.Map",
      "userRecommendations": "java.util.Map"
    }
  },
  "ribbon\\ribbon-examples\\src\\main\\java\\com\\netflix\\ribbon\\examples\\rx\\common\\InMemoryCacheProviderFactory.java": {
    "TypeDeclarations": [
      "InMemoryCacheProviderFactory",
      "InMemoryCacheProvider"
    ],
    "MethodDeclarations": [
      "InMemoryCacheProviderFactory.createCacheProvider()",
      "InMemoryCacheProvider.get(String, Map)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "CacheProvider": "com.netflix.ribbon.CacheProvider",
      "CacheProviderFactory": "com.netflix.ribbon.CacheProviderFactory",
      "Observable": "rx.Observable",
      "Map": "java.util.Map",
      "ConcurrentHashMap": "java.util.concurrent.ConcurrentHashMap"
    },
    "FieldTypes": {
      "cacheMap": "java.util.Map"
    }
  },
  "ribbon\\ribbon-examples\\src\\main\\java\\com\\netflix\\ribbon\\examples\\rx\\common\\Movie.java": {
    "TypeDeclarations": [
      "Movie"
    ],
    "MethodDeclarations": [
      "Movie.getId()",
      "Movie.getName()",
      "Movie.getCategory()",
      "Movie.getContentURI()",
      "Movie.getAgeGroup()",
      "Movie.equals(Object)",
      "Movie.hashCode()",
      "Movie.toString()",
      "Movie.from(String)",
      "Movie.from(ByteBuf)"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.lang.getClass"
      ],
      "UserDefined": [
        "Movie.from"
      ],
      "Unresolved": [
        "java.util.regex.Pattern.matcher"
      ]
    },
    "Imports": {
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "Charset": "java.nio.charset.Charset",
      "Matcher": "java.util.regex.Matcher",
      "Pattern": "java.util.regex.Pattern"
    },
    "FieldTypes": {
      "FORMAT_RE": "java.util.regex.Pattern"
    }
  },
  "ribbon\\ribbon-examples\\src\\main\\java\\com\\netflix\\ribbon\\examples\\rx\\common\\Recommendations.java": {
    "TypeDeclarations": [
      "Recommendations"
    ],
    "MethodDeclarations": [
      "Recommendations.getMovies()",
      "Recommendations.equals(Object)",
      "Recommendations.hashCode()",
      "Recommendations.toString()",
      "Recommendations.from(String)"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.lang.getClass",
        "java.util.List.add"
      ],
      "UserDefined": [],
      "Unresolved": [
        "java.util.List.equals",
        "java.util.List.hashCode",
        "java.util.regex.Pattern.matcher",
        "trim"
      ]
    },
    "Imports": {
      "ArrayList": "java.util.ArrayList",
      "Collections": "java.util.Collections",
      "List": "java.util.List",
      "Matcher": "java.util.regex.Matcher",
      "Pattern": "java.util.regex.Pattern"
    },
    "FieldTypes": {
      "FORMAT_RE": "java.util.regex.Pattern",
      "movies": "java.util.List"
    }
  },
  "ribbon\\ribbon-examples\\src\\main\\java\\com\\netflix\\ribbon\\examples\\rx\\common\\RecommendationServiceFallbackHandler.java": {
    "TypeDeclarations": [
      "RecommendationServiceFallbackHandler"
    ],
    "MethodDeclarations": [
      "RecommendationServiceFallbackHandler.getFallback(HystrixInvokableInfo, Map)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "getBytes"
      ]
    },
    "Imports": {
      "HystrixInvokableInfo": "com.netflix.hystrix.HystrixInvokableInfo",
      "FallbackHandler": "com.netflix.ribbon.hystrix.FallbackHandler",
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "UnpooledByteBufAllocator": "io.netty.buffer.UnpooledByteBufAllocator",
      "Observable": "rx.Observable",
      "Charset": "java.nio.charset.Charset",
      "Map": "java.util.Map"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-examples\\src\\main\\java\\com\\netflix\\ribbon\\examples\\rx\\common\\RecommendationServiceResponseValidator.java": {
    "TypeDeclarations": [
      "RecommendationServiceResponseValidator"
    ],
    "MethodDeclarations": [
      "RecommendationServiceResponseValidator.validate(HttpClientResponse)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "code"
      ]
    },
    "Imports": {
      "ServerError": "com.netflix.ribbon.ServerError",
      "UnsuccessfulResponseException": "com.netflix.ribbon.UnsuccessfulResponseException",
      "HttpResponseValidator": "com.netflix.ribbon.http.HttpResponseValidator",
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "HttpClientResponse": "io.reactivex.netty.protocol.http.client.HttpClientResponse"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-examples\\src\\main\\java\\com\\netflix\\ribbon\\examples\\rx\\common\\RxMovieTransformer.java": {
    "TypeDeclarations": [
      "RxMovieTransformer"
    ],
    "MethodDeclarations": [
      "RxMovieTransformer.call(Movie, ByteBufAllocator)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "getBytes"
      ]
    },
    "Imports": {
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "ByteBufAllocator": "io.netty.buffer.ByteBufAllocator",
      "ContentTransformer": "io.reactivex.netty.channel.ContentTransformer",
      "Charset": "java.nio.charset.Charset"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-examples\\src\\main\\java\\com\\netflix\\ribbon\\examples\\rx\\proxy\\MovieService.java": {
    "TypeDeclarations": [
      "MovieService"
    ],
    "MethodDeclarations": [
      "MovieService.recommendationsByUserId(String)",
      "MovieService.recommendationsBy(String, String)",
      "MovieService.registerMovie(Movie)",
      "MovieService.updateRecommendations(String, String)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "RibbonRequest": "com.netflix.ribbon.RibbonRequest",
      "InMemoryCacheProviderFactory": "com.netflix.ribbon.examples.rx.common.InMemoryCacheProviderFactory",
      "Movie": "com.netflix.ribbon.examples.rx.common.Movie",
      "RecommendationServiceFallbackHandler": "com.netflix.ribbon.examples.rx.common.RecommendationServiceFallbackHandler",
      "RecommendationServiceResponseValidator": "com.netflix.ribbon.examples.rx.common.RecommendationServiceResponseValidator",
      "RxMovieTransformer": "com.netflix.ribbon.examples.rx.common.RxMovieTransformer",
      "CacheProvider": "com.netflix.ribbon.proxy.annotation.CacheProvider",
      "ClientProperties": "com.netflix.ribbon.proxy.annotation.ClientProperties",
      "Property": "com.netflix.ribbon.proxy.annotation.ClientProperties.Property",
      "Content": "com.netflix.ribbon.proxy.annotation.Content",
      "ContentTransformerClass": "com.netflix.ribbon.proxy.annotation.ContentTransformerClass",
      "Http": "com.netflix.ribbon.proxy.annotation.Http",
      "Header": "com.netflix.ribbon.proxy.annotation.Http.Header",
      "HttpMethod": "com.netflix.ribbon.proxy.annotation.Http.HttpMethod",
      "Hystrix": "com.netflix.ribbon.proxy.annotation.Hystrix",
      "TemplateName": "com.netflix.ribbon.proxy.annotation.TemplateName",
      "Var": "com.netflix.ribbon.proxy.annotation.Var",
      "ByteBuf": "io.netty.buffer.ByteBuf"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-examples\\src\\main\\java\\com\\netflix\\ribbon\\examples\\rx\\proxy\\RxMovieProxyExample.java": {
    "TypeDeclarations": [
      "RxMovieProxyExample"
    ],
    "MethodDeclarations": [
      "RxMovieProxyExample.triggerMoviesRegistration()",
      "RxMovieProxyExample.triggerRecommendationsUpdate()",
      "RxMovieProxyExample.triggerRecommendationsSearch()",
      "RxMovieProxyExample.shutdown()",
      "RxMovieProxyExample.main(String)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "setProperty",
        "setProperty",
        "toObservable",
        "toObservable",
        "toObservable",
        "toObservable",
        "toObservable",
        "toObservable",
        "toObservable",
        "runExample"
      ]
    },
    "Imports": {
      "CommonClientConfigKey": "com.netflix.client.config.CommonClientConfigKey",
      "ConfigurationManager": "com.netflix.config.ConfigurationManager",
      "Ribbon": "com.netflix.ribbon.Ribbon",
      "AbstractRxMovieClient": "com.netflix.ribbon.examples.rx.AbstractRxMovieClient",
      "RxMovieServer": "com.netflix.ribbon.examples.rx.RxMovieServer",
      "Movie": "com.netflix.ribbon.examples.rx.common.Movie",
      "ProxyLifeCycle": "com.netflix.ribbon.proxy.ProxyLifeCycle",
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "Observable": "rx.Observable"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-examples\\src\\main\\java\\com\\netflix\\ribbon\\examples\\rx\\template\\RxMovieTemplateExample.java": {
    "TypeDeclarations": [
      "RxMovieTemplateExample"
    ],
    "MethodDeclarations": [
      "RxMovieTemplateExample.triggerMoviesRegistration()",
      "RxMovieTemplateExample.triggerRecommendationsUpdate()",
      "RxMovieTemplateExample.triggerRecommendationsSearch()",
      "RxMovieTemplateExample.main(String)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "withMaxAutoRetriesNextServer",
        "withConfigurationBasedServerList",
        "com.netflix.ribbon.http.HttpResourceGroup.newTemplateBuilder",
        "withMethod",
        "withUriTemplate",
        "withHeader",
        "withHeader",
        "withResponseValidator",
        "build",
        "com.netflix.ribbon.http.HttpResourceGroup.newTemplateBuilder",
        "withMethod",
        "withUriTemplate",
        "withHeader",
        "withHeader",
        "withResponseValidator",
        "build",
        "com.netflix.ribbon.http.HttpResourceGroup.newTemplateBuilder",
        "withMethod",
        "withUriTemplate",
        "withHeader",
        "withHeader",
        "withFallbackProvider",
        "withResponseValidator",
        "build",
        "com.netflix.ribbon.http.HttpResourceGroup.newTemplateBuilder",
        "withMethod",
        "withUriTemplate",
        "withHeader",
        "withHeader",
        "withFallbackProvider",
        "withResponseValidator",
        "build",
        "com.netflix.ribbon.http.HttpRequestTemplate.requestBuilder",
        "withRawContentSource",
        "build",
        "toObservable",
        "com.netflix.ribbon.http.HttpRequestTemplate.requestBuilder",
        "withRawContentSource",
        "build",
        "toObservable",
        "com.netflix.ribbon.http.HttpRequestTemplate.requestBuilder",
        "withRawContentSource",
        "build",
        "toObservable",
        "com.netflix.ribbon.http.HttpRequestTemplate.requestBuilder",
        "withRawContentSource",
        "withRequestProperty",
        "build",
        "toObservable",
        "com.netflix.ribbon.http.HttpRequestTemplate.requestBuilder",
        "withRawContentSource",
        "withRequestProperty",
        "build",
        "toObservable",
        "com.netflix.ribbon.http.HttpRequestTemplate.requestBuilder",
        "withRequestProperty",
        "build",
        "toObservable",
        "com.netflix.ribbon.http.HttpRequestTemplate.requestBuilder",
        "withRequestProperty",
        "withRequestProperty",
        "build",
        "toObservable",
        "runExample"
      ]
    },
    "Imports": {
      "ClientOptions": "com.netflix.ribbon.ClientOptions",
      "Ribbon": "com.netflix.ribbon.Ribbon",
      "AbstractRxMovieClient": "com.netflix.ribbon.examples.rx.AbstractRxMovieClient",
      "RxMovieServer": "com.netflix.ribbon.examples.rx.RxMovieServer",
      "Movie": "com.netflix.ribbon.examples.rx.common.Movie",
      "RecommendationServiceFallbackHandler": "com.netflix.ribbon.examples.rx.common.RecommendationServiceFallbackHandler",
      "RecommendationServiceResponseValidator": "com.netflix.ribbon.examples.rx.common.RecommendationServiceResponseValidator",
      "RxMovieTransformer": "com.netflix.ribbon.examples.rx.common.RxMovieTransformer",
      "HttpRequestTemplate": "com.netflix.ribbon.http.HttpRequestTemplate",
      "HttpResourceGroup": "com.netflix.ribbon.http.HttpResourceGroup",
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "StringTransformer": "io.reactivex.netty.channel.StringTransformer",
      "Observable": "rx.Observable"
    },
    "FieldTypes": {
      "httpResourceGroup": "com.netflix.ribbon.http.HttpResourceGroup",
      "registerMovieTemplate": "com.netflix.ribbon.http.HttpRequestTemplate",
      "updateRecommendationTemplate": "com.netflix.ribbon.http.HttpRequestTemplate",
      "recommendationsByUserIdTemplate": "com.netflix.ribbon.http.HttpRequestTemplate",
      "recommendationsByTemplate": "com.netflix.ribbon.http.HttpRequestTemplate"
    }
  },
  "ribbon\\ribbon-examples\\src\\main\\java\\com\\netflix\\ribbon\\examples\\rx\\transport\\RxMovieTransportExample.java": {
    "TypeDeclarations": [
      "RxMovieTransportExample"
    ],
    "MethodDeclarations": [
      "RxMovieTransportExample.triggerMoviesRegistration()",
      "RxMovieTransportExample.registerMovie(Movie)",
      "RxMovieTransportExample.triggerRecommendationsUpdate()",
      "RxMovieTransportExample.updateRecommendation(String, Movie)",
      "RxMovieTransportExample.triggerRecommendationsSearch()",
      "RxMovieTransportExample.main(String)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "RxMovieTransportExample.registerMovie",
        "RxMovieTransportExample.registerMovie",
        "RxMovieTransportExample.registerMovie",
        "RxMovieTransportExample.updateRecommendation",
        "RxMovieTransportExample.updateRecommendation"
      ],
      "Unresolved": [
        "build",
        "withHeader",
        "withHeader",
        "withRawContentSource",
        "com.netflix.ribbon.transport.netty.http.LoadBalancingHttpClient.submit",
        "flatMap",
        "code",
        "format",
        "withHeader",
        "withHeader",
        "withRawContentSource",
        "format",
        "com.netflix.ribbon.transport.netty.http.LoadBalancingHttpClient.submit",
        "flatMap",
        "code",
        "format",
        "withHeader",
        "withHeader",
        "format",
        "com.netflix.ribbon.transport.netty.http.LoadBalancingHttpClient.submit",
        "flatMap",
        "code",
        "format",
        "withHeader",
        "withHeader",
        "com.netflix.ribbon.transport.netty.http.LoadBalancingHttpClient.submit",
        "flatMap",
        "code",
        "format",
        "runExample"
      ]
    },
    "Imports": {
      "CommonClientConfigKey": "com.netflix.client.config.CommonClientConfigKey",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "RibbonTransport": "com.netflix.ribbon.transport.netty.RibbonTransport",
      "LoadBalancingHttpClient": "com.netflix.ribbon.transport.netty.http.LoadBalancingHttpClient",
      "AbstractRxMovieClient": "com.netflix.ribbon.examples.rx.AbstractRxMovieClient",
      "RxMovieServer": "com.netflix.ribbon.examples.rx.RxMovieServer",
      "Movie": "com.netflix.ribbon.examples.rx.common.Movie",
      "RxMovieTransformer": "com.netflix.ribbon.examples.rx.common.RxMovieTransformer",
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "StringTransformer": "io.reactivex.netty.channel.StringTransformer",
      "HttpClientRequest": "io.reactivex.netty.protocol.http.client.HttpClientRequest",
      "HttpClientResponse": "io.reactivex.netty.protocol.http.client.HttpClientResponse",
      "Observable": "rx.Observable",
      "Func1": "rx.functions.Func1",
      "java.lang.String.*": "java.lang.String"
    },
    "FieldTypes": {
      "client": "com.netflix.ribbon.transport.netty.http.LoadBalancingHttpClient"
    }
  },
  "ribbon\\ribbon-examples\\src\\main\\java\\com\\netflix\\ribbon\\examples\\server\\ServerResources.java": {
    "TypeDeclarations": [
      "ServerResources",
      "Person"
    ],
    "MethodDeclarations": [
      "Person.toString()",
      "Person.hashCode()",
      "Person.equals(Object)",
      "ServerResources.getPerson()",
      "ServerResources.getPersons()",
      "ServerResources.getNoEntity()",
      "ServerResources.getReadTimeout()",
      "ServerResources.createPerson(String)",
      "ServerResources.queryPerson(String, BasicType(dimensions=[], name=int))",
      "ServerResources.getStream()",
      "ServerResources.getPersonStream()",
      "ServerResources.getCustomeEvents()",
      "ServerResources.getXml()"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.lang.getClass",
        "java.util.List.add",
        "java.util.List.add"
      ],
      "UserDefined": [],
      "Unresolved": [
        "org.codehaus.jackson.map.ObjectMapper.writeValueAsString",
        "build",
        "org.codehaus.jackson.map.ObjectMapper.writeValueAsString",
        "build",
        "build",
        "org.codehaus.jackson.map.ObjectMapper.writeValueAsString",
        "build",
        "org.codehaus.jackson.map.ObjectMapper.readValue",
        "build",
        "org.codehaus.jackson.map.ObjectMapper.writeValueAsString",
        "build",
        "org.codehaus.jackson.map.ObjectMapper.writeValueAsString",
        "org.codehaus.jackson.map.ObjectMapper.writeValueAsString",
        "build"
      ]
    },
    "Imports": {
      "IOException": "java.io.IOException",
      "OutputStream": "java.io.OutputStream",
      "List": "java.util.List",
      "Consumes": "javax.ws.rs.Consumes",
      "GET": "javax.ws.rs.GET",
      "POST": "javax.ws.rs.POST",
      "Path": "javax.ws.rs.Path",
      "Produces": "javax.ws.rs.Produces",
      "QueryParam": "javax.ws.rs.QueryParam",
      "WebApplicationException": "javax.ws.rs.WebApplicationException",
      "MediaType": "javax.ws.rs.core.MediaType",
      "Response": "javax.ws.rs.core.Response",
      "StreamingOutput": "javax.ws.rs.core.StreamingOutput",
      "ObjectMapper": "org.codehaus.jackson.map.ObjectMapper",
      "Lists": "com.google.common.collect.Lists",
      "XStream": "com.thoughtworks.xstream.XStream"
    },
    "FieldTypes": {
      "mapper": "org.codehaus.jackson.map.ObjectMapper",
      "persons": "java.util.List",
      "streamContent": "java.util.List"
    }
  },
  "ribbon\\ribbon-examples\\src\\test\\java\\com\\netflix\\ribbon\\examples\\rx\\RxMovieClientTestBase.java": {
    "TypeDeclarations": [
      "RxMovieClientTestBase"
    ],
    "MethodDeclarations": [
      "RxMovieClientTestBase.setUp()",
      "RxMovieClientTestBase.tearDown()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "start",
        "io.reactivex.netty.protocol.http.server.HttpServer.getServerPort",
        "io.reactivex.netty.protocol.http.server.HttpServer.shutdown"
      ]
    },
    "Imports": {
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "HttpServer": "io.reactivex.netty.protocol.http.server.HttpServer",
      "After": "org.junit.After",
      "Before": "org.junit.Before"
    },
    "FieldTypes": {
      "httpServer": "io.reactivex.netty.protocol.http.server.HttpServer"
    }
  },
  "ribbon\\ribbon-examples\\src\\test\\java\\com\\netflix\\ribbon\\examples\\rx\\RxMovieServerTest.java": {
    "TypeDeclarations": [
      "RxMovieServerTest"
    ],
    "MethodDeclarations": [
      "RxMovieServerTest.setUp()",
      "RxMovieServerTest.tearDown()",
      "RxMovieServerTest.testMovieRegistration()",
      "RxMovieServerTest.testUpateRecommendations()",
      "RxMovieServerTest.testRecommendationsByUserId()",
      "RxMovieServerTest.testRecommendationsByMultipleCriteria()",
      "RxMovieServerTest.handleGetMoviesReply(Observable)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "RxMovieServerTest.handleGetMoviesReply",
        "RxMovieServerTest.handleGetMoviesReply"
      ],
      "Unresolved": [
        "java.util.Random.nextInt",
        "start",
        "io.reactivex.netty.protocol.http.server.HttpServer.shutdown",
        "flatMap",
        "toBlocking",
        "first",
        "assertEquals",
        "assertEquals",
        "flatMap",
        "toBlocking",
        "first",
        "assertEquals",
        "assertTrue",
        "contains",
        "assertTrue",
        "assertTrue",
        "getId",
        "assertTrue",
        "getId",
        "assertEquals",
        "assertEquals",
        "toBlocking",
        "first",
        "map",
        "split"
      ]
    },
    "Imports": {
      "Movie": "com.netflix.ribbon.examples.rx.common.Movie",
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "HttpResponseStatus": "io.netty.handler.codec.http.HttpResponseStatus",
      "ConcurrentSet": "io.netty.util.internal.ConcurrentSet",
      "RxNetty": "io.reactivex.netty.RxNetty",
      "StringTransformer": "io.reactivex.netty.channel.StringTransformer",
      "HttpClientResponse": "io.reactivex.netty.protocol.http.client.HttpClientResponse",
      "HttpServer": "io.reactivex.netty.protocol.http.server.HttpServer",
      "After": "org.junit.After",
      "Before": "org.junit.Before",
      "Test": "org.junit.Test",
      "Observable": "rx.Observable",
      "Func1": "rx.functions.Func1",
      "Charset": "java.nio.charset.Charset",
      "Random": "java.util.Random",
      "Set": "java.util.Set",
      "com.netflix.ribbon.examples.rx.common.Movie.*": "com.netflix.ribbon.examples.rx.common.Movie",
      "junit.framework.Assert.*": "junit.framework.Assert"
    },
    "FieldTypes": {
      "RANDOM": "java.util.Random",
      "httpServer": "io.reactivex.netty.protocol.http.server.HttpServer"
    }
  },
  "ribbon\\ribbon-examples\\src\\test\\java\\com\\netflix\\ribbon\\examples\\rx\\common\\MovieTest.java": {
    "TypeDeclarations": [
      "MovieTest"
    ],
    "MethodDeclarations": [
      "MovieTest.testStringParsing()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "assertEquals"
      ]
    },
    "Imports": {
      "Test": "org.junit.Test",
      "com.netflix.ribbon.examples.rx.common.Movie.*": "com.netflix.ribbon.examples.rx.common.Movie",
      "org.junit.Assert.*": "org.junit.Assert"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-examples\\src\\test\\java\\com\\netflix\\ribbon\\examples\\rx\\common\\RecommendationsTest.java": {
    "TypeDeclarations": [
      "RecommendationsTest"
    ],
    "MethodDeclarations": [
      "RecommendationsTest.testStringParsing()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "assertEquals"
      ]
    },
    "Imports": {
      "Test": "org.junit.Test",
      "ArrayList": "java.util.ArrayList",
      "List": "java.util.List",
      "junit.framework.Assert.*": "junit.framework.Assert"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-examples\\src\\test\\java\\com\\netflix\\ribbon\\examples\\rx\\proxy\\RxMovieProxyExampleTest.java": {
    "TypeDeclarations": [
      "RxMovieProxyExampleTest"
    ],
    "MethodDeclarations": [
      "RxMovieProxyExampleTest.testProxyExample()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "assertTrue",
        "runExample"
      ]
    },
    "Imports": {
      "RxMovieClientTestBase": "com.netflix.ribbon.examples.rx.RxMovieClientTestBase",
      "Test": "org.junit.Test",
      "junit.framework.Assert.*": "junit.framework.Assert"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-examples\\src\\test\\java\\com\\netflix\\ribbon\\examples\\rx\\template\\RxMovieTemplateExampleTest.java": {
    "TypeDeclarations": [
      "RxMovieTemplateExampleTest"
    ],
    "MethodDeclarations": [
      "RxMovieTemplateExampleTest.testTemplateExample()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "assertTrue",
        "runExample"
      ]
    },
    "Imports": {
      "RxMovieClientTestBase": "com.netflix.ribbon.examples.rx.RxMovieClientTestBase",
      "Test": "org.junit.Test",
      "junit.framework.Assert.*": "junit.framework.Assert"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-examples\\src\\test\\java\\com\\netflix\\ribbon\\examples\\rx\\transport\\RxMovieTransportExampleTest.java": {
    "TypeDeclarations": [
      "RxMovieTransportExampleTest"
    ],
    "MethodDeclarations": [
      "RxMovieTransportExampleTest.testTemplateExample()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "assertTrue",
        "runExample"
      ]
    },
    "Imports": {
      "RxMovieClientTestBase": "com.netflix.ribbon.examples.rx.RxMovieClientTestBase",
      "Test": "org.junit.Test",
      "junit.framework.Assert.*": "junit.framework.Assert"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-guice\\src\\main\\java\\com\\netflix\\ribbon\\guice\\RibbonModule.java": {
    "TypeDeclarations": [
      "RibbonModule"
    ],
    "MethodDeclarations": [
      "RibbonModule.configure()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "bind",
        "toInstance",
        "bind",
        "to",
        "in",
        "bind",
        "to",
        "in",
        "bind",
        "to",
        "in"
      ]
    },
    "Imports": {
      "AbstractModule": "com.google.inject.AbstractModule",
      "Scopes": "com.google.inject.Scopes",
      "ClientConfigFactory": "com.netflix.client.config.ClientConfigFactory",
      "DefaultResourceFactory": "com.netflix.ribbon.DefaultResourceFactory",
      "RibbonResourceFactory": "com.netflix.ribbon.RibbonResourceFactory",
      "RibbonTransportFactory": "com.netflix.ribbon.RibbonTransportFactory",
      "DefaultRibbonTransportFactory": "com.netflix.ribbon.RibbonTransportFactory.DefaultRibbonTransportFactory",
      "AnnotationProcessorsProvider": "com.netflix.ribbon.proxy.processor.AnnotationProcessorsProvider",
      "DefaultAnnotationProcessorsProvider": "com.netflix.ribbon.proxy.processor.AnnotationProcessorsProvider.DefaultAnnotationProcessorsProvider"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-guice\\src\\main\\java\\com\\netflix\\ribbon\\guice\\RibbonResourceProvider.java": {
    "TypeDeclarations": [
      "RibbonResourceProvider"
    ],
    "MethodDeclarations": [
      "RibbonResourceProvider.get()",
      "RibbonResourceProvider.acceptExtensionVisitor(BindingTargetVisitor, ProviderInstanceBinding)",
      "RibbonResourceProvider.initialize(RibbonResourceFactory)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "com.netflix.ribbon.RibbonResourceFactory.from"
      ]
    },
    "Imports": {
      "Inject": "com.google.inject.Inject",
      "BindingTargetVisitor": "com.google.inject.spi.BindingTargetVisitor",
      "ProviderInstanceBinding": "com.google.inject.spi.ProviderInstanceBinding",
      "ProviderWithExtensionVisitor": "com.google.inject.spi.ProviderWithExtensionVisitor",
      "Toolable": "com.google.inject.spi.Toolable",
      "RibbonResourceFactory": "com.netflix.ribbon.RibbonResourceFactory"
    },
    "FieldTypes": {
      "factory": "com.netflix.ribbon.RibbonResourceFactory"
    }
  },
  "ribbon\\ribbon-guice\\src\\test\\java\\com\\netflix\\ribbon\\examples\\rx\\RibbonModuleTest.java": {
    "TypeDeclarations": [
      "RibbonModuleTest",
      "MyService"
    ],
    "MethodDeclarations": [
      "MyService.triggerMoviesRegistration()",
      "MyService.triggerRecommendationsUpdate()",
      "MyService.triggerRecommendationsSearch()",
      "RibbonModuleTest.shouldBind()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "withMaxAutoRetriesNextServer",
        "withConfigurationBasedServerList",
        "com.netflix.ribbon.http.HttpResourceGroup.newTemplateBuilder",
        "withMethod",
        "withUriTemplate",
        "withHeader",
        "withHeader",
        "withResponseValidator",
        "build",
        "com.netflix.ribbon.http.HttpResourceGroup.newTemplateBuilder",
        "withMethod",
        "withUriTemplate",
        "withHeader",
        "withHeader",
        "withResponseValidator",
        "build",
        "com.netflix.ribbon.http.HttpResourceGroup.newTemplateBuilder",
        "withMethod",
        "withUriTemplate",
        "withHeader",
        "withHeader",
        "withFallbackProvider",
        "withResponseValidator",
        "build",
        "com.netflix.ribbon.http.HttpResourceGroup.newTemplateBuilder",
        "withMethod",
        "withUriTemplate",
        "withHeader",
        "withHeader",
        "withFallbackProvider",
        "withResponseValidator",
        "build",
        "com.netflix.ribbon.http.HttpRequestTemplate.requestBuilder",
        "withRawContentSource",
        "build",
        "toObservable",
        "com.netflix.ribbon.http.HttpRequestTemplate.requestBuilder",
        "withRawContentSource",
        "build",
        "toObservable",
        "com.netflix.ribbon.http.HttpRequestTemplate.requestBuilder",
        "withRawContentSource",
        "build",
        "toObservable",
        "com.netflix.ribbon.http.HttpRequestTemplate.requestBuilder",
        "withRawContentSource",
        "withRequestProperty",
        "build",
        "toObservable",
        "com.netflix.ribbon.http.HttpRequestTemplate.requestBuilder",
        "withRawContentSource",
        "withRequestProperty",
        "build",
        "toObservable",
        "com.netflix.ribbon.http.HttpRequestTemplate.requestBuilder",
        "withRequestProperty",
        "build",
        "toObservable",
        "com.netflix.ribbon.http.HttpRequestTemplate.requestBuilder",
        "withRequestProperty",
        "withRequestProperty",
        "build",
        "toObservable"
      ]
    },
    "Imports": {
      "Guice": "com.google.inject.Guice",
      "Injector": "com.google.inject.Injector",
      "ClientOptions": "com.netflix.ribbon.ClientOptions",
      "RibbonResourceFactory": "com.netflix.ribbon.RibbonResourceFactory",
      "Movie": "com.netflix.ribbon.examples.rx.common.Movie",
      "RecommendationServiceFallbackHandler": "com.netflix.ribbon.examples.rx.common.RecommendationServiceFallbackHandler",
      "RecommendationServiceResponseValidator": "com.netflix.ribbon.examples.rx.common.RecommendationServiceResponseValidator",
      "RxMovieTransformer": "com.netflix.ribbon.examples.rx.common.RxMovieTransformer",
      "RibbonModule": "com.netflix.ribbon.guice.RibbonModule",
      "HttpRequestTemplate": "com.netflix.ribbon.http.HttpRequestTemplate",
      "HttpResourceGroup": "com.netflix.ribbon.http.HttpResourceGroup",
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "StringTransformer": "io.reactivex.netty.channel.StringTransformer",
      "Test": "org.junit.Test",
      "Observable": "rx.Observable",
      "Inject": "javax.inject.Inject",
      "Singleton": "javax.inject.Singleton"
    },
    "FieldTypes": {
      "httpResourceGroup": "com.netflix.ribbon.http.HttpResourceGroup",
      "registerMovieTemplate": "com.netflix.ribbon.http.HttpRequestTemplate",
      "updateRecommendationTemplate": "com.netflix.ribbon.http.HttpRequestTemplate",
      "recommendationsByUserIdTemplate": "com.netflix.ribbon.http.HttpRequestTemplate",
      "recommendationsByTemplate": "com.netflix.ribbon.http.HttpRequestTemplate"
    }
  },
  "ribbon\\ribbon-guice\\src\\test\\java\\com\\netflix\\ribbon\\examples\\rx\\RxMovieClientTestBase.java": {
    "TypeDeclarations": [
      "RxMovieClientTestBase"
    ],
    "MethodDeclarations": [
      "RxMovieClientTestBase.setUp()",
      "RxMovieClientTestBase.tearDown()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "start",
        "io.reactivex.netty.protocol.http.server.HttpServer.getServerPort",
        "io.reactivex.netty.protocol.http.server.HttpServer.shutdown"
      ]
    },
    "Imports": {
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "HttpServer": "io.reactivex.netty.protocol.http.server.HttpServer",
      "After": "org.junit.After",
      "Before": "org.junit.Before"
    },
    "FieldTypes": {
      "httpServer": "io.reactivex.netty.protocol.http.server.HttpServer"
    }
  },
  "ribbon\\ribbon-guice\\src\\test\\java\\com\\netflix\\ribbon\\examples\\rx\\RxMovieProxyExampleTest.java": {
    "TypeDeclarations": [
      "RxMovieProxyExampleTest",
      "MyClientConfigFactory"
    ],
    "MethodDeclarations": [
      "MyClientConfigFactory.newConfig()",
      "RxMovieProxyExampleTest.shouldBind()",
      "RxMovieProxyExampleTest.shouldBindCustomClientConfigFactory()",
      "RxMovieProxyExampleTest.testTransportFactoryWithInjection()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "org.junit.Assert.assertTrue",
        "org.junit.Assert.assertTrue",
        "org.junit.Assert.assertEquals"
      ],
      "Unresolved": [
        "setProperty",
        "getSimpleName",
        "bind",
        "toProvider",
        "asEagerSingleton",
        "setProperty",
        "getSimpleName",
        "bind",
        "to",
        "in",
        "bind",
        "to",
        "in",
        "bind",
        "to",
        "in",
        "bind",
        "to",
        "in",
        "bind",
        "toProvider",
        "asEagerSingleton",
        "bind",
        "to",
        "in",
        "bind",
        "to",
        "in"
      ]
    },
    "Imports": {
      "AbstractModule": "com.google.inject.AbstractModule",
      "Guice": "com.google.inject.Guice",
      "Injector": "com.google.inject.Injector",
      "Scopes": "com.google.inject.Scopes",
      "ClientConfigFactory": "com.netflix.client.config.ClientConfigFactory",
      "DefaultClientConfigImpl": "com.netflix.client.config.DefaultClientConfigImpl",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "LoadBalancingHttpClient": "com.netflix.ribbon.transport.netty.http.LoadBalancingHttpClient",
      "ConfigurationManager": "com.netflix.config.ConfigurationManager",
      "DefaultResourceFactory": "com.netflix.ribbon.DefaultResourceFactory",
      "RibbonResourceFactory": "com.netflix.ribbon.RibbonResourceFactory",
      "RibbonTransportFactory": "com.netflix.ribbon.RibbonTransportFactory",
      "DefaultRibbonTransportFactory": "com.netflix.ribbon.RibbonTransportFactory.DefaultRibbonTransportFactory",
      "MovieService": "com.netflix.ribbon.examples.rx.proxy.MovieService",
      "RxMovieProxyExample": "com.netflix.ribbon.examples.rx.proxy.RxMovieProxyExample",
      "RibbonModule": "com.netflix.ribbon.guice.RibbonModule",
      "RibbonResourceProvider": "com.netflix.ribbon.guice.RibbonResourceProvider",
      "AnnotationProcessorsProvider": "com.netflix.ribbon.proxy.processor.AnnotationProcessorsProvider",
      "DefaultAnnotationProcessorsProvider": "com.netflix.ribbon.proxy.processor.AnnotationProcessorsProvider.DefaultAnnotationProcessorsProvider",
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "HttpClient": "io.reactivex.netty.protocol.http.client.HttpClient",
      "Test": "org.junit.Test",
      "assertEquals": "org.junit.Assert.assertEquals",
      "assertTrue": "org.junit.Assert.assertTrue"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-guice\\src\\test\\java\\com\\netflix\\ribbon\\examples\\rx\\proxy\\RxMovieProxyExample.java": {
    "TypeDeclarations": [
      "RxMovieProxyExample"
    ],
    "MethodDeclarations": [
      "RxMovieProxyExample.triggerMoviesRegistration()",
      "RxMovieProxyExample.triggerRecommendationsUpdate()",
      "RxMovieProxyExample.triggerRecommendationsSearch()",
      "RxMovieProxyExample.shutdown()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "com.netflix.ribbon.examples.rx.proxy.MovieService.registerMovie",
        "toObservable",
        "com.netflix.ribbon.examples.rx.proxy.MovieService.registerMovie",
        "toObservable",
        "com.netflix.ribbon.examples.rx.proxy.MovieService.registerMovie",
        "toObservable",
        "com.netflix.ribbon.examples.rx.proxy.MovieService.updateRecommendations",
        "toObservable",
        "com.netflix.ribbon.examples.rx.proxy.MovieService.updateRecommendations",
        "toObservable",
        "com.netflix.ribbon.examples.rx.proxy.MovieService.recommendationsByUserId",
        "toObservable",
        "com.netflix.ribbon.examples.rx.proxy.MovieService.recommendationsBy",
        "toObservable"
      ]
    },
    "Imports": {
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "Inject": "javax.inject.Inject",
      "Observable": "rx.Observable",
      "Singleton": "com.google.inject.Singleton",
      "AbstractRxMovieClient": "com.netflix.ribbon.examples.rx.AbstractRxMovieClient",
      "Movie": "com.netflix.ribbon.examples.rx.common.Movie",
      "MovieService": "com.netflix.ribbon.examples.rx.proxy.MovieService",
      "ProxyLifeCycle": "com.netflix.ribbon.proxy.ProxyLifeCycle"
    },
    "FieldTypes": {
      "movieService": "com.netflix.ribbon.examples.rx.proxy.MovieService"
    }
  },
  "ribbon\\ribbon-httpclient\\src\\main\\java\\com\\netflix\\client\\http\\CaseInsensitiveMultiMap.java": {
    "TypeDeclarations": [
      "CaseInsensitiveMultiMap"
    ],
    "MethodDeclarations": [
      "CaseInsensitiveMultiMap.getFirstValue(String)",
      "CaseInsensitiveMultiMap.getAllValues(String)",
      "CaseInsensitiveMultiMap.getAllHeaders()",
      "CaseInsensitiveMultiMap.containsHeader(String)",
      "CaseInsensitiveMultiMap.addHeader(String, String)",
      "CaseInsensitiveMultiMap.asMap()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "CaseInsensitiveMultiMap.getAllValues"
      ],
      "Unresolved": [
        "com.google.common.collect.Multimap.get",
        "next",
        "getValue",
        "com.google.common.collect.Multimap.get",
        "com.google.common.collect.Multimap.values",
        "com.google.common.collect.Multimap.containsKey",
        "contains",
        "com.google.common.collect.Multimap.put",
        "com.google.common.collect.Multimap.values"
      ]
    },
    "Imports": {
      "ArrayList": "java.util.ArrayList",
      "Collection": "java.util.Collection",
      "List": "java.util.List",
      "Map": "java.util.Map",
      "Entry": "java.util.Map.Entry",
      "SimpleEntry": "java.util.AbstractMap.SimpleEntry",
      "ArrayListMultimap": "com.google.common.collect.ArrayListMultimap",
      "Lists": "com.google.common.collect.Lists",
      "Multimap": "com.google.common.collect.Multimap"
    },
    "FieldTypes": {
      "map": "com.google.common.collect.Multimap"
    }
  },
  "ribbon\\ribbon-httpclient\\src\\main\\java\\com\\netflix\\client\\http\\HttpHeaders.java": {
    "TypeDeclarations": [
      "HttpHeaders"
    ],
    "MethodDeclarations": [
      "HttpHeaders.getFirstValue(String)",
      "HttpHeaders.getAllValues(String)",
      "HttpHeaders.getAllHeaders()",
      "HttpHeaders.containsHeader(String)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "List": "java.util.List",
      "Entry": "java.util.Map.Entry"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-httpclient\\src\\main\\java\\com\\netflix\\client\\http\\HttpRequest.java": {
    "TypeDeclarations": [
      "HttpRequest",
      "Verb",
      "Builder"
    ],
    "MethodDeclarations": [
      "Verb.verb()",
      "Builder.uri(URI)",
      "Builder.uri(String)",
      "Builder.header(String, String)",
      "Builder.queryParams(Multimap)",
      "Builder.overrideConfig(IClientConfig)",
      "Builder.headers(CaseInsensitiveMultiMap)",
      "Builder.setRetriable(BasicType(dimensions=[], name=boolean))",
      "Builder.queryParams(String, String)",
      "Builder.queryParam(String, String)",
      "Builder.entity(Object)",
      "Builder.verb(Verb)",
      "Builder.loadBalancerKey(Object)",
      "Builder.build()",
      "HttpRequest.getQueryParams()",
      "HttpRequest.getVerb()",
      "HttpRequest.getHeaders()",
      "HttpRequest.getHttpHeaders()",
      "HttpRequest.getEntity()",
      "HttpRequest.isRetriable()",
      "HttpRequest.newBuilder()",
      "HttpRequest.newBuilder(HttpRequest)",
      "HttpRequest.replaceUri(URI)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "Builder.uri",
        "Builder.headers",
        "Builder.overrideConfig",
        "Builder.queryParams",
        "Builder.setRetriable",
        "Builder.loadBalancerKey",
        "Builder.verb",
        "Builder.entity",
        "Builder.build"
      ],
      "Unresolved": [
        "com.google.common.collect.Multimap.asMap",
        "getOverrideConfig",
        "isRetriable",
        "getLoadBalancerKey",
        "getVerb"
      ]
    },
    "Imports": {
      "URI": "java.net.URI",
      "URISyntaxException": "java.net.URISyntaxException",
      "Collection": "java.util.Collection",
      "Map": "java.util.Map",
      "ArrayListMultimap": "com.google.common.collect.ArrayListMultimap",
      "Multimap": "com.google.common.collect.Multimap",
      "ClientRequest": "com.netflix.client.ClientRequest",
      "IClientConfig": "com.netflix.client.config.IClientConfig"
    },
    "FieldTypes": {
      "queryParams": "com.google.common.collect.Multimap"
    }
  },
  "ribbon\\ribbon-httpclient\\src\\main\\java\\com\\netflix\\client\\http\\HttpResponse.java": {
    "TypeDeclarations": [
      "HttpResponse"
    ],
    "MethodDeclarations": [
      "HttpResponse.getStatus()",
      "HttpResponse.getStatusLine()",
      "HttpResponse.getHeaders()",
      "HttpResponse.getHttpHeaders()",
      "HttpResponse.close()",
      "HttpResponse.getInputStream()",
      "HttpResponse.hasEntity()",
      "HttpResponse.getEntity(Class)",
      "HttpResponse.getEntity(Type)",
      "HttpResponse.getEntity(TypeToken)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "TypeToken": "com.google.common.reflect.TypeToken",
      "IResponse": "com.netflix.client.IResponse",
      "Closeable": "java.io.Closeable",
      "InputStream": "java.io.InputStream",
      "Type": "java.lang.reflect.Type",
      "Collection": "java.util.Collection",
      "Map": "java.util.Map"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-httpclient\\src\\main\\java\\com\\netflix\\http4\\ConnectionPoolCleaner.java": {
    "TypeDeclarations": [
      "ConnectionPoolCleaner"
    ],
    "MethodDeclarations": [
      "ConnectionPoolCleaner.getConnIdleEvictTimeMilliSeconds()",
      "ConnectionPoolCleaner.setConnIdleEvictTimeMilliSeconds(Property)",
      "ConnectionPoolCleaner.isEnableConnectionPoolCleanerTask()",
      "ConnectionPoolCleaner.setEnableConnectionPoolCleanerTask(BasicType(dimensions=[], name=boolean))",
      "ConnectionPoolCleaner.getConnectionCleanerTimerDelay()",
      "ConnectionPoolCleaner.setConnectionCleanerTimerDelay(BasicType(dimensions=[], name=long))",
      "ConnectionPoolCleaner.getConnectionCleanerRepeatInterval()",
      "ConnectionPoolCleaner.setConnectionCleanerRepeatInterval(BasicType(dimensions=[], name=long))",
      "ConnectionPoolCleaner.initTask()",
      "ConnectionPoolCleaner.cleanupConnections()",
      "ConnectionPoolCleaner.shutdown()",
      "ConnectionPoolCleaner.toString()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "ConnectionPoolCleaner.cleanupConnections"
      ],
      "Unresolved": [
        "java.util.concurrent.ScheduledExecutorService.scheduleWithFixedDelay",
        "org.slf4j.Logger.debug",
        "java.util.concurrent.ScheduledFuture.cancel",
        "org.slf4j.Logger.error",
        "org.slf4j.Logger.info",
        "org.apache.http.conn.ClientConnectionManager.closeExpiredConnections",
        "org.apache.http.conn.ClientConnectionManager.closeIdleConnections",
        "com.netflix.client.config.Property.getOrDefault",
        "java.util.concurrent.ScheduledFuture.cancel",
        "com.netflix.client.config.Property.get"
      ]
    },
    "Imports": {
      "Property": "com.netflix.client.config.Property",
      "ClientConnectionManager": "org.apache.http.conn.ClientConnectionManager",
      "Logger": "org.slf4j.Logger",
      "LoggerFactory": "org.slf4j.LoggerFactory",
      "ScheduledExecutorService": "java.util.concurrent.ScheduledExecutorService",
      "ScheduledFuture": "java.util.concurrent.ScheduledFuture",
      "TimeUnit": "java.util.concurrent.TimeUnit"
    },
    "FieldTypes": {
      "logger": "org.slf4j.Logger",
      "connMgr": "org.apache.http.conn.ClientConnectionManager",
      "scheduler": "java.util.concurrent.ScheduledExecutorService",
      "connIdleEvictTimeMilliSeconds": "com.netflix.client.config.Property",
      "scheduledFuture": "java.util.concurrent.ScheduledFuture"
    }
  },
  "ribbon\\ribbon-httpclient\\src\\main\\java\\com\\netflix\\http4\\MonitoredConnectionManager.java": {
    "TypeDeclarations": [
      "MonitoredConnectionManager"
    ],
    "MethodDeclarations": [
      "MonitoredConnectionManager.initMonitors(String)",
      "MonitoredConnectionManager.createConnectionPool(HttpParams)",
      "MonitoredConnectionManager.createConnectionPool(BasicType(dimensions=[], name=long), TimeUnit)",
      "MonitoredConnectionManager.getConnectionPool()",
      "MonitoredConnectionManager.requestConnection(HttpRoute, Object)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "MonitoredConnectionManager.initMonitors",
        "MonitoredConnectionManager.initMonitors",
        "MonitoredConnectionManager.initMonitors"
      ],
      "Unresolved": []
    },
    "Imports": {
      "TimeUnit": "java.util.concurrent.TimeUnit",
      "ClientConnectionRequest": "org.apache.http.conn.ClientConnectionRequest",
      "HttpRoute": "org.apache.http.conn.routing.HttpRoute",
      "SchemeRegistry": "org.apache.http.conn.scheme.SchemeRegistry",
      "AbstractConnPool": "org.apache.http.impl.conn.tsccm.AbstractConnPool",
      "ConnPoolByRoute": "org.apache.http.impl.conn.tsccm.ConnPoolByRoute",
      "ThreadSafeClientConnManager": "org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager",
      "HttpParams": "org.apache.http.params.HttpParams",
      "VisibleForTesting": "com.google.common.annotations.VisibleForTesting"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-httpclient\\src\\main\\java\\com\\netflix\\http4\\NamedConnectionPool.java": {
    "TypeDeclarations": [
      "NamedConnectionPool"
    ],
    "MethodDeclarations": [
      "NamedConnectionPool.initMonitors(String)",
      "NamedConnectionPool.requestPoolEntry(HttpRoute, Object)",
      "NamedConnectionPool.getFreeEntry(RouteSpecificPool, Object)",
      "NamedConnectionPool.createEntry(RouteSpecificPool, ClientConnectionOperator)",
      "NamedConnectionPool.getEntryBlocking(HttpRoute, Object, BasicType(dimensions=[], name=long), TimeUnit, WaitingThreadAborter)",
      "NamedConnectionPool.freeEntry(BasicPoolEntry, BasicType(dimensions=[], name=boolean), BasicType(dimensions=[], name=long), TimeUnit)",
      "NamedConnectionPool.deleteEntry(BasicPoolEntry)",
      "NamedConnectionPool.getFreeEntryCount()",
      "NamedConnectionPool.getCreatedEntryCount()",
      "NamedConnectionPool.getRequestsCount()",
      "NamedConnectionPool.getReleaseCount()",
      "NamedConnectionPool.getDeleteCount()",
      "NamedConnectionPool.getConnectionCount()",
      "NamedConnectionPool.shutdown()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "NamedConnectionPool.initMonitors",
        "NamedConnectionPool.initMonitors",
        "NamedConnectionPool.initMonitors"
      ],
      "Unresolved": [
        "com.netflix.servo.monitor.Counter.increment",
        "com.netflix.servo.monitor.Counter.increment",
        "com.netflix.servo.monitor.Counter.increment",
        "com.netflix.servo.monitor.Timer.start",
        "com.netflix.servo.monitor.Timer.start",
        "com.netflix.servo.monitor.Counter.increment",
        "com.netflix.servo.monitor.Counter.increment",
        "com.netflix.servo.monitor.Counter.getValue",
        "longValue",
        "com.netflix.servo.monitor.Counter.getValue",
        "longValue",
        "com.netflix.servo.monitor.Counter.getValue",
        "longValue",
        "com.netflix.servo.monitor.Counter.getValue",
        "longValue",
        "com.netflix.servo.monitor.Counter.getValue",
        "longValue",
        "getConnectionsInPool"
      ]
    },
    "Imports": {
      "TimeUnit": "java.util.concurrent.TimeUnit",
      "ClientConnectionOperator": "org.apache.http.conn.ClientConnectionOperator",
      "ConnectionPoolTimeoutException": "org.apache.http.conn.ConnectionPoolTimeoutException",
      "ConnPerRoute": "org.apache.http.conn.params.ConnPerRoute",
      "HttpRoute": "org.apache.http.conn.routing.HttpRoute",
      "BasicPoolEntry": "org.apache.http.impl.conn.tsccm.BasicPoolEntry",
      "ConnPoolByRoute": "org.apache.http.impl.conn.tsccm.ConnPoolByRoute",
      "PoolEntryRequest": "org.apache.http.impl.conn.tsccm.PoolEntryRequest",
      "RouteSpecificPool": "org.apache.http.impl.conn.tsccm.RouteSpecificPool",
      "WaitingThreadAborter": "org.apache.http.impl.conn.tsccm.WaitingThreadAborter",
      "HttpParams": "org.apache.http.params.HttpParams",
      "Preconditions": "com.google.common.base.Preconditions",
      "DataSourceType": "com.netflix.servo.annotations.DataSourceType",
      "Monitor": "com.netflix.servo.annotations.Monitor",
      "Counter": "com.netflix.servo.monitor.Counter",
      "Monitors": "com.netflix.servo.monitor.Monitors",
      "Stopwatch": "com.netflix.servo.monitor.Stopwatch",
      "Timer": "com.netflix.servo.monitor.Timer"
    },
    "FieldTypes": {
      "freeEntryCounter": "com.netflix.servo.monitor.Counter",
      "createEntryCounter": "com.netflix.servo.monitor.Counter",
      "requestCounter": "com.netflix.servo.monitor.Counter",
      "releaseCounter": "com.netflix.servo.monitor.Counter",
      "deleteCounter": "com.netflix.servo.monitor.Counter",
      "requestTimer": "com.netflix.servo.monitor.Timer",
      "creationTimer": "com.netflix.servo.monitor.Timer"
    }
  },
  "ribbon\\ribbon-httpclient\\src\\main\\java\\com\\netflix\\http4\\NFHttpClient.java": {
    "TypeDeclarations": [
      "NFHttpClient"
    ],
    "MethodDeclarations": [
      "NFHttpClient.createDefaultConfig()",
      "NFHttpClient.init(IClientConfig, BasicType(dimensions=[], name=boolean))",
      "NFHttpClient.initConnectionCleanerTask()",
      "NFHttpClient.getConnPoolCleaner()",
      "NFHttpClient.getConnIdleEvictTimeMilliSeconds()",
      "NFHttpClient.getConnectionsInPool()",
      "NFHttpClient.getMaxTotalConnnections()",
      "NFHttpClient.getMaxConnectionsPerHost()",
      "NFHttpClient.getNumRetries()",
      "NFHttpClient.setConnIdleEvictTimeMilliSeconds(Property)",
      "NFHttpClient.getSleepTimeFactorMs()",
      "NFHttpClient.determineTarget(HttpUriRequest)",
      "NFHttpClient.execute(HttpUriRequest, ResponseHandler)",
      "NFHttpClient.execute(HttpUriRequest, ResponseHandler, HttpContext)",
      "NFHttpClient.execute(HttpHost, HttpRequest, ResponseHandler)",
      "NFHttpClient.execute(HttpHost, HttpRequest, ResponseHandler, HttpContext)",
      "NFHttpClient.shutdown()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "NFHttpClient.init",
        "NFHttpClient.createDefaultConfig",
        "NFHttpClient.init",
        "NFHttpClient.createDefaultConfig",
        "NFHttpClient.createDefaultConfig",
        "NFHttpClient.init",
        "NFHttpClient.getConnIdleEvictTimeMilliSeconds",
        "NFHttpClient.execute",
        "NFHttpClient.determineTarget",
        "NFHttpClient.execute",
        "NFHttpClient.execute",
        "NFHttpClient.shutdown"
      ],
      "Unresolved": [
        "setDaemon",
        "setNameFormat",
        "build",
        "java.util.concurrent.atomic.AtomicInteger.incrementAndGet",
        "java.util.concurrent.atomic.AtomicInteger.incrementAndGet",
        "getParams",
        "getName",
        "getConnectionManager",
        "com.netflix.client.config.IClientConfigKey.format",
        "com.netflix.client.config.IClientConfigKey.format",
        "setHttpRequestRetryHandler",
        "getOrDefault",
        "getOrDefault",
        "com.netflix.client.config.Property.onChange",
        "getConnectionManager",
        "com.netflix.client.config.Property.onChange",
        "getConnectionManager",
        "com.netflix.client.config.IClientConfigKey.format",
        "getConnectionManager",
        "getConnectionManager",
        "getConnectionManager",
        "getOrDefault",
        "getOrDefault",
        "com.netflix.servo.monitor.Timer.start",
        "org.slf4j.Logger.debug",
        "getMethod",
        "getUri",
        "getConnectionManager"
      ]
    },
    "Imports": {
      "ThreadFactoryBuilder": "com.google.common.util.concurrent.ThreadFactoryBuilder",
      "ClientConfigFactory": "com.netflix.client.config.ClientConfigFactory",
      "CommonClientConfigKey": "com.netflix.client.config.CommonClientConfigKey",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "IClientConfigKey": "com.netflix.client.config.IClientConfigKey",
      "Property": "com.netflix.client.config.Property",
      "DataSourceType": "com.netflix.servo.annotations.DataSourceType",
      "Monitor": "com.netflix.servo.annotations.Monitor",
      "Monitors": "com.netflix.servo.monitor.Monitors",
      "Stopwatch": "com.netflix.servo.monitor.Stopwatch",
      "Timer": "com.netflix.servo.monitor.Timer",
      "Header": "org.apache.http.Header",
      "HttpHost": "org.apache.http.HttpHost",
      "HttpRequest": "org.apache.http.HttpRequest",
      "ClientProtocolException": "org.apache.http.client.ClientProtocolException",
      "ResponseHandler": "org.apache.http.client.ResponseHandler",
      "HttpUriRequest": "org.apache.http.client.methods.HttpUriRequest",
      "ClientPNames": "org.apache.http.client.params.ClientPNames",
      "HttpClientParams": "org.apache.http.client.params.HttpClientParams",
      "URIUtils": "org.apache.http.client.utils.URIUtils",
      "ClientConnectionManager": "org.apache.http.conn.ClientConnectionManager",
      "HttpRoute": "org.apache.http.conn.routing.HttpRoute",
      "DefaultHttpClient": "org.apache.http.impl.client.DefaultHttpClient",
      "ThreadSafeClientConnManager": "org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager",
      "BasicHeader": "org.apache.http.message.BasicHeader",
      "HttpParams": "org.apache.http.params.HttpParams",
      "HttpProtocolParams": "org.apache.http.params.HttpProtocolParams",
      "HttpContext": "org.apache.http.protocol.HttpContext",
      "Logger": "org.slf4j.Logger",
      "LoggerFactory": "org.slf4j.LoggerFactory",
      "IOException": "java.io.IOException",
      "URI": "java.net.URI",
      "ArrayList": "java.util.ArrayList",
      "List": "java.util.List",
      "Executors": "java.util.concurrent.Executors",
      "ScheduledExecutorService": "java.util.concurrent.ScheduledExecutorService",
      "ThreadFactory": "java.util.concurrent.ThreadFactory",
      "TimeUnit": "java.util.concurrent.TimeUnit",
      "AtomicInteger": "java.util.concurrent.atomic.AtomicInteger"
    },
    "FieldTypes": {
      "LOGGER": "org.slf4j.Logger",
      "RETRIES": "com.netflix.client.config.IClientConfigKey",
      "SLEEP_TIME_FACTOR_MS": "com.netflix.client.config.IClientConfigKey",
      "CONN_IDLE_EVICT_TIME_MILLIS": "com.netflix.client.config.IClientConfigKey",
      "connectionPoolCleanUpScheduler": "java.util.concurrent.ScheduledExecutorService",
      "httpHost": "org.apache.http.HttpHost",
      "httpRoute": "org.apache.http.conn.routing.HttpRoute",
      "numNonNamedHttpClients": "java.util.concurrent.atomic.AtomicInteger",
      "connIdleEvictTimeMilliSeconds": "com.netflix.client.config.Property",
      "retriesProperty": "com.netflix.client.config.Property",
      "sleepTimeFactorMsProperty": "com.netflix.client.config.Property",
      "tracer": "com.netflix.servo.monitor.Timer",
      "maxTotalConnectionProperty": "com.netflix.client.config.Property",
      "maxConnectionPerHostProperty": "com.netflix.client.config.Property"
    }
  },
  "ribbon\\ribbon-httpclient\\src\\main\\java\\com\\netflix\\http4\\NFHttpClientFactory.java": {
    "TypeDeclarations": [
      "NFHttpClientFactory"
    ],
    "MethodDeclarations": [
      "NFHttpClientFactory.getNFHttpClient(String, BasicType(dimensions=[], name=int))",
      "NFHttpClientFactory.getNamedNFHttpClient(String)",
      "NFHttpClientFactory.getNamedNFHttpClient(String, IClientConfig)",
      "NFHttpClientFactory.getNamedNFHttpClient(String, BasicType(dimensions=[], name=boolean))",
      "NFHttpClientFactory.getNamedNFHttpClient(String, IClientConfig, BasicType(dimensions=[], name=boolean))",
      "NFHttpClientFactory.getDefaultClient()",
      "NFHttpClientFactory.setDefaultClient(NFHttpClient)",
      "NFHttpClientFactory.shutdownNFHttpClient(String)"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.util.Map.get",
        "java.util.Map.put",
        "java.util.Map.get",
        "java.util.Map.get",
        "java.util.Map.put",
        "java.util.Map.get",
        "java.util.Map.remove"
      ],
      "UserDefined": [
        "NFHttpClientFactory.getNamedNFHttpClient",
        "NFHttpClientFactory.getNamedNFHttpClient",
        "NFHttpClientFactory.getNamedNFHttpClient"
      ],
      "Unresolved": []
    },
    "Imports": {
      "Map": "java.util.Map",
      "ConcurrentHashMap": "java.util.concurrent.ConcurrentHashMap",
      "ClientConfigFactory": "com.netflix.client.config.ClientConfigFactory",
      "MultiKey": "org.apache.commons.collections.keyvalue.MultiKey",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "Monitors": "com.netflix.servo.monitor.Monitors"
    },
    "FieldTypes": {
      "clientMap": "java.util.Map",
      "namedClientMap": "java.util.Map"
    }
  },
  "ribbon\\ribbon-httpclient\\src\\main\\java\\com\\netflix\\http4\\NFHttpMethodRetryHandler.java": {
    "TypeDeclarations": [
      "NFHttpMethodRetryHandler"
    ],
    "MethodDeclarations": [
      "NFHttpMethodRetryHandler.retryRequest(IOException, BasicType(dimensions=[], name=int), HttpContext)"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.lang.toString"
      ],
      "UserDefined": [],
      "Unresolved": [
        "getMethod",
        "org.slf4j.Logger.warn"
      ]
    },
    "Imports": {
      "IOException": "java.io.IOException",
      "HttpRequest": "org.apache.http.HttpRequest",
      "HttpUriRequest": "org.apache.http.client.methods.HttpUriRequest",
      "DefaultHttpRequestRetryHandler": "org.apache.http.impl.client.DefaultHttpRequestRetryHandler",
      "ExecutionContext": "org.apache.http.protocol.ExecutionContext",
      "HttpContext": "org.apache.http.protocol.HttpContext",
      "Logger": "org.slf4j.Logger",
      "LoggerFactory": "org.slf4j.LoggerFactory",
      "DynamicCounter": "com.netflix.servo.monitor.DynamicCounter"
    },
    "FieldTypes": {
      "logger": "org.slf4j.Logger"
    }
  },
  "ribbon\\ribbon-httpclient\\src\\main\\java\\com\\netflix\\http4\\ssl\\AcceptAllSocketFactory.java": {
    "TypeDeclarations": [
      "AcceptAllSocketFactory"
    ],
    "MethodDeclarations": [
      "AcceptAllSocketFactory.initWithNiwsConfig(IClientConfig)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "IClientConfigAware": "com.netflix.client.IClientConfigAware",
      "CommonClientConfigKey": "com.netflix.client.config.CommonClientConfigKey",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "SSLSocketFactory": "org.apache.http.conn.ssl.SSLSocketFactory",
      "TrustStrategy": "org.apache.http.conn.ssl.TrustStrategy",
      "KeyManagementException": "java.security.KeyManagementException",
      "KeyStoreException": "java.security.KeyStoreException",
      "NoSuchAlgorithmException": "java.security.NoSuchAlgorithmException",
      "UnrecoverableKeyException": "java.security.UnrecoverableKeyException",
      "CertificateException": "java.security.cert.CertificateException",
      "X509Certificate": "java.security.cert.X509Certificate"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-httpclient\\src\\main\\java\\com\\netflix\\http4\\ssl\\KeyStoreAwareSocketFactory.java": {
    "TypeDeclarations": [
      "KeyStoreAwareSocketFactory"
    ],
    "MethodDeclarations": [
      "KeyStoreAwareSocketFactory.getKeyStore()",
      "KeyStoreAwareSocketFactory.getTrustStore()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "KeyStore": "java.security.KeyStore",
      "KeyStoreException": "java.security.KeyStoreException",
      "NoSuchAlgorithmException": "java.security.NoSuchAlgorithmException",
      "SSLContext": "javax.net.ssl.SSLContext",
      "SSLSocketFactory": "org.apache.http.conn.ssl.SSLSocketFactory",
      "X509HostnameVerifier": "org.apache.http.conn.ssl.X509HostnameVerifier",
      "AbstractSslContextFactory": "com.netflix.client.ssl.AbstractSslContextFactory",
      "ClientSslSocketFactoryException": "com.netflix.client.ssl.ClientSslSocketFactoryException"
    },
    "FieldTypes": {
      "keyStore": "java.security.KeyStore",
      "trustStore": "java.security.KeyStore"
    }
  },
  "ribbon\\ribbon-httpclient\\src\\main\\java\\com\\netflix\\loadbalancer\\PingUrl.java": {
    "TypeDeclarations": [
      "PingUrl"
    ],
    "MethodDeclarations": [
      "PingUrl.setPingAppendString(String)",
      "PingUrl.getPingAppendString()",
      "PingUrl.isSecure()",
      "PingUrl.setSecure(BasicType(dimensions=[], name=boolean))",
      "PingUrl.getExpectedContent()",
      "PingUrl.setExpectedContent(String)",
      "PingUrl.isAlive(Server)",
      "PingUrl.main(String)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "PingUrl.getPingAppendString",
        "PingUrl.getExpectedContent",
        "PingUrl.getExpectedContent"
      ],
      "Unresolved": [
        "getStatusCode",
        "org.slf4j.Logger.debug"
      ]
    },
    "Imports": {
      "HttpResponse": "org.apache.http.HttpResponse",
      "HttpClient": "org.apache.http.client.HttpClient",
      "HttpGet": "org.apache.http.client.methods.HttpGet",
      "HttpUriRequest": "org.apache.http.client.methods.HttpUriRequest",
      "DefaultHttpClient": "org.apache.http.impl.client.DefaultHttpClient",
      "EntityUtils": "org.apache.http.util.EntityUtils",
      "Logger": "org.slf4j.Logger",
      "LoggerFactory": "org.slf4j.LoggerFactory",
      "IOException": "java.io.IOException"
    },
    "FieldTypes": {
      "LOGGER": "org.slf4j.Logger"
    }
  },
  "ribbon\\ribbon-httpclient\\src\\main\\java\\com\\netflix\\niws\\client\\http\\HttpClientLoadBalancerErrorHandler.java": {
    "TypeDeclarations": [
      "HttpClientLoadBalancerErrorHandler"
    ],
    "MethodDeclarations": [
      "HttpClientLoadBalancerErrorHandler.isCircuitTrippingException(Throwable)",
      "HttpClientLoadBalancerErrorHandler.isRetriableException(Throwable, BasicType(dimensions=[], name=boolean))",
      "HttpClientLoadBalancerErrorHandler.getRetriableExceptions()",
      "HttpClientLoadBalancerErrorHandler.getCircuitRelatedExceptions()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "com.google.common.collect.Lists",
        "com.google.common.collect.Lists"
      ],
      "Unresolved": []
    },
    "Imports": {
      "ConnectException": "java.net.ConnectException",
      "SocketException": "java.net.SocketException",
      "SocketTimeoutException": "java.net.SocketTimeoutException",
      "List": "java.util.List",
      "ConnectionClosedException": "org.apache.http.ConnectionClosedException",
      "NoHttpResponseException": "org.apache.http.NoHttpResponseException",
      "ConnectTimeoutException": "org.apache.http.conn.ConnectTimeoutException",
      "ConnectionPoolTimeoutException": "org.apache.http.conn.ConnectionPoolTimeoutException",
      "HttpHostConnectException": "org.apache.http.conn.HttpHostConnectException",
      "Lists": "com.google.common.collect.Lists",
      "ClientException": "com.netflix.client.ClientException",
      "DefaultLoadBalancerRetryHandler": "com.netflix.client.DefaultLoadBalancerRetryHandler",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "HttpResponse": "com.netflix.client.http.HttpResponse"
    },
    "FieldTypes": {
      "retriable": "java.util.List",
      "circuitRelated": "java.util.List"
    }
  },
  "ribbon\\ribbon-httpclient\\src\\main\\java\\com\\netflix\\niws\\client\\http\\HttpClientRequest.java": {
    "TypeDeclarations": [
      "HttpClientRequest",
      "Verb",
      "Builder"
    ],
    "MethodDeclarations": [
      "Verb.verb()",
      "Builder.setUri(URI)",
      "Builder.setHeaders(MultivaluedMap)",
      "Builder.setOverrideConfig(IClientConfig)",
      "Builder.setRetriable(BasicType(dimensions=[], name=boolean))",
      "Builder.setQueryParams(MultivaluedMap)",
      "Builder.setEntity(Object)",
      "Builder.setVerb(Verb)",
      "Builder.setLoadBalancerKey(Object)",
      "Builder.build()",
      "HttpClientRequest.getQueryParams()",
      "HttpClientRequest.getVerb()",
      "HttpClientRequest.getHeaders()",
      "HttpClientRequest.getEntity()",
      "HttpClientRequest.isRetriable()",
      "HttpClientRequest.newBuilder()",
      "HttpClientRequest.replaceUri(URI)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "Builder.setUri",
        "Builder.setEntity",
        "Builder.setHeaders",
        "Builder.setOverrideConfig",
        "Builder.setQueryParams",
        "Builder.setRetriable",
        "Builder.setLoadBalancerKey",
        "Builder.setVerb",
        "Builder.build"
      ],
      "Unresolved": [
        "getEntity",
        "getHeaders",
        "getOverrideConfig",
        "getQueryParams",
        "isRetriable",
        "getLoadBalancerKey",
        "getVerb"
      ]
    },
    "Imports": {
      "URI": "java.net.URI",
      "MultivaluedMap": "javax.ws.rs.core.MultivaluedMap",
      "ClientRequest": "com.netflix.client.ClientRequest",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "HttpRequest": "com.netflix.client.http.HttpRequest"
    },
    "FieldTypes": {
      "headers": "javax.ws.rs.core.MultivaluedMap",
      "queryParams": "javax.ws.rs.core.MultivaluedMap"
    }
  },
  "ribbon\\ribbon-httpclient\\src\\main\\java\\com\\netflix\\niws\\client\\http\\HttpClientResponse.java": {
    "TypeDeclarations": [
      "HttpClientResponse"
    ],
    "MethodDeclarations": [
      "HttpClientResponse.getRawEntity()",
      "HttpClientResponse.getEntity(Class)",
      "HttpClientResponse.getHeaders()",
      "HttpClientResponse.getStatus()",
      "HttpClientResponse.isSuccess()",
      "HttpClientResponse.hasEntity()",
      "HttpClientResponse.getRequestedURI()",
      "HttpClientResponse.getPayload()",
      "HttpClientResponse.hasPayload()",
      "HttpClientResponse.getJerseyClientResponse()",
      "HttpClientResponse.close()",
      "HttpClientResponse.getInputStream()",
      "HttpClientResponse.getStatusLine()",
      "HttpClientResponse.getHttpHeaders()",
      "HttpClientResponse.getEntity(TypeToken)",
      "HttpClientResponse.getEntity(Type)"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.lang.toString"
      ],
      "UserDefined": [
        "com.google.common.collect.ArrayListMultimap",
        "HttpClientResponse.hasEntity",
        "HttpClientResponse.getRawEntity",
        "HttpClientResponse.hasEntity",
        "HttpClientResponse.getRawEntity"
      ],
      "Unresolved": [
        "com.sun.jersey.api.client.ClientResponse.getHeaders",
        "entrySet",
        "com.google.common.collect.Multimap.putAll",
        "com.sun.jersey.api.client.ClientResponse.getHeaders",
        "getFirst",
        "com.sun.jersey.api.client.ClientResponse.getHeaders",
        "get",
        "com.sun.jersey.api.client.ClientResponse.getHeaders",
        "com.sun.jersey.api.client.ClientResponse.getHeaders",
        "containsKey",
        "com.sun.jersey.api.client.ClientResponse.getEntityInputStream",
        "com.sun.jersey.api.client.ClientResponse.getEntity",
        "com.google.common.collect.Multimap.asMap",
        "com.sun.jersey.api.client.ClientResponse.getStatus",
        "com.sun.jersey.api.client.ClientResponse.getClientResponseStatus",
        "com.sun.jersey.api.client.ClientResponse.hasEntity",
        "com.sun.jersey.api.client.ClientResponse.close",
        "com.sun.jersey.api.client.ClientResponse.getClientResponseStatus",
        "com.sun.jersey.api.client.ClientResponse.getEntity",
        "com.sun.jersey.api.client.ClientResponse.getEntity"
      ]
    },
    "Imports": {
      "ArrayListMultimap": "com.google.common.collect.ArrayListMultimap",
      "Lists": "com.google.common.collect.Lists",
      "Multimap": "com.google.common.collect.Multimap",
      "TypeToken": "com.google.common.reflect.TypeToken",
      "ClientException": "com.netflix.client.ClientException",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "HttpHeaders": "com.netflix.client.http.HttpHeaders",
      "HttpResponse": "com.netflix.client.http.HttpResponse",
      "ClientResponse": "com.sun.jersey.api.client.ClientResponse",
      "GenericType": "com.sun.jersey.api.client.GenericType",
      "MultivaluedMap": "javax.ws.rs.core.MultivaluedMap",
      "InputStream": "java.io.InputStream",
      "Type": "java.lang.reflect.Type",
      "URI": "java.net.URI",
      "AbstractMap": "java.util.AbstractMap",
      "Collection": "java.util.Collection",
      "List": "java.util.List",
      "Map": "java.util.Map",
      "Entry": "java.util.Map.Entry"
    },
    "FieldTypes": {
      "bcr": "com.sun.jersey.api.client.ClientResponse",
      "headers": "com.google.common.collect.Multimap",
      "httpHeaders": "com.netflix.client.http.HttpHeaders",
      "requestedURI": "java.net.URI",
      "overrideConfig": "com.netflix.client.config.IClientConfig"
    }
  },
  "ribbon\\ribbon-httpclient\\src\\main\\java\\com\\netflix\\niws\\client\\http\\HttpPrimeConnection.java": {
    "TypeDeclarations": [
      "HttpPrimeConnection"
    ],
    "MethodDeclarations": [
      "HttpPrimeConnection.connect(Server, String)",
      "HttpPrimeConnection.initWithNiwsConfig(IClientConfig)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "org.slf4j.Logger.debug",
        "com.netflix.http4.NFHttpClient.execute",
        "org.slf4j.Logger.isDebugEnabled",
        "org.slf4j.Logger.debug",
        "getStatusCode",
        "com.netflix.http4.NFHttpClient.getParams"
      ]
    },
    "Imports": {
      "Logger": "org.slf4j.Logger",
      "LoggerFactory": "org.slf4j.LoggerFactory",
      "IPrimeConnection": "com.netflix.client.IPrimeConnection",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "NFHttpClient": "com.netflix.http4.NFHttpClient",
      "NFHttpClientFactory": "com.netflix.http4.NFHttpClientFactory",
      "Server": "com.netflix.loadbalancer.Server",
      "HttpResponse": "org.apache.http.HttpResponse",
      "HttpGet": "org.apache.http.client.methods.HttpGet",
      "HttpUriRequest": "org.apache.http.client.methods.HttpUriRequest",
      "HttpConnectionParams": "org.apache.http.params.HttpConnectionParams"
    },
    "FieldTypes": {
      "logger": "org.slf4j.Logger",
      "client": "com.netflix.http4.NFHttpClient"
    }
  },
  "ribbon\\ribbon-httpclient\\src\\main\\java\\com\\netflix\\niws\\client\\http\\RestClient.java": {
    "TypeDeclarations": [
      "RestClient"
    ],
    "MethodDeclarations": [
      "RestClient.initWithNiwsConfig(IClientConfig)",
      "RestClient.throwInvalidValue(IClientConfigKey, Exception)",
      "RestClient.apacheHttpClientSpecificInitialization()",
      "RestClient.resetSSLSocketFactory(AbstractSslContextFactory)",
      "RestClient.getKeyStore()",
      "RestClient.getResource(String)",
      "RestClient.getJerseyClient()",
      "RestClient.setJerseyClient(Client)",
      "RestClient.getResourceForOptionalProperty(IClientConfigKey)",
      "RestClient.execute(HttpRequest)",
      "RestClient.execute(HttpRequest, IClientConfig)",
      "RestClient.getDefaultPortFromScheme(String)",
      "RestClient.deriveSchemeAndPortFromPartialUri(URI)",
      "RestClient.execute(HttpRequest, URI, Map, Map, IClientConfig, Object)",
      "RestClient.isRetriableException(Throwable)",
      "RestClient.isCircuitBreakerException(Throwable)",
      "RestClient.isSocketException(Throwable)",
      "RestClient.isConnectException(Throwable)",
      "RestClient.deriveHostAndPortFromVipAddress(String)",
      "RestClient.getRequestSpecificRetryHandler(HttpRequest, IClientConfig)",
      "RestClient.shutdown()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "RestClient.initWithNiwsConfig",
        "RestClient.initWithNiwsConfig",
        "RestClient.apacheHttpClientSpecificInitialization",
        "RestClient.throwInvalidValue",
        "RestClient.throwInvalidValue",
        "RestClient.throwInvalidValue",
        "RestClient.throwInvalidValue",
        "RestClient.throwInvalidValue",
        "RestClient.throwInvalidValue",
        "RestClient.throwInvalidValue",
        "RestClient.throwInvalidValue",
        "RestClient.throwInvalidValue",
        "RestClient.throwInvalidValue",
        "RestClient.throwInvalidValue",
        "RestClient.throwInvalidValue",
        "RestClient.getResourceForOptionalProperty",
        "RestClient.getResourceForOptionalProperty",
        "RestClient.throwInvalidValue",
        "RestClient.getResource",
        "RestClient.getResource",
        "RestClient.getResource",
        "RestClient.execute",
        "RestClient.execute",
        "RestClient.isConnectException",
        "RestClient.isSocketException",
        "RestClient.isConnectException",
        "RestClient.isSocketException"
      ],
      "Unresolved": [
        "setRetryHandler",
        "com.netflix.client.config.IClientConfig.getClientName",
        "com.netflix.client.config.IClientConfig.get",
        "com.netflix.client.config.IClientConfig.get",
        "com.netflix.client.config.IClientConfig.get",
        "com.netflix.client.config.IClientConfig.get",
        "com.netflix.client.config.IClientConfig.get",
        "getProperties",
        "put",
        "com.netflix.client.config.IClientConfig.get",
        "getProperties",
        "put",
        "com.netflix.client.config.IClientConfig.get",
        "setRetryHandler",
        "org.slf4j.Logger.warn",
        "org.apache.http.client.HttpClient.getParams",
        "com.netflix.client.config.IClientConfig.getOrDefault",
        "setEnableConnectionPoolCleanerTask",
        "com.netflix.client.config.IClientConfig.getOrDefault",
        "setConnectionCleanerRepeatInterval",
        "com.netflix.client.config.IClientConfig.getDynamicProperty",
        "com.netflix.client.config.IClientConfig.getOrDefault",
        "org.apache.http.client.HttpClient.getConnectionManager",
        "com.netflix.client.config.IClientConfig.getOrDefault",
        "org.apache.http.client.HttpClient.getConnectionManager",
        "com.netflix.client.config.IClientConfig.getOrDefault",
        "com.netflix.client.config.IClientConfig.getOrDefault",
        "com.netflix.client.config.IClientConfig.get",
        "com.netflix.client.config.IClientConfig.getOrDefault",
        "com.netflix.client.config.IClientConfig.get",
        "com.netflix.client.config.IClientConfig.getOrDefault",
        "com.netflix.client.config.IClientConfig.get",
        "com.netflix.client.config.IClientConfig.getOrDefault",
        "com.netflix.client.config.IClientConfig.get",
        "com.netflix.client.config.IClientConfig.getOrDefault",
        "com.netflix.client.config.IClientConfig.get",
        "com.netflix.client.config.IClientConfig.getOrDefault",
        "com.netflix.client.config.IClientConfig.getOrDefault",
        "org.apache.http.client.HttpClient.getParams",
        "setParameter",
        "org.apache.http.client.HttpClient.getConnectionManager",
        "com.netflix.client.config.IClientConfig.get",
        "com.netflix.client.config.IClientConfig.get",
        "register",
        "com.netflix.client.config.IClientConfig.get",
        "org.apache.http.client.HttpClient.getConnectionManager",
        "getSchemeRegistry",
        "register",
        "org.apache.http.client.HttpClient.getConnectionManager",
        "getSchemeRegistry",
        "register",
        "org.apache.http.client.HttpClient.getConnectionManager",
        "getSchemeRegistry",
        "contains",
        "org.apache.http.client.HttpClient.getConnectionManager",
        "getSchemeRegistry",
        "getScheme",
        "getSchemeSocketFactory",
        "getName",
        "getContextClassLoader",
        "getClassLoader",
        "toURI",
        "toURL",
        "org.slf4j.Logger.error",
        "com.netflix.client.config.IClientConfig.get",
        "com.netflix.client.config.IClientConfig.get",
        "flatMap",
        "com.sun.jersey.client.apache4.config.ApacheHttpClient4Config.getIfSet",
        "orElse",
        "com.sun.jersey.api.client.Client.setFollowRedirects",
        "org.slf4j.Logger.isDebugEnabled",
        "org.slf4j.Logger.debug",
        "com.sun.jersey.api.client.Client.resource",
        "getRetryHandler",
        "get",
        "getRetryHandler",
        "getRetryHandler",
        "getRetryHandler",
        "getLoadBalancer"
      ]
    },
    "Imports": {
      "File": "java.io.File",
      "SocketException": "java.net.SocketException",
      "SocketTimeoutException": "java.net.SocketTimeoutException",
      "URI": "java.net.URI",
      "URISyntaxException": "java.net.URISyntaxException",
      "URL": "java.net.URL",
      "URLDecoder": "java.net.URLDecoder",
      "KeyStore": "java.security.KeyStore",
      "Collection": "java.util.Collection",
      "Map": "java.util.Map",
      "Optional": "java.util.Optional",
      "Property": "com.netflix.client.config.Property",
      "HttpHost": "org.apache.http.HttpHost",
      "HttpClient": "org.apache.http.client.HttpClient",
      "UserTokenHandler": "org.apache.http.client.UserTokenHandler",
      "ClientConnectionManager": "org.apache.http.conn.ClientConnectionManager",
      "ConnRouteParams": "org.apache.http.conn.params.ConnRouteParams",
      "Scheme": "org.apache.http.conn.scheme.Scheme",
      "SchemeRegistry": "org.apache.http.conn.scheme.SchemeRegistry",
      "SchemeSocketFactory": "org.apache.http.conn.scheme.SchemeSocketFactory",
      "SSLSocketFactory": "org.apache.http.conn.ssl.SSLSocketFactory",
      "AbstractHttpClient": "org.apache.http.impl.client.AbstractHttpClient",
      "BasicCookieStore": "org.apache.http.impl.client.BasicCookieStore",
      "DefaultHttpClient": "org.apache.http.impl.client.DefaultHttpClient",
      "ThreadSafeClientConnManager": "org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager",
      "HttpConnectionParams": "org.apache.http.params.HttpConnectionParams",
      "HttpParams": "org.apache.http.params.HttpParams",
      "HttpContext": "org.apache.http.protocol.HttpContext",
      "Logger": "org.slf4j.Logger",
      "LoggerFactory": "org.slf4j.LoggerFactory",
      "AbstractLoadBalancerAwareClient": "com.netflix.client.AbstractLoadBalancerAwareClient",
      "ClientException": "com.netflix.client.ClientException",
      "ClientFactory": "com.netflix.client.ClientFactory",
      "RequestSpecificRetryHandler": "com.netflix.client.RequestSpecificRetryHandler",
      "CommonClientConfigKey": "com.netflix.client.config.CommonClientConfigKey",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "IClientConfigKey": "com.netflix.client.config.IClientConfigKey",
      "HttpRequest": "com.netflix.client.http.HttpRequest",
      "HttpResponse": "com.netflix.client.http.HttpResponse",
      "AbstractSslContextFactory": "com.netflix.client.ssl.AbstractSslContextFactory",
      "ClientSslSocketFactoryException": "com.netflix.client.ssl.ClientSslSocketFactoryException",
      "URLSslContextFactory": "com.netflix.client.ssl.URLSslContextFactory",
      "NFHttpClient": "com.netflix.http4.NFHttpClient",
      "NFHttpClientFactory": "com.netflix.http4.NFHttpClientFactory",
      "NFHttpMethodRetryHandler": "com.netflix.http4.NFHttpMethodRetryHandler",
      "KeyStoreAwareSocketFactory": "com.netflix.http4.ssl.KeyStoreAwareSocketFactory",
      "BaseLoadBalancer": "com.netflix.loadbalancer.BaseLoadBalancer",
      "ILoadBalancer": "com.netflix.loadbalancer.ILoadBalancer",
      "Pair": "com.netflix.util.Pair",
      "Client": "com.sun.jersey.api.client.Client",
      "ClientResponse": "com.sun.jersey.api.client.ClientResponse",
      "WebResource": "com.sun.jersey.api.client.WebResource",
      "Builder": "com.sun.jersey.api.client.WebResource.Builder",
      "ApacheHttpClient4": "com.sun.jersey.client.apache4.ApacheHttpClient4",
      "ApacheHttpClient4Handler": "com.sun.jersey.client.apache4.ApacheHttpClient4Handler",
      "ApacheHttpClient4Config": "com.sun.jersey.client.apache4.config.ApacheHttpClient4Config",
      "DefaultApacheHttpClient4Config": "com.sun.jersey.client.apache4.config.DefaultApacheHttpClient4Config"
    },
    "FieldTypes": {
      "CONN_IDLE_EVICT_TIME_MILLIS": "com.netflix.client.config.IClientConfigKey",
      "restClient": "com.sun.jersey.api.client.Client",
      "httpClient4": "org.apache.http.client.HttpClient",
      "ncc": "com.netflix.client.config.IClientConfig",
      "connIdleEvictTimeMilliSeconds": "com.netflix.client.config.Property",
      "config": "com.sun.jersey.client.apache4.config.ApacheHttpClient4Config",
      "logger": "org.slf4j.Logger"
    }
  },
  "ribbon\\ribbon-httpclient\\src\\test\\java\\com\\netflix\\client\\ClientFactoryTest.java": {
    "TypeDeclarations": [
      "ClientFactoryTest"
    ],
    "MethodDeclarations": [
      "ClientFactoryTest.init()",
      "ClientFactoryTest.testChooseServers()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "org.junit.Assert.assertNotNull",
        "org.junit.Assert.assertTrue",
        "org.junit.Assert.assertEquals"
      ],
      "Unresolved": [
        "setProperty",
        "com.netflix.niws.client.http.RestClient.getLoadBalancer"
      ]
    },
    "Imports": {
      "assertEquals": "org.junit.Assert.assertEquals",
      "assertNotNull": "org.junit.Assert.assertNotNull",
      "assertTrue": "org.junit.Assert.assertTrue",
      "HashSet": "java.util.HashSet",
      "Set": "java.util.Set",
      "BeforeClass": "org.junit.BeforeClass",
      "Test": "org.junit.Test",
      "ConfigurationManager": "com.netflix.config.ConfigurationManager",
      "ConfigurationBasedServerList": "com.netflix.loadbalancer.ConfigurationBasedServerList",
      "DynamicServerListLoadBalancer": "com.netflix.loadbalancer.DynamicServerListLoadBalancer",
      "Server": "com.netflix.loadbalancer.Server",
      "RestClient": "com.netflix.niws.client.http.RestClient"
    },
    "FieldTypes": {
      "client": "com.netflix.niws.client.http.RestClient"
    }
  },
  "ribbon\\ribbon-httpclient\\src\\test\\java\\com\\netflix\\client\\ManyShortLivedRequestsSurvivorTest.java": {
    "TypeDeclarations": [
      "ManyShortLivedRequestsSurvivorTest"
    ],
    "MethodDeclarations": [
      "ManyShortLivedRequestsSurvivorTest.survive()",
      "ManyShortLivedRequestsSurvivorTest.hostAndPort(URL)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "com.netflix.config.ConfigurationManager.getConfigInstance",
        "ManyShortLivedRequestsSurvivorTest.hostAndPort",
        "ManyShortLivedRequestsSurvivorTest.hostAndPort"
      ],
      "Unresolved": [
        "setResponseCode",
        "setBody",
        "setResponseCode",
        "setBody",
        "setProperty",
        "uri",
        "build"
      ]
    },
    "Imports": {
      "MockResponse": "com.google.mockwebserver.MockResponse",
      "MockWebServer": "com.google.mockwebserver.MockWebServer",
      "HttpRequest": "com.netflix.client.http.HttpRequest",
      "HttpResponse": "com.netflix.client.http.HttpResponse",
      "RestClient": "com.netflix.niws.client.http.RestClient",
      "Test": "org.junit.Test",
      "IOException": "java.io.IOException",
      "URI": "java.net.URI",
      "URISyntaxException": "java.net.URISyntaxException",
      "URL": "java.net.URL",
      "getConfigInstance": "com.netflix.config.ConfigurationManager.getConfigInstance"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-httpclient\\src\\test\\java\\com\\netflix\\client\\samples\\SampleApp.java": {
    "TypeDeclarations": [
      "SampleApp"
    ],
    "MethodDeclarations": [
      "SampleApp.main(String)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "getProperty",
        "uri",
        "build",
        "setProperty"
      ]
    },
    "Imports": {
      "URI": "java.net.URI",
      "Ignore": "org.junit.Ignore",
      "ClientFactory": "com.netflix.client.ClientFactory",
      "HttpRequest": "com.netflix.client.http.HttpRequest",
      "HttpResponse": "com.netflix.client.http.HttpResponse",
      "ConfigurationManager": "com.netflix.config.ConfigurationManager",
      "ZoneAwareLoadBalancer": "com.netflix.loadbalancer.ZoneAwareLoadBalancer",
      "RestClient": "com.netflix.niws.client.http.RestClient"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-httpclient\\src\\test\\java\\com\\netflix\\client\\testutil\\SimpleSSLTestServer.java": {
    "TypeDeclarations": [
      "SimpleSSLTestServer"
    ],
    "MethodDeclarations": [
      "SimpleSSLTestServer.accept()",
      "SimpleSSLTestServer.close()",
      "SimpleSSLTestServer.getPort()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "createServerSocket",
        "start",
        "java.net.ServerSocket.accept",
        "java.net.ServerSocket.close",
        "java.net.ServerSocket.getLocalPort"
      ]
    },
    "Imports": {
      "BufferedReader": "java.io.BufferedReader",
      "BufferedWriter": "java.io.BufferedWriter",
      "File": "java.io.File",
      "FileInputStream": "java.io.FileInputStream",
      "InputStreamReader": "java.io.InputStreamReader",
      "OutputStreamWriter": "java.io.OutputStreamWriter",
      "ServerSocket": "java.net.ServerSocket",
      "Socket": "java.net.Socket",
      "Charset": "java.nio.charset.Charset",
      "KeyStore": "java.security.KeyStore",
      "KeyManagerFactory": "javax.net.ssl.KeyManagerFactory",
      "SSLContext": "javax.net.ssl.SSLContext",
      "SSLServerSocket": "javax.net.ssl.SSLServerSocket",
      "TrustManagerFactory": "javax.net.ssl.TrustManagerFactory",
      "Ignore": "org.junit.Ignore",
      "Closeables": "com.google.common.io.Closeables"
    },
    "FieldTypes": {
      "ss": "java.net.ServerSocket"
    }
  },
  "ribbon\\ribbon-httpclient\\src\\test\\java\\com\\netflix\\http4\\NamedConnectionPoolTest.java": {
    "TypeDeclarations": [
      "NamedConnectionPoolTest"
    ],
    "MethodDeclarations": [
      "NamedConnectionPoolTest.testConnectionPoolCounters()",
      "NamedConnectionPoolTest.testConnectionPoolCleaner()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "org.junit.Assert.assertTrue",
        "org.junit.Assert.assertTrue",
        "org.junit.Assert.assertTrue",
        "org.junit.Assert.assertTrue",
        "org.junit.Assert.assertTrue",
        "org.junit.Assert.assertTrue",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertNotNull",
        "org.junit.Assert.assertEquals"
      ],
      "Unresolved": [
        "com.netflix.client.testutil.MockHttpServer.getServerPath",
        "getStatusCode",
        "setProperty",
        "setProperty",
        "setProperty",
        "setProperty",
        "uri",
        "com.netflix.client.testutil.MockHttpServer.getServerPath",
        "build"
      ]
    },
    "Imports": {
      "assertEquals": "org.junit.Assert.assertEquals",
      "assertNotNull": "org.junit.Assert.assertNotNull",
      "assertTrue": "org.junit.Assert.assertTrue",
      "HttpResponse": "org.apache.http.HttpResponse",
      "HttpGet": "org.apache.http.client.methods.HttpGet",
      "HttpUriRequest": "org.apache.http.client.methods.HttpUriRequest",
      "EntityUtils": "org.apache.http.util.EntityUtils",
      "ClassRule": "org.junit.ClassRule",
      "Test": "org.junit.Test",
      "ClientFactory": "com.netflix.client.ClientFactory",
      "CommonClientConfigKey": "com.netflix.client.config.CommonClientConfigKey",
      "HttpRequest": "com.netflix.client.http.HttpRequest",
      "MockHttpServer": "com.netflix.client.testutil.MockHttpServer",
      "ConfigurationManager": "com.netflix.config.ConfigurationManager",
      "RestClient": "com.netflix.niws.client.http.RestClient"
    },
    "FieldTypes": {
      "server": "com.netflix.client.testutil.MockHttpServer"
    }
  },
  "ribbon\\ribbon-httpclient\\src\\test\\java\\com\\netflix\\http4\\NFHttpClientTest.java": {
    "TypeDeclarations": [
      "NFHttpClientTest",
      "GetThread"
    ],
    "MethodDeclarations": [
      "NFHttpClientTest.testDefaultClient()",
      "NFHttpClientTest.testNFHttpClient()",
      "NFHttpClientTest.testMultiThreadedClient()",
      "GetThread.run()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "org.junit.Assert.assertTrue",
        "org.junit.Assert.assertTrue"
      ],
      "Unresolved": [
        "com.netflix.client.testutil.MockHttpServer.getServerURI",
        "com.netflix.client.testutil.MockHttpServer.getServerPort",
        "com.netflix.client.testutil.MockHttpServer.getServerURI",
        "start",
        "org.apache.http.client.methods.HttpGet.getURI",
        "org.apache.http.client.HttpClient.execute"
      ]
    },
    "Imports": {
      "assertTrue": "org.junit.Assert.assertTrue",
      "IOException": "java.io.IOException",
      "HttpEntity": "org.apache.http.HttpEntity",
      "HttpHost": "org.apache.http.HttpHost",
      "HttpResponse": "org.apache.http.HttpResponse",
      "ClientProtocolException": "org.apache.http.client.ClientProtocolException",
      "HttpClient": "org.apache.http.client.HttpClient",
      "ResponseHandler": "org.apache.http.client.ResponseHandler",
      "HttpGet": "org.apache.http.client.methods.HttpGet",
      "ThreadSafeClientConnManager": "org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager",
      "EntityUtils": "org.apache.http.util.EntityUtils",
      "ClassRule": "org.junit.ClassRule",
      "Ignore": "org.junit.Ignore",
      "Test": "org.junit.Test",
      "MockHttpServer": "com.netflix.client.testutil.MockHttpServer"
    },
    "FieldTypes": {
      "server": "com.netflix.client.testutil.MockHttpServer",
      "httpClient": "org.apache.http.client.HttpClient",
      "target": "org.apache.http.HttpHost",
      "request": "org.apache.http.client.methods.HttpGet"
    }
  },
  "ribbon\\ribbon-httpclient\\src\\test\\java\\com\\netflix\\niws\\client\\http\\FollowRedirectTest.java": {
    "TypeDeclarations": [
      "FollowRedirectTest"
    ],
    "MethodDeclarations": [
      "FollowRedirectTest.setup()",
      "FollowRedirectTest.shutdown()",
      "FollowRedirectTest.testRedirectNotFollowed()",
      "FollowRedirectTest.testRedirectFollowed()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals"
      ],
      "Unresolved": [
        "com.google.mockwebserver.MockWebServer.enqueue",
        "setResponseCode",
        "setHeader",
        "setBody",
        "com.google.mockwebserver.MockWebServer.play",
        "com.google.mockwebserver.MockWebServer.enqueue",
        "setResponseCode",
        "setHeader",
        "com.google.mockwebserver.MockWebServer.getPort",
        "com.google.mockwebserver.MockWebServer.play",
        "com.google.mockwebserver.MockWebServer.shutdown",
        "com.google.mockwebserver.MockWebServer.shutdown",
        "uri",
        "com.google.mockwebserver.MockWebServer.getPort",
        "build",
        "set",
        "uri",
        "com.google.mockwebserver.MockWebServer.getPort",
        "build"
      ]
    },
    "Imports": {
      "assertEquals": "org.junit.Assert.assertEquals",
      "IOException": "java.io.IOException",
      "URI": "java.net.URI",
      "After": "org.junit.After",
      "Before": "org.junit.Before",
      "Test": "org.junit.Test",
      "MockResponse": "com.google.mockwebserver.MockResponse",
      "MockWebServer": "com.google.mockwebserver.MockWebServer",
      "ClientFactory": "com.netflix.client.ClientFactory",
      "CommonClientConfigKey": "com.netflix.client.config.CommonClientConfigKey",
      "DefaultClientConfigImpl": "com.netflix.client.config.DefaultClientConfigImpl",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "IClientConfigKey": "com.netflix.client.config.IClientConfigKey",
      "HttpRequest": "com.netflix.client.http.HttpRequest",
      "HttpResponse": "com.netflix.client.http.HttpResponse"
    },
    "FieldTypes": {
      "redirectingServer": "com.google.mockwebserver.MockWebServer",
      "redirectedServer": "com.google.mockwebserver.MockWebServer"
    }
  },
  "ribbon\\ribbon-httpclient\\src\\test\\java\\com\\netflix\\niws\\client\\http\\GetPostTest.java": {
    "TypeDeclarations": [
      "GetPostTest"
    ],
    "MethodDeclarations": [
      "GetPostTest.init()",
      "GetPostTest.shutDown()",
      "GetPostTest.testGet()",
      "GetPostTest.testPost()",
      "GetPostTest.testChunkedEncoding()"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.lang.equals",
        "java.lang.equals",
        "java.lang.equals"
      ],
      "UserDefined": [
        "org.junit.Assert.fail",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertTrue",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertTrue",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertTrue"
      ],
      "Unresolved": [
        "nextInt",
        "com.sun.net.httpserver.HttpServer.start",
        "com.sun.net.httpserver.HttpServer.stop",
        "uri",
        "queryParams",
        "build",
        "verb",
        "uri",
        "entity",
        "build",
        "verb",
        "uri",
        "entity",
        "build"
      ]
    },
    "Imports": {
      "assertEquals": "org.junit.Assert.assertEquals",
      "assertTrue": "org.junit.Assert.assertTrue",
      "fail": "org.junit.Assert.fail",
      "ByteArrayInputStream": "java.io.ByteArrayInputStream",
      "InputStream": "java.io.InputStream",
      "URI": "java.net.URI",
      "Random": "java.util.Random",
      "AfterClass": "org.junit.AfterClass",
      "BeforeClass": "org.junit.BeforeClass",
      "Test": "org.junit.Test",
      "ClientFactory": "com.netflix.client.ClientFactory",
      "HttpRequest": "com.netflix.client.http.HttpRequest",
      "HttpResponse": "com.netflix.client.http.HttpResponse",
      "Verb": "com.netflix.client.http.HttpRequest.Verb",
      "HttpServerFactory": "com.sun.jersey.api.container.httpserver.HttpServerFactory",
      "PackagesResourceConfig": "com.sun.jersey.api.core.PackagesResourceConfig",
      "MultivaluedMapImpl": "com.sun.jersey.core.util.MultivaluedMapImpl",
      "HttpServer": "com.sun.net.httpserver.HttpServer"
    },
    "FieldTypes": {
      "server": "com.sun.net.httpserver.HttpServer"
    }
  },
  "ribbon\\ribbon-httpclient\\src\\test\\java\\com\\netflix\\niws\\client\\http\\PrimeConnectionsTest.java": {
    "TypeDeclarations": [
      "PrimeConnectionsTest",
      "LargeFixedServerList",
      "SmallFixedServerList",
      "FixedServerList"
    ],
    "MethodDeclarations": [
      "FixedServerList.initWithNiwsConfig(IClientConfig)",
      "FixedServerList.getInitialListOfServers()",
      "FixedServerList.getUpdatedListOfServers()",
      "PrimeConnectionsTest.setup()",
      "PrimeConnectionsTest.testPrimeConnectionsSmallPool()",
      "PrimeConnectionsTest.testPrimeConnectionsLargePool()",
      "PrimeConnectionsTest.shutDown()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "nextInt",
        "com.sun.net.httpserver.HttpServer.start",
        "fail",
        "getName",
        "getName",
        "getEndStats",
        "assertEquals",
        "getName",
        "getName",
        "getEndStats",
        "assertEquals",
        "com.sun.net.httpserver.HttpServer.stop"
      ]
    },
    "Imports": {
      "org.junit.Assert.*": "org.junit.Assert",
      "Arrays": "java.util.Arrays",
      "List": "java.util.List",
      "Random": "java.util.Random",
      "Configuration": "org.apache.commons.configuration.Configuration",
      "org.junit.*": "org.junit",
      "ClientFactory": "com.netflix.client.ClientFactory",
      "PrimeConnectionEndStats": "com.netflix.client.PrimeConnections.PrimeConnectionEndStats",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "ConfigurationManager": "com.netflix.config.ConfigurationManager",
      "AbstractServerList": "com.netflix.loadbalancer.AbstractServerList",
      "DynamicServerListLoadBalancer": "com.netflix.loadbalancer.DynamicServerListLoadBalancer",
      "Server": "com.netflix.loadbalancer.Server",
      "HttpServerFactory": "com.sun.jersey.api.container.httpserver.HttpServerFactory",
      "PackagesResourceConfig": "com.sun.jersey.api.core.PackagesResourceConfig",
      "HttpServer": "com.sun.net.httpserver.HttpServer"
    },
    "FieldTypes": {
      "server": "com.sun.net.httpserver.HttpServer",
      "testServer": "com.netflix.loadbalancer.Server",
      "testServers": "java.util.List"
    }
  },
  "ribbon\\ribbon-httpclient\\src\\test\\java\\com\\netflix\\niws\\client\\http\\ResponseTimeWeightedRuleTest.java": {
    "TypeDeclarations": [
      "ResponseTimeWeightedRuleTest"
    ],
    "MethodDeclarations": [
      "ResponseTimeWeightedRuleTest.testServerWeights()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "setProperty",
        "setProperty",
        "setProperty",
        "setProperty",
        "uri",
        "build"
      ]
    },
    "Imports": {
      "URI": "java.net.URI",
      "Test": "org.junit.Test",
      "ClientFactory": "com.netflix.client.ClientFactory",
      "HttpRequest": "com.netflix.client.http.HttpRequest",
      "ConfigurationManager": "com.netflix.config.ConfigurationManager",
      "AbstractLoadBalancer": "com.netflix.loadbalancer.AbstractLoadBalancer",
      "WeightedResponseTimeRule": "com.netflix.loadbalancer.WeightedResponseTimeRule"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-httpclient\\src\\test\\java\\com\\netflix\\niws\\client\\http\\RestClientTest.java": {
    "TypeDeclarations": [
      "RestClientTest"
    ],
    "MethodDeclarations": [
      "RestClientTest.testExecuteWithoutLB()",
      "RestClientTest.testExecuteWithLB()",
      "RestClientTest.testVipAsURI()",
      "RestClientTest.testSecureClient()",
      "RestClientTest.testSecureClient2()",
      "RestClientTest.testDelete()",
      "RestClientTest.assertStatusIsOk(BasicType(dimensions=[], name=int))"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.lang.toString",
        "java.lang.toString"
      ],
      "UserDefined": [
        "RestClientTest.assertStatusIsOk",
        "RestClientTest.assertStatusIsOk",
        "RestClientTest.assertStatusIsOk",
        "org.junit.Assert.assertTrue",
        "org.junit.Assert.assertFalse",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertNull",
        "RestClientTest.assertStatusIsOk",
        "org.junit.Assert.assertEquals",
        "RestClientTest.assertStatusIsOk",
        "RestClientTest.assertStatusIsOk",
        "org.junit.Assert.assertEquals",
        "RestClientTest.assertStatusIsOk",
        "RestClientTest.assertStatusIsOk",
        "org.junit.Assert.assertTrue"
      ],
      "Unresolved": [
        "secure",
        "uri",
        "com.netflix.client.testutil.MockHttpServer.getServerURI",
        "build",
        "setProperty",
        "setProperty",
        "com.netflix.client.testutil.MockHttpServer.getServerPort",
        "com.netflix.client.testutil.MockHttpServer.getServerPath",
        "uri",
        "build",
        "uri",
        "com.netflix.client.testutil.MockHttpServer.getServerURI",
        "build",
        "setProperty",
        "com.netflix.client.testutil.MockHttpServer.getServerPath",
        "setProperty",
        "uri",
        "build",
        "com.netflix.client.testutil.MockHttpServer.getServerPath",
        "setProperty",
        "uri",
        "com.netflix.client.testutil.MockHttpServer.getServerURI",
        "build",
        "setProperty",
        "setProperty",
        "com.netflix.client.testutil.MockHttpServer.getTrustStore",
        "getAbsolutePath",
        "setProperty",
        "com.netflix.client.testutil.MockHttpServer.getServerPort",
        "uri",
        "build",
        "com.netflix.client.testutil.MockHttpServer.getServerPath",
        "uri",
        "com.netflix.client.testutil.MockHttpServer.getServerURI",
        "verb",
        "build",
        "uri",
        "com.netflix.client.testutil.MockHttpServer.getServerURI",
        "verb",
        "entity",
        "build"
      ]
    },
    "Imports": {
      "assertEquals": "org.junit.Assert.assertEquals",
      "assertFalse": "org.junit.Assert.assertFalse",
      "assertNull": "org.junit.Assert.assertNull",
      "assertTrue": "org.junit.Assert.assertTrue",
      "URI": "java.net.URI",
      "Arrays": "java.util.Arrays",
      "HashSet": "java.util.HashSet",
      "Set": "java.util.Set",
      "ClassRule": "org.junit.ClassRule",
      "Test": "org.junit.Test",
      "ClientFactory": "com.netflix.client.ClientFactory",
      "CommonClientConfigKey": "com.netflix.client.config.CommonClientConfigKey",
      "HttpRequest": "com.netflix.client.http.HttpRequest",
      "HttpResponse": "com.netflix.client.http.HttpResponse",
      "MockHttpServer": "com.netflix.client.testutil.MockHttpServer",
      "ConfigurationManager": "com.netflix.config.ConfigurationManager",
      "BaseLoadBalancer": "com.netflix.loadbalancer.BaseLoadBalancer",
      "Server": "com.netflix.loadbalancer.Server"
    },
    "FieldTypes": {
      "server": "com.netflix.client.testutil.MockHttpServer",
      "secureServer": "com.netflix.client.testutil.MockHttpServer"
    }
  },
  "ribbon\\ribbon-httpclient\\src\\test\\java\\com\\netflix\\niws\\client\\http\\RetryTest.java": {
    "TypeDeclarations": [
      "RetryTest"
    ],
    "MethodDeclarations": [
      "RetryTest.init()",
      "RetryTest.beforeTest()",
      "RetryTest.testThrottled()",
      "RetryTest.testThrottledWithRetrySameServer()",
      "RetryTest.testThrottledWithRetryNextServer()",
      "RetryTest.testReadTimeout()",
      "RetryTest.testReadTimeoutWithRetriesNextServe()",
      "RetryTest.postReadTimeout()",
      "RetryTest.testRetriesOnPost()",
      "RetryTest.testRetriesOnPostWithConnectException()",
      "RetryTest.testSuccessfulRetries()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "org.junit.Assert.fail",
        "org.junit.Assert.assertNotNull",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.fail",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.fail",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertTrue",
        "org.junit.Assert.fail",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.fail",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.fail",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.fail",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.fail",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.fail",
        "org.junit.Assert.assertEquals"
      ],
      "Unresolved": [
        "com.netflix.client.testutil.MockHttpServer.getServerPort",
        "setProperty",
        "getName",
        "setProperty",
        "getName",
        "setProperty",
        "setProperty",
        "setProperty",
        "com.netflix.loadbalancer.BaseLoadBalancer.setServersList",
        "com.netflix.http4.NFHttpClient.getConnectionManager",
        "com.netflix.loadbalancer.BaseLoadBalancer.setServersList",
        "com.netflix.loadbalancer.BaseLoadBalancer.setRule",
        "com.netflix.loadbalancer.BaseLoadBalancer.getLoadBalancerStats",
        "getSingleServerStat",
        "clearSuccessiveConnectionFailureCount",
        "uri",
        "build",
        "set",
        "com.netflix.loadbalancer.BaseLoadBalancer.getLoadBalancerStats",
        "getSingleServerStat",
        "getSuccessiveConnectionFailureCount",
        "uri",
        "build",
        "set",
        "set",
        "com.netflix.loadbalancer.BaseLoadBalancer.getLoadBalancerStats",
        "getSingleServerStat",
        "getSuccessiveConnectionFailureCount",
        "com.netflix.http4.MonitoredConnectionManager.getConnectionsInPool",
        "uri",
        "build",
        "set",
        "com.netflix.loadbalancer.BaseLoadBalancer.getLoadBalancerStats",
        "getSingleServerStat",
        "getSuccessiveConnectionFailureCount",
        "com.netflix.http4.MonitoredConnectionManager.getConnectionsInPool",
        "com.netflix.http4.MonitoredConnectionManager.getConnectionsInPool",
        "uri",
        "build",
        "set",
        "com.netflix.loadbalancer.BaseLoadBalancer.getLoadBalancerStats",
        "getSingleServerStat",
        "getSuccessiveConnectionFailureCount",
        "uri",
        "build",
        "set",
        "com.netflix.loadbalancer.BaseLoadBalancer.getLoadBalancerStats",
        "getSingleServerStat",
        "getSuccessiveConnectionFailureCount",
        "uri",
        "verb",
        "build",
        "set",
        "com.netflix.loadbalancer.BaseLoadBalancer.getLoadBalancerStats",
        "getSingleServerStat",
        "uri",
        "verb",
        "setRetriable",
        "build",
        "set",
        "com.netflix.loadbalancer.BaseLoadBalancer.getLoadBalancerStats",
        "getSingleServerStat",
        "com.netflix.loadbalancer.BaseLoadBalancer.setServersList",
        "uri",
        "verb",
        "setRetriable",
        "build",
        "set",
        "com.netflix.loadbalancer.BaseLoadBalancer.getLoadBalancerStats",
        "getSingleServerStat",
        "com.netflix.loadbalancer.BaseLoadBalancer.setServersList",
        "uri",
        "queryParams",
        "build",
        "set",
        "com.netflix.loadbalancer.BaseLoadBalancer.getLoadBalancerStats",
        "getSingleServerStat"
      ]
    },
    "Imports": {
      "assertEquals": "org.junit.Assert.assertEquals",
      "assertNotNull": "org.junit.Assert.assertNotNull",
      "assertTrue": "org.junit.Assert.assertTrue",
      "fail": "org.junit.Assert.fail",
      "URI": "java.net.URI",
      "Before": "org.junit.Before",
      "BeforeClass": "org.junit.BeforeClass",
      "ClassRule": "org.junit.ClassRule",
      "Test": "org.junit.Test",
      "Lists": "com.google.common.collect.Lists",
      "ClientException": "com.netflix.client.ClientException",
      "ClientFactory": "com.netflix.client.ClientFactory",
      "CommonClientConfigKey": "com.netflix.client.config.CommonClientConfigKey",
      "DefaultClientConfigImpl": "com.netflix.client.config.DefaultClientConfigImpl",
      "HttpRequest": "com.netflix.client.http.HttpRequest",
      "Verb": "com.netflix.client.http.HttpRequest.Verb",
      "HttpResponse": "com.netflix.client.http.HttpResponse",
      "MockHttpServer": "com.netflix.client.testutil.MockHttpServer",
      "ConfigurationManager": "com.netflix.config.ConfigurationManager",
      "MonitoredConnectionManager": "com.netflix.http4.MonitoredConnectionManager",
      "NFHttpClient": "com.netflix.http4.NFHttpClient",
      "NFHttpClientFactory": "com.netflix.http4.NFHttpClientFactory",
      "AvailabilityFilteringRule": "com.netflix.loadbalancer.AvailabilityFilteringRule",
      "BaseLoadBalancer": "com.netflix.loadbalancer.BaseLoadBalancer",
      "DummyPing": "com.netflix.loadbalancer.DummyPing",
      "Server": "com.netflix.loadbalancer.Server",
      "ServerStats": "com.netflix.loadbalancer.ServerStats"
    },
    "FieldTypes": {
      "server": "com.netflix.client.testutil.MockHttpServer",
      "lb": "com.netflix.loadbalancer.BaseLoadBalancer",
      "httpClient": "com.netflix.http4.NFHttpClient",
      "connectionPoolManager": "com.netflix.http4.MonitoredConnectionManager",
      "localServer": "com.netflix.loadbalancer.Server"
    }
  },
  "ribbon\\ribbon-httpclient\\src\\test\\java\\com\\netflix\\niws\\client\\http\\SecureAcceptAllGetTest.java": {
    "TypeDeclarations": [
      "SecureAcceptAllGetTest"
    ],
    "MethodDeclarations": [
      "SecureAcceptAllGetTest.init()",
      "SecureAcceptAllGetTest.shutDown()",
      "SecureAcceptAllGetTest.testPositiveAcceptAllSSLSocketFactory()",
      "SecureAcceptAllGetTest.testNegativeAcceptAllSSLSocketFactoryCannotWorkWithTrustStore()",
      "SecureAcceptAllGetTest.testNegativeAcceptAllSSLSocketFactory()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "org.junit.Assert.fail",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertTrue",
        "org.junit.Assert.assertTrue"
      ],
      "Unresolved": [
        "com.netflix.client.testutil.SimpleSSLTestServer.getPort",
        "com.netflix.client.testutil.SimpleSSLTestServer.close",
        "org.junit.rules.TestName.getMethodName",
        "com.netflix.client.testutil.SimpleSSLTestServer.accept",
        "uri",
        "queryParams",
        "build",
        "org.junit.rules.TestName.getMethodName",
        "java.io.File.getAbsolutePath",
        "startsWith",
        "org.junit.rules.TestName.getMethodName",
        "com.netflix.client.testutil.SimpleSSLTestServer.accept",
        "uri",
        "queryParams",
        "build",
        "startsWith"
      ]
    },
    "Imports": {
      "ClientFactory": "com.netflix.client.ClientFactory",
      "CommonClientConfigKey": "com.netflix.client.config.CommonClientConfigKey",
      "HttpRequest": "com.netflix.client.http.HttpRequest",
      "HttpResponse": "com.netflix.client.http.HttpResponse",
      "SimpleSSLTestServer": "com.netflix.client.testutil.SimpleSSLTestServer",
      "ConfigurationManager": "com.netflix.config.ConfigurationManager",
      "Base64": "com.sun.jersey.core.util.Base64",
      "AbstractConfiguration": "org.apache.commons.configuration.AbstractConfiguration",
      "org.junit.*": "org.junit",
      "TestName": "org.junit.rules.TestName",
      "SSLPeerUnverifiedException": "javax.net.ssl.SSLPeerUnverifiedException",
      "File": "java.io.File",
      "FileOutputStream": "java.io.FileOutputStream",
      "URI": "java.net.URI",
      "Random": "java.util.Random",
      "assertEquals": "org.junit.Assert.assertEquals",
      "assertTrue": "org.junit.Assert.assertTrue",
      "fail": "org.junit.Assert.fail"
    },
    "FieldTypes": {
      "TEST_FILE_KS": "java.io.File",
      "TEST_FILE_TS": "java.io.File",
      "TEST_SERVER": "com.netflix.client.testutil.SimpleSSLTestServer",
      "testName": "org.junit.rules.TestName"
    }
  },
  "ribbon\\ribbon-httpclient\\src\\test\\java\\com\\netflix\\niws\\client\\http\\SecureGetTest.java": {
    "TypeDeclarations": [
      "SecureGetTest"
    ],
    "MethodDeclarations": [
      "SecureGetTest.init()",
      "SecureGetTest.shutDown()",
      "SecureGetTest.testSunnyDay()",
      "SecureGetTest.testSunnyDayNoClientAuth()",
      "SecureGetTest.testFailsWithHostNameValidationOn()",
      "SecureGetTest.testClientRejectsWrongServer()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "org.junit.Assert.fail",
        "org.junit.Assert.fail",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.fail",
        "org.junit.Assert.assertTrue",
        "org.junit.Assert.fail",
        "org.junit.Assert.assertTrue"
      ],
      "Unresolved": [
        "com.netflix.client.testutil.SimpleSSLTestServer.getPort",
        "com.netflix.client.testutil.SimpleSSLTestServer.getPort",
        "com.netflix.client.testutil.SimpleSSLTestServer.close",
        "com.netflix.client.testutil.SimpleSSLTestServer.close",
        "com.netflix.client.testutil.SimpleSSLTestServer.getPort",
        "java.io.File.getAbsolutePath",
        "java.io.File.getAbsolutePath",
        "com.netflix.client.testutil.SimpleSSLTestServer.accept",
        "uri",
        "queryParams",
        "build",
        "com.netflix.client.testutil.SimpleSSLTestServer.getPort",
        "java.io.File.getAbsolutePath",
        "com.netflix.client.testutil.SimpleSSLTestServer.accept",
        "uri",
        "queryParams",
        "build",
        "com.netflix.client.testutil.SimpleSSLTestServer.getPort",
        "java.io.File.getAbsolutePath",
        "java.io.File.getAbsolutePath",
        "com.netflix.client.testutil.SimpleSSLTestServer.accept",
        "uri",
        "queryParams",
        "build",
        "indexOf",
        "com.netflix.client.testutil.SimpleSSLTestServer.getPort",
        "java.io.File.getAbsolutePath",
        "com.netflix.client.testutil.SimpleSSLTestServer.accept",
        "uri",
        "queryParams",
        "build",
        "indexOf"
      ]
    },
    "Imports": {
      "assertEquals": "org.junit.Assert.assertEquals",
      "assertTrue": "org.junit.Assert.assertTrue",
      "fail": "org.junit.Assert.fail",
      "File": "java.io.File",
      "FileOutputStream": "java.io.FileOutputStream",
      "URI": "java.net.URI",
      "AbstractConfiguration": "org.apache.commons.configuration.AbstractConfiguration",
      "AfterClass": "org.junit.AfterClass",
      "BeforeClass": "org.junit.BeforeClass",
      "Test": "org.junit.Test",
      "ClientFactory": "com.netflix.client.ClientFactory",
      "CommonClientConfigKey": "com.netflix.client.config.CommonClientConfigKey",
      "HttpRequest": "com.netflix.client.http.HttpRequest",
      "HttpResponse": "com.netflix.client.http.HttpResponse",
      "SimpleSSLTestServer": "com.netflix.client.testutil.SimpleSSLTestServer",
      "ConfigurationManager": "com.netflix.config.ConfigurationManager",
      "ClientHandlerException": "com.sun.jersey.api.client.ClientHandlerException",
      "Base64": "com.sun.jersey.core.util.Base64",
      "MultivaluedMapImpl": "com.sun.jersey.core.util.MultivaluedMapImpl"
    },
    "FieldTypes": {
      "testServer1": "com.netflix.client.testutil.SimpleSSLTestServer",
      "testServer2": "com.netflix.client.testutil.SimpleSSLTestServer",
      "FILE_TS1": "java.io.File",
      "FILE_KS1": "java.io.File",
      "FILE_TS2": "java.io.File",
      "FILE_KS2": "java.io.File"
    }
  },
  "ribbon\\ribbon-httpclient\\src\\test\\java\\com\\netflix\\niws\\client\\http\\SecureRestClientKeystoreTest.java": {
    "TypeDeclarations": [
      "SecureRestClientKeystoreTest"
    ],
    "MethodDeclarations": [
      "SecureRestClientKeystoreTest.testGetKeystoreWithClientAuth()",
      "SecureRestClientKeystoreTest.testGetKeystoreWithNoClientAuth()"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.lang.getClass",
        "java.lang.getClass",
        "java.lang.getClass",
        "java.lang.getClass",
        "java.lang.getClass",
        "java.lang.getClass"
      ],
      "UserDefined": [
        "org.junit.Assert.assertNotNull",
        "org.junit.Assert.assertNotNull"
      ],
      "Unresolved": [
        "getName",
        "getName",
        "getName",
        "getName",
        "getName",
        "getName"
      ]
    },
    "Imports": {
      "assertNotNull": "org.junit.Assert.assertNotNull",
      "File": "java.io.File",
      "FileOutputStream": "java.io.FileOutputStream",
      "KeyStore": "java.security.KeyStore",
      "Certificate": "java.security.cert.Certificate",
      "AbstractConfiguration": "org.apache.commons.configuration.AbstractConfiguration",
      "Test": "org.junit.Test",
      "ClientFactory": "com.netflix.client.ClientFactory",
      "CommonClientConfigKey": "com.netflix.client.config.CommonClientConfigKey",
      "ConfigurationManager": "com.netflix.config.ConfigurationManager",
      "Base64": "com.sun.jersey.core.util.Base64"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-httpclient\\src\\test\\java\\com\\netflix\\niws\\client\\http\\TestObject.java": {
    "TypeDeclarations": [
      "TestObject"
    ],
    "MethodDeclarations": [],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "XmlRootElement": "javax.xml.bind.annotation.XmlRootElement"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-httpclient\\src\\test\\java\\com\\netflix\\niws\\client\\http\\TestResource.java": {
    "TypeDeclarations": [
      "TestResource"
    ],
    "MethodDeclarations": [
      "TestResource.getObject(String)",
      "TestResource.getJsonObject(String)",
      "TestResource.setObject(TestObject)",
      "TestResource.setJsonObject(String)",
      "TestResource.handlePost(InputStream, String)",
      "TestResource.get503()",
      "TestResource.get500()",
      "TestResource.getReadtimeout()",
      "TestResource.postReadtimeout()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "build",
        "build",
        "build",
        "build",
        "build",
        "build",
        "build",
        "build",
        "build",
        "build"
      ]
    },
    "Imports": {
      "InputStream": "java.io.InputStream",
      "Consumes": "javax.ws.rs.Consumes",
      "GET": "javax.ws.rs.GET",
      "HeaderParam": "javax.ws.rs.HeaderParam",
      "POST": "javax.ws.rs.POST",
      "Path": "javax.ws.rs.Path",
      "Produces": "javax.ws.rs.Produces",
      "QueryParam": "javax.ws.rs.QueryParam",
      "MediaType": "javax.ws.rs.core.MediaType",
      "Response": "javax.ws.rs.core.Response",
      "ObjectMapper": "com.fasterxml.jackson.databind.ObjectMapper",
      "IOUtils": "org.apache.commons.io.IOUtils"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\client\\AbstractLoadBalancerAwareClient.java": {
    "TypeDeclarations": [
      "AbstractLoadBalancerAwareClient"
    ],
    "MethodDeclarations": [
      "AbstractLoadBalancerAwareClient.isCircuitBreakerException(Throwable)",
      "AbstractLoadBalancerAwareClient.isRetriableException(Throwable)",
      "AbstractLoadBalancerAwareClient.executeWithLoadBalancer(S)",
      "AbstractLoadBalancerAwareClient.executeWithLoadBalancer(S, IClientConfig)",
      "AbstractLoadBalancerAwareClient.getRequestSpecificRetryHandler(S, IClientConfig)",
      "AbstractLoadBalancerAwareClient.buildLoadBalancerCommand(S, IClientConfig)",
      "AbstractLoadBalancerAwareClient.customizeLoadBalancerCommandBuilder(S, IClientConfig, LoadBalancerCommand)",
      "AbstractLoadBalancerAwareClient.isRetriable(S)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "AbstractLoadBalancerAwareClient.isRetriableException",
        "AbstractLoadBalancerAwareClient.executeWithLoadBalancer",
        "AbstractLoadBalancerAwareClient.buildLoadBalancerCommand",
        "AbstractLoadBalancerAwareClient.getRequestSpecificRetryHandler",
        "com.netflix.loadbalancer.reactive.LoadBalancerCommand",
        "AbstractLoadBalancerAwareClient.customizeLoadBalancerCommandBuilder"
      ],
      "Unresolved": [
        "getRetryHandler",
        "getRetryHandler",
        "isCircuitTrippingException",
        "getRetryHandler",
        "getRetryHandler",
        "toBlocking",
        "single",
        "reconstructURIWithServer",
        "execute",
        "withLoadBalancerContext",
        "withRetryHandler",
        "withLoadBalancerURI"
      ]
    },
    "Imports": {
      "URI": "java.net.URI",
      "Observable": "rx.Observable",
      "CommonClientConfigKey": "com.netflix.client.config.CommonClientConfigKey",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "AvailabilityFilteringRule": "com.netflix.loadbalancer.AvailabilityFilteringRule",
      "ILoadBalancer": "com.netflix.loadbalancer.ILoadBalancer",
      "LoadBalancerContext": "com.netflix.loadbalancer.LoadBalancerContext",
      "Server": "com.netflix.loadbalancer.Server",
      "LoadBalancerCommand": "com.netflix.loadbalancer.reactive.LoadBalancerCommand",
      "ServerOperation": "com.netflix.loadbalancer.reactive.ServerOperation"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\client\\ClientFactory.java": {
    "TypeDeclarations": [
      "ClientFactory"
    ],
    "MethodDeclarations": [
      "ClientFactory.registerClientFromProperties(String, IClientConfig)",
      "ClientFactory.getNamedClient(String)",
      "ClientFactory.getNamedClient(String, Class)",
      "ClientFactory.createNamedClient(String, Class)",
      "ClientFactory.getNamedLoadBalancer(String)",
      "ClientFactory.getNamedLoadBalancer(String, Class)",
      "ClientFactory.registerNamedLoadBalancerFromclientConfig(String, IClientConfig)",
      "ClientFactory.registerNamedLoadBalancerFromProperties(String, Class)",
      "ClientFactory.instantiateInstanceWithClientConfig(String, IClientConfig)",
      "ClientFactory.getNamedConfig(String)",
      "ClientFactory.getNamedConfig(String, Class)",
      "ClientFactory.getNamedConfig(String, Supplier)",
      "ClientFactory.factoryFromConfigType(Class)"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.util.Map.get",
        "java.util.Map.put",
        "java.util.Map.get",
        "java.util.Map.get",
        "java.util.Map.get",
        "java.util.Map.get",
        "java.util.Map.get",
        "java.util.Map.put",
        "java.util.Map.get",
        "java.util.Map.get",
        "java.util.Map.put",
        "java.util.Map.get"
      ],
      "UserDefined": [
        "ClientFactory.instantiateInstanceWithClientConfig",
        "ClientFactory.registerNamedLoadBalancerFromclientConfig",
        "ClientFactory.registerClientFromProperties",
        "ClientFactory.getNamedConfig",
        "ClientFactory.createNamedClient",
        "ClientFactory.getNamedConfig",
        "ClientFactory.registerClientFromProperties",
        "ClientFactory.registerNamedLoadBalancerFromclientConfig",
        "ClientFactory.getNamedConfig",
        "ClientFactory.registerNamedLoadBalancerFromProperties",
        "ClientFactory.getNamedConfig",
        "ClientFactory.registerNamedLoadBalancerFromclientConfig",
        "ClientFactory.getNamedConfig",
        "ClientFactory.getNamedConfig",
        "ClientFactory.factoryFromConfigType"
      ],
      "Unresolved": [
        "org.slf4j.Logger.warn",
        "org.slf4j.Logger.info",
        "org.slf4j.Logger.info",
        "isAssignableFrom",
        "newInstance",
        "org.slf4j.Logger.warn",
        "org.slf4j.Logger.warn",
        "java.util.concurrent.ConcurrentHashMap.computeIfAbsent",
        "org.slf4j.Logger.error"
      ]
    },
    "Imports": {
      "ClientConfigFactory": "com.netflix.client.config.ClientConfigFactory",
      "CommonClientConfigKey": "com.netflix.client.config.CommonClientConfigKey",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "ILoadBalancer": "com.netflix.loadbalancer.ILoadBalancer",
      "Monitors": "com.netflix.servo.monitor.Monitors",
      "Logger": "org.slf4j.Logger",
      "LoggerFactory": "org.slf4j.LoggerFactory",
      "InvocationTargetException": "java.lang.reflect.InvocationTargetException",
      "Map": "java.util.Map",
      "ConcurrentHashMap": "java.util.concurrent.ConcurrentHashMap",
      "Supplier": "java.util.function.Supplier"
    },
    "FieldTypes": {
      "simpleClientMap": "java.util.Map",
      "namedLBMap": "java.util.Map",
      "namedConfig": "java.util.concurrent.ConcurrentHashMap",
      "logger": "org.slf4j.Logger"
    }
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\client\\IPrimeConnection.java": {
    "TypeDeclarations": [
      "IPrimeConnection"
    ],
    "MethodDeclarations": [
      "IPrimeConnection.connect(Server, String)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "Server": "com.netflix.loadbalancer.Server"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\client\\PrimeConnections.java": {
    "TypeDeclarations": [
      "PrimeConnections",
      "PrimeConnectionListener",
      "PrimeConnectionEndStats",
      "ASyncPrimeConnectionsThreadFactory"
    ],
    "MethodDeclarations": [
      "PrimeConnectionListener.primeCompleted(Server, Throwable)",
      "PrimeConnectionEndStats.toString()",
      "PrimeConnections.setUp(String, BasicType(dimensions=[], name=int), BasicType(dimensions=[], name=long), String, BasicType(dimensions=[], name=float))",
      "PrimeConnections.primeConnections(List)",
      "PrimeConnections.getEndStats()",
      "PrimeConnections.printStats(PrimeConnectionEndStats)",
      "PrimeConnections.primeConnectionsAsync(List, PrimeConnectionListener)",
      "PrimeConnections.makeConnectionASync(Server, PrimeConnectionListener)",
      "PrimeConnections.shutdown()",
      "PrimeConnections.connectToServer(Server, PrimeConnectionListener)",
      "PrimeConnections.sleepBeforeRetry(BasicType(dimensions=[], name=int))",
      "ASyncPrimeConnectionsThreadFactory.newThread(Runnable)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "org.slf4j.Logger.warn",
        "org.slf4j.Logger.warn",
        "newInstance",
        "setUp",
        "setUp",
        "setUp",
        "org.slf4j.Logger.debug",
        "primeConnectionsAsync",
        "com.netflix.servo.monitor.Timer.start",
        "org.slf4j.Logger.error",
        "printStats",
        "org.slf4j.Logger.info",
        "org.slf4j.Logger.info",
        "org.slf4j.Logger.debug",
        "org.slf4j.Logger.debug",
        "org.slf4j.Logger.debug",
        "org.slf4j.Logger.debug",
        "org.slf4j.Logger.debug",
        "org.slf4j.Logger.debug",
        "org.slf4j.Logger.info",
        "makeConnectionASync",
        "org.slf4j.Logger.error",
        "org.slf4j.Logger.error",
        "connectToServer",
        "org.slf4j.Logger.debug",
        "connectToServer",
        "java.util.concurrent.ExecutorService.submit",
        "java.util.concurrent.ExecutorService.shutdown",
        "com.netflix.servo.monitor.Counter.increment",
        "org.slf4j.Logger.debug",
        "com.netflix.servo.monitor.Counter.increment",
        "org.slf4j.Logger.debug",
        "sleepBeforeRetry",
        "org.slf4j.Logger.debug",
        "org.slf4j.Logger.error",
        "org.slf4j.Logger.debug",
        "org.slf4j.Logger.debug",
        "getThreadGroup",
        "java.util.concurrent.atomic.AtomicInteger.getAndIncrement",
        "java.util.concurrent.atomic.AtomicInteger.getAndIncrement"
      ]
    },
    "Imports": {
      "ArrayList": "java.util.ArrayList",
      "Collections": "java.util.Collections",
      "List": "java.util.List",
      "Callable": "java.util.concurrent.Callable",
      "CountDownLatch": "java.util.concurrent.CountDownLatch",
      "ExecutorService": "java.util.concurrent.ExecutorService",
      "Future": "java.util.concurrent.Future",
      "LinkedBlockingQueue": "java.util.concurrent.LinkedBlockingQueue",
      "RejectedExecutionException": "java.util.concurrent.RejectedExecutionException",
      "ThreadFactory": "java.util.concurrent.ThreadFactory",
      "ThreadPoolExecutor": "java.util.concurrent.ThreadPoolExecutor",
      "TimeUnit": "java.util.concurrent.TimeUnit",
      "AtomicInteger": "java.util.concurrent.atomic.AtomicInteger",
      "Logger": "org.slf4j.Logger",
      "LoggerFactory": "org.slf4j.LoggerFactory",
      "CommonClientConfigKey": "com.netflix.client.config.CommonClientConfigKey",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "Server": "com.netflix.loadbalancer.Server",
      "Counter": "com.netflix.servo.monitor.Counter",
      "Monitors": "com.netflix.servo.monitor.Monitors",
      "Stopwatch": "com.netflix.servo.monitor.Stopwatch",
      "Timer": "com.netflix.servo.monitor.Timer"
    },
    "FieldTypes": {
      "logger": "org.slf4j.Logger",
      "executorService": "java.util.concurrent.ExecutorService",
      "totalCounter": "com.netflix.servo.monitor.Counter",
      "successCounter": "com.netflix.servo.monitor.Counter",
      "initialPrimeTimer": "com.netflix.servo.monitor.Timer",
      "groupNumber": "java.util.concurrent.atomic.AtomicInteger",
      "threadNumber": "java.util.concurrent.atomic.AtomicInteger"
    }
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\AbstractLoadBalancer.java": {
    "TypeDeclarations": [
      "AbstractLoadBalancer",
      "ServerGroup"
    ],
    "MethodDeclarations": [
      "AbstractLoadBalancer.chooseServer()",
      "AbstractLoadBalancer.getServerList(ServerGroup)",
      "AbstractLoadBalancer.getLoadBalancerStats()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "chooseServer"
      ]
    },
    "Imports": {
      "List": "java.util.List"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\AbstractLoadBalancerPing.java": {
    "TypeDeclarations": [
      "AbstractLoadBalancerPing"
    ],
    "MethodDeclarations": [
      "AbstractLoadBalancerPing.isAlive(Server)",
      "AbstractLoadBalancerPing.setLoadBalancer(AbstractLoadBalancer)",
      "AbstractLoadBalancerPing.getLoadBalancer()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "IClientConfigAware": "com.netflix.client.IClientConfigAware"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\AbstractLoadBalancerRule.java": {
    "TypeDeclarations": [
      "AbstractLoadBalancerRule"
    ],
    "MethodDeclarations": [
      "AbstractLoadBalancerRule.setLoadBalancer(ILoadBalancer)",
      "AbstractLoadBalancerRule.getLoadBalancer()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "IClientConfigAware": "com.netflix.client.IClientConfigAware"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\AbstractServerList.java": {
    "TypeDeclarations": [
      "AbstractServerList"
    ],
    "MethodDeclarations": [
      "AbstractServerList.getFilterImpl(IClientConfig)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "getName"
      ]
    },
    "Imports": {
      "ClientFactory": "com.netflix.client.ClientFactory",
      "IClientConfigAware": "com.netflix.client.IClientConfigAware",
      "ClientException": "com.netflix.client.ClientException",
      "CommonClientConfigKey": "com.netflix.client.config.CommonClientConfigKey",
      "IClientConfig": "com.netflix.client.config.IClientConfig"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\AbstractServerListFilter.java": {
    "TypeDeclarations": [
      "AbstractServerListFilter"
    ],
    "MethodDeclarations": [
      "AbstractServerListFilter.setLoadBalancerStats(LoadBalancerStats)",
      "AbstractServerListFilter.getLoadBalancerStats()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {},
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\AbstractServerPredicate.java": {
    "TypeDeclarations": [
      "AbstractServerPredicate"
    ],
    "MethodDeclarations": [
      "AbstractServerPredicate.alwaysTrue()",
      "AbstractServerPredicate.getLBStats()",
      "AbstractServerPredicate.setLoadBalancerStats(LoadBalancerStats)",
      "AbstractServerPredicate.getServerOnlyPredicate()",
      "AbstractServerPredicate.getEligibleServers(List)",
      "AbstractServerPredicate.getEligibleServers(List, Object)",
      "AbstractServerPredicate.incrementAndGetModulo(BasicType(dimensions=[], name=int))",
      "AbstractServerPredicate.chooseRandomlyAfterFiltering(List)",
      "AbstractServerPredicate.chooseRoundRobinAfterFiltering(List)",
      "AbstractServerPredicate.chooseRandomlyAfterFiltering(List, Object)",
      "AbstractServerPredicate.chooseRoundRobinAfterFiltering(List, Object)",
      "AbstractServerPredicate.ofKeyPredicate(Predicate)",
      "AbstractServerPredicate.ofServerPredicate(Predicate)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "AbstractServerPredicate.setLoadBalancerStats",
        "AbstractServerPredicate.getEligibleServers",
        "AbstractServerPredicate.getServerOnlyPredicate",
        "AbstractServerPredicate.getEligibleServers",
        "AbstractServerPredicate.getEligibleServers",
        "AbstractServerPredicate.incrementAndGetModulo",
        "AbstractServerPredicate.getEligibleServers",
        "AbstractServerPredicate.getEligibleServers",
        "AbstractServerPredicate.incrementAndGetModulo"
      ],
      "Unresolved": [
        "apply",
        "apply",
        "java.util.concurrent.atomic.AtomicInteger.get",
        "java.util.concurrent.atomic.AtomicInteger.compareAndSet",
        "java.util.Random.nextInt",
        "java.util.Random.nextInt"
      ]
    },
    "Imports": {
      "List": "java.util.List",
      "Random": "java.util.Random",
      "AtomicInteger": "java.util.concurrent.atomic.AtomicInteger",
      "Nullable": "javax.annotation.Nullable",
      "Optional": "com.google.common.base.Optional",
      "Predicate": "com.google.common.base.Predicate",
      "ImmutableList": "com.google.common.collect.ImmutableList",
      "Iterables": "com.google.common.collect.Iterables",
      "Lists": "com.google.common.collect.Lists",
      "IClientConfig": "com.netflix.client.config.IClientConfig"
    },
    "FieldTypes": {
      "random": "java.util.Random",
      "nextIndex": "java.util.concurrent.atomic.AtomicInteger",
      "serverOnlyPredicate": "com.google.common.base.Predicate"
    }
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\AvailabilityFilteringRule.java": {
    "TypeDeclarations": [
      "AvailabilityFilteringRule"
    ],
    "MethodDeclarations": [
      "AvailabilityFilteringRule.initWithNiwsConfig(IClientConfig)",
      "AvailabilityFilteringRule.getAvailableServersCount()",
      "AvailabilityFilteringRule.choose(Object)",
      "AvailabilityFilteringRule.getPredicate()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "addFallbackPredicate",
        "build",
        "addFallbackPredicate",
        "build",
        "getLoadBalancer",
        "size"
      ]
    },
    "Imports": {
      "List": "java.util.List",
      "Collections2": "com.google.common.collect.Collections2",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "DataSourceType": "com.netflix.servo.annotations.DataSourceType",
      "Monitor": "com.netflix.servo.annotations.Monitor"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\AvailabilityPredicate.java": {
    "TypeDeclarations": [
      "AvailabilityPredicate"
    ],
    "MethodDeclarations": [
      "AvailabilityPredicate.initDynamicProperty(IClientConfig)",
      "AvailabilityPredicate.getActiveConnectionsLimit()",
      "AvailabilityPredicate.apply(PredicateKey)",
      "AvailabilityPredicate.shouldSkipServer(ServerStats)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "AvailabilityPredicate.initDynamicProperty",
        "AvailabilityPredicate.initDynamicProperty",
        "AvailabilityPredicate.shouldSkipServer",
        "AvailabilityPredicate.getActiveConnectionsLimit"
      ],
      "Unresolved": [
        "com.netflix.client.config.IClientConfigKey.defaultValue",
        "com.netflix.client.config.IClientConfigKey.defaultValue",
        "com.netflix.client.config.IClientConfigKey.defaultValue",
        "com.netflix.client.config.Property.getOrDefault",
        "com.netflix.client.config.Property.getOrDefault",
        "getLBStats",
        "com.netflix.client.config.Property.getOrDefault"
      ]
    },
    "Imports": {
      "Preconditions": "com.google.common.base.Preconditions",
      "CommonClientConfigKey": "com.netflix.client.config.CommonClientConfigKey",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "IClientConfigKey": "com.netflix.client.config.IClientConfigKey",
      "Property": "com.netflix.client.config.Property",
      "Nullable": "javax.annotation.Nullable"
    },
    "FieldTypes": {
      "FILTER_CIRCUIT_TRIPPED": "com.netflix.client.config.IClientConfigKey",
      "DEFAULT_ACTIVE_CONNECTIONS_LIMIT": "com.netflix.client.config.IClientConfigKey",
      "ACTIVE_CONNECTIONS_LIMIT": "com.netflix.client.config.IClientConfigKey",
      "circuitBreakerFiltering": "com.netflix.client.config.Property",
      "defaultActiveConnectionsLimit": "com.netflix.client.config.Property",
      "activeConnectionsLimit": "com.netflix.client.config.Property"
    }
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\BaseLoadBalancer.java": {
    "TypeDeclarations": [
      "BaseLoadBalancer",
      "PingTask",
      "Pinger",
      "SerialPingStrategy"
    ],
    "MethodDeclarations": [
      "BaseLoadBalancer.initWithConfig(IClientConfig, IRule, IPing)",
      "BaseLoadBalancer.initWithConfig(IClientConfig, IRule, IPing, LoadBalancerStats)",
      "BaseLoadBalancer.initWithNiwsConfig(IClientConfig)",
      "BaseLoadBalancer.initWithNiwsConfig(IClientConfig, Factory)",
      "BaseLoadBalancer.createLoadBalancerStatsFromConfig(IClientConfig, Factory)",
      "BaseLoadBalancer.addServerListChangeListener(ServerListChangeListener)",
      "BaseLoadBalancer.removeServerListChangeListener(ServerListChangeListener)",
      "BaseLoadBalancer.addServerStatusChangeListener(ServerStatusChangeListener)",
      "BaseLoadBalancer.removeServerStatusChangeListener(ServerStatusChangeListener)",
      "BaseLoadBalancer.getClientConfig()",
      "BaseLoadBalancer.canSkipPing()",
      "BaseLoadBalancer.setupPingTask()",
      "BaseLoadBalancer.setName(String)",
      "BaseLoadBalancer.getName()",
      "BaseLoadBalancer.getLoadBalancerStats()",
      "BaseLoadBalancer.setLoadBalancerStats(LoadBalancerStats)",
      "BaseLoadBalancer.lockAllServerList(BasicType(dimensions=[], name=boolean))",
      "BaseLoadBalancer.lockUpServerList(BasicType(dimensions=[], name=boolean))",
      "BaseLoadBalancer.setPingInterval(BasicType(dimensions=[], name=int))",
      "BaseLoadBalancer.getPingInterval()",
      "BaseLoadBalancer.setMaxTotalPingTime(BasicType(dimensions=[], name=int))",
      "BaseLoadBalancer.getMaxTotalPingTime()",
      "BaseLoadBalancer.getPing()",
      "BaseLoadBalancer.getRule()",
      "BaseLoadBalancer.isPingInProgress()",
      "BaseLoadBalancer.setPing(IPing)",
      "BaseLoadBalancer.setRule(IRule)",
      "BaseLoadBalancer.getServerCount(BasicType(dimensions=[], name=boolean))",
      "BaseLoadBalancer.addServer(Server)",
      "BaseLoadBalancer.addServers(List)",
      "BaseLoadBalancer.addServers(Object)",
      "BaseLoadBalancer.setServersList(List)",
      "BaseLoadBalancer.setServers(String)",
      "BaseLoadBalancer.getServerByIndex(BasicType(dimensions=[], name=int), BasicType(dimensions=[], name=boolean))",
      "BaseLoadBalancer.getServerList(BasicType(dimensions=[], name=boolean))",
      "BaseLoadBalancer.getReachableServers()",
      "BaseLoadBalancer.getAllServers()",
      "BaseLoadBalancer.getServerList(ServerGroup)",
      "BaseLoadBalancer.cancelPingTask()",
      "PingTask.run()",
      "Pinger.runPinger()",
      "BaseLoadBalancer.notifyServerStatusChangeListener(Collection)",
      "BaseLoadBalancer.createCounter()",
      "BaseLoadBalancer.chooseServer(Object)",
      "BaseLoadBalancer.choose(Object)",
      "BaseLoadBalancer.markServerDown(Server)",
      "BaseLoadBalancer.markServerDown(String)",
      "BaseLoadBalancer.forceQuickPing()",
      "BaseLoadBalancer.toString()",
      "BaseLoadBalancer.init()",
      "BaseLoadBalancer.getPrimeConnections()",
      "BaseLoadBalancer.setPrimeConnections(PrimeConnections)",
      "BaseLoadBalancer.primeCompleted(Server, Throwable)",
      "BaseLoadBalancer.isEnablePrimingConnections()",
      "BaseLoadBalancer.setEnablePrimingConnections(BasicType(dimensions=[], name=boolean))",
      "BaseLoadBalancer.shutdown()",
      "SerialPingStrategy.pingServers(IPing, Server)"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.util.List.add",
        "java.util.List.remove",
        "java.util.List.add",
        "java.util.List.remove",
        "java.lang.equals",
        "java.util.List.size",
        "java.util.List.size",
        "java.util.List.size",
        "java.util.List.contains",
        "java.util.List.get",
        "java.util.List.get",
        "java.util.List.toArray",
        "java.util.List.size",
        "java.util.List.isEmpty",
        "java.lang.toString"
      ],
      "UserDefined": [
        "java.util.Collections.singleton"
      ],
      "Unresolved": [
        "setRule",
        "setupPingTask",
        "org.slf4j.Logger.debug",
        "setRule",
        "setupPingTask",
        "init",
        "initWithNiwsConfig",
        "initWithConfig",
        "createLoadBalancerStatsFromConfig",
        "initWithConfig",
        "createLoadBalancerStatsFromConfig",
        "setPingInterval",
        "setMaxTotalPingTime",
        "setRule",
        "setPing",
        "setLoadBalancerStats",
        "org.slf4j.Logger.info",
        "setEnablePrimingConnections",
        "getName",
        "setPrimeConnections",
        "init",
        "initWithNiwsConfig",
        "createLoadBalancerStatsFromConfig",
        "initWithConfig",
        "getName",
        "getName",
        "canSkipPing",
        "java.util.Timer.cancel",
        "java.util.Timer.schedule",
        "forceQuickPing",
        "java.util.concurrent.locks.ReadWriteLock.writeLock",
        "java.util.concurrent.locks.ReadWriteLock.readLock",
        "java.util.concurrent.locks.ReadWriteLock.writeLock",
        "java.util.concurrent.locks.ReadWriteLock.readLock",
        "org.slf4j.Logger.isDebugEnabled",
        "org.slf4j.Logger.debug",
        "setupPingTask",
        "org.slf4j.Logger.debug",
        "java.util.concurrent.atomic.AtomicBoolean.get",
        "setupPingTask",
        "java.util.Timer.cancel",
        "getLoadBalancer",
        "setLoadBalancer",
        "setServersList",
        "org.slf4j.Logger.error",
        "setServersList",
        "org.slf4j.Logger.error",
        "setServersList",
        "org.slf4j.Logger.error",
        "java.util.concurrent.locks.ReadWriteLock.writeLock",
        "org.slf4j.Logger.debug",
        "org.slf4j.Logger.debug",
        "java.util.List.equals",
        "org.slf4j.Logger.error",
        "isEnablePrimingConnections",
        "com.netflix.client.PrimeConnections.primeConnectionsAsync",
        "canSkipPing",
        "forceQuickPing",
        "setServersList",
        "org.slf4j.Logger.error",
        "getReachableServers",
        "getAllServers",
        "java.util.Timer.cancel",
        "runPinger",
        "org.slf4j.Logger.error",
        "java.util.concurrent.atomic.AtomicBoolean.compareAndSet",
        "java.util.concurrent.locks.ReadWriteLock.readLock",
        "org.slf4j.Logger.debug",
        "java.util.concurrent.locks.ReadWriteLock.writeLock",
        "notifyServerStatusChangeListener",
        "java.util.concurrent.atomic.AtomicBoolean.set",
        "org.slf4j.Logger.error",
        "createCounter",
        "com.netflix.servo.monitor.Counter.increment",
        "org.slf4j.Logger.warn",
        "org.slf4j.Logger.warn",
        "org.slf4j.Logger.error",
        "notifyServerStatusChangeListener",
        "java.util.concurrent.locks.ReadWriteLock.writeLock",
        "org.slf4j.Logger.error",
        "notifyServerStatusChangeListener",
        "canSkipPing",
        "org.slf4j.Logger.debug",
        "runPinger",
        "org.slf4j.Logger.error",
        "append",
        "getName",
        "append",
        "append",
        "append",
        "append",
        "append",
        "getRule",
        "com.netflix.client.PrimeConnections.primeConnections",
        "getReachableServers",
        "cancelPingTask",
        "com.netflix.client.PrimeConnections.shutdown",
        "getRule",
        "org.slf4j.Logger.debug",
        "org.slf4j.Logger.error"
      ]
    },
    "Imports": {
      "singleton": "java.util.Collections.singleton",
      "ImmutableList": "com.google.common.collect.ImmutableList",
      "ClientFactory": "com.netflix.client.ClientFactory",
      "IClientConfigAware": "com.netflix.client.IClientConfigAware",
      "PrimeConnections": "com.netflix.client.PrimeConnections",
      "CommonClientConfigKey": "com.netflix.client.config.CommonClientConfigKey",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "DataSourceType": "com.netflix.servo.annotations.DataSourceType",
      "Monitor": "com.netflix.servo.annotations.Monitor",
      "Counter": "com.netflix.servo.monitor.Counter",
      "Monitors": "com.netflix.servo.monitor.Monitors",
      "ShutdownEnabledTimer": "com.netflix.util.concurrent.ShutdownEnabledTimer",
      "Logger": "org.slf4j.Logger",
      "LoggerFactory": "org.slf4j.LoggerFactory",
      "ArrayList": "java.util.ArrayList",
      "Collection": "java.util.Collection",
      "Collections": "java.util.Collections",
      "Comparator": "java.util.Comparator",
      "List": "java.util.List",
      "Timer": "java.util.Timer",
      "TimerTask": "java.util.TimerTask",
      "CopyOnWriteArrayList": "java.util.concurrent.CopyOnWriteArrayList",
      "AtomicBoolean": "java.util.concurrent.atomic.AtomicBoolean",
      "Lock": "java.util.concurrent.locks.Lock",
      "ReadWriteLock": "java.util.concurrent.locks.ReadWriteLock",
      "ReentrantReadWriteLock": "java.util.concurrent.locks.ReentrantReadWriteLock"
    },
    "FieldTypes": {
      "logger": "org.slf4j.Logger",
      "allServerList": "java.util.List",
      "upServerList": "java.util.List",
      "allServerLock": "java.util.concurrent.locks.ReadWriteLock",
      "upServerLock": "java.util.concurrent.locks.ReadWriteLock",
      "lbTimer": "java.util.Timer",
      "serverComparator": "java.util.Comparator",
      "pingInProgress": "java.util.concurrent.atomic.AtomicBoolean",
      "counter": "com.netflix.servo.monitor.Counter",
      "primeConnections": "com.netflix.client.PrimeConnections",
      "config": "com.netflix.client.config.IClientConfig",
      "changeListeners": "java.util.List",
      "serverStatusListeners": "java.util.List"
    }
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\BestAvailableRule.java": {
    "TypeDeclarations": [
      "BestAvailableRule"
    ],
    "MethodDeclarations": [
      "BestAvailableRule.choose(Object)",
      "BestAvailableRule.setLoadBalancer(ILoadBalancer)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "getLoadBalancer",
        "getAllServers"
      ]
    },
    "Imports": {
      "List": "java.util.List"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\ClientConfigEnabledRoundRobinRule.java": {
    "TypeDeclarations": [
      "ClientConfigEnabledRoundRobinRule"
    ],
    "MethodDeclarations": [
      "ClientConfigEnabledRoundRobinRule.initWithNiwsConfig(IClientConfig)",
      "ClientConfigEnabledRoundRobinRule.setLoadBalancer(ILoadBalancer)",
      "ClientConfigEnabledRoundRobinRule.choose(Object)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "IClientConfig": "com.netflix.client.config.IClientConfig"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\CompositePredicate.java": {
    "TypeDeclarations": [
      "CompositePredicate",
      "Builder"
    ],
    "MethodDeclarations": [
      "CompositePredicate.apply(PredicateKey)",
      "Builder.addFallbackPredicate(AbstractServerPredicate)",
      "Builder.setFallbackThresholdAsMinimalFilteredNumberOfServers(BasicType(dimensions=[], name=int))",
      "Builder.setFallbackThresholdAsMinimalFilteredPercentage(BasicType(dimensions=[], name=float))",
      "Builder.build()",
      "CompositePredicate.withPredicates(AbstractServerPredicate)",
      "CompositePredicate.withPredicate(AbstractServerPredicate)",
      "CompositePredicate.getEligibleServers(List, Object)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "com.google.common.base.Predicates"
      ],
      "Unresolved": [
        "java.util.List.iterator"
      ]
    },
    "Imports": {
      "Iterator": "java.util.Iterator",
      "List": "java.util.List",
      "Nullable": "javax.annotation.Nullable",
      "Predicate": "com.google.common.base.Predicate",
      "Predicates": "com.google.common.base.Predicates",
      "Lists": "com.google.common.collect.Lists"
    },
    "FieldTypes": {
      "fallbacks": "java.util.List"
    }
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\ConfigurationBasedServerList.java": {
    "TypeDeclarations": [
      "ConfigurationBasedServerList"
    ],
    "MethodDeclarations": [
      "ConfigurationBasedServerList.getInitialListOfServers()",
      "ConfigurationBasedServerList.getUpdatedListOfServers()",
      "ConfigurationBasedServerList.initWithNiwsConfig(IClientConfig)",
      "ConfigurationBasedServerList.derive(String)",
      "ConfigurationBasedServerList.toString()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "ConfigurationBasedServerList.getUpdatedListOfServers",
        "ConfigurationBasedServerList.derive",
        "ConfigurationBasedServerList.getUpdatedListOfServers"
      ],
      "Unresolved": [
        "com.netflix.client.config.IClientConfig.get"
      ]
    },
    "Imports": {
      "List": "java.util.List",
      "Strings": "com.google.common.base.Strings",
      "Lists": "com.google.common.collect.Lists",
      "CommonClientConfigKey": "com.netflix.client.config.CommonClientConfigKey",
      "IClientConfig": "com.netflix.client.config.IClientConfig"
    },
    "FieldTypes": {
      "clientConfig": "com.netflix.client.config.IClientConfig"
    }
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\DummyPing.java": {
    "TypeDeclarations": [
      "DummyPing"
    ],
    "MethodDeclarations": [
      "DummyPing.isAlive(Server)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "IClientConfig": "com.netflix.client.config.IClientConfig"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\DynamicServerListLoadBalancer.java": {
    "TypeDeclarations": [
      "DynamicServerListLoadBalancer"
    ],
    "MethodDeclarations": [
      "DynamicServerListLoadBalancer.initWithNiwsConfig(IClientConfig)",
      "DynamicServerListLoadBalancer.initWithNiwsConfig(IClientConfig, Factory)",
      "DynamicServerListLoadBalancer.restOfInit(IClientConfig)",
      "DynamicServerListLoadBalancer.setServersList(List)",
      "DynamicServerListLoadBalancer.setServerListForZones(Map)",
      "DynamicServerListLoadBalancer.getServerListImpl()",
      "DynamicServerListLoadBalancer.setServerListImpl(ServerList)",
      "DynamicServerListLoadBalancer.getFilter()",
      "DynamicServerListLoadBalancer.setFilter(ServerListFilter)",
      "DynamicServerListLoadBalancer.getServerListUpdater()",
      "DynamicServerListLoadBalancer.setServerListUpdater(ServerListUpdater)",
      "DynamicServerListLoadBalancer.forceQuickPing()",
      "DynamicServerListLoadBalancer.enableAndInitLearnNewServersFeature()",
      "DynamicServerListLoadBalancer.getIdentifier()",
      "DynamicServerListLoadBalancer.stopServerListRefreshing()",
      "DynamicServerListLoadBalancer.updateListOfServers()",
      "DynamicServerListLoadBalancer.updateAllServerList(List)",
      "DynamicServerListLoadBalancer.toString()",
      "DynamicServerListLoadBalancer.shutdown()",
      "DynamicServerListLoadBalancer.getLastUpdate()",
      "DynamicServerListLoadBalancer.getDurationSinceLastUpdateMs()",
      "DynamicServerListLoadBalancer.getNumberMissedCycles()",
      "DynamicServerListLoadBalancer.getCoreThreads()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "DynamicServerListLoadBalancer.updateListOfServers",
        "DynamicServerListLoadBalancer.restOfInit",
        "DynamicServerListLoadBalancer.initWithNiwsConfig",
        "DynamicServerListLoadBalancer.initWithNiwsConfig",
        "DynamicServerListLoadBalancer.restOfInit",
        "DynamicServerListLoadBalancer.enableAndInitLearnNewServersFeature",
        "DynamicServerListLoadBalancer.updateListOfServers",
        "DynamicServerListLoadBalancer.toString",
        "DynamicServerListLoadBalancer.setServerListForZones",
        "DynamicServerListLoadBalancer.getIdentifier",
        "DynamicServerListLoadBalancer.getIdentifier",
        "DynamicServerListLoadBalancer.updateAllServerList",
        "DynamicServerListLoadBalancer.setServersList",
        "DynamicServerListLoadBalancer.stopServerListRefreshing"
      ],
      "Unresolved": [
        "getLoadBalancerStats",
        "isEnablePrimingConnections",
        "setEnablePrimingConnections",
        "getPrimeConnections",
        "getPrimeConnections",
        "primeConnections",
        "getReachableServers",
        "setEnablePrimingConnections",
        "org.slf4j.Logger.info",
        "getLoadBalancerStats",
        "getSingleServerStat",
        "org.slf4j.Logger.debug",
        "getLoadBalancerStats",
        "updateZoneServerMapping",
        "org.slf4j.Logger.info",
        "getSimpleName",
        "getClientConfig",
        "getClientName",
        "org.slf4j.Logger.debug",
        "org.slf4j.Logger.debug",
        "java.util.concurrent.atomic.AtomicBoolean.compareAndSet",
        "java.util.concurrent.atomic.AtomicBoolean.set"
      ]
    },
    "Imports": {
      "VisibleForTesting": "com.google.common.annotations.VisibleForTesting",
      "ClientFactory": "com.netflix.client.ClientFactory",
      "CommonClientConfigKey": "com.netflix.client.config.CommonClientConfigKey",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "DataSourceType": "com.netflix.servo.annotations.DataSourceType",
      "Monitor": "com.netflix.servo.annotations.Monitor",
      "Logger": "org.slf4j.Logger",
      "LoggerFactory": "org.slf4j.LoggerFactory",
      "ArrayList": "java.util.ArrayList",
      "HashMap": "java.util.HashMap",
      "List": "java.util.List",
      "Map": "java.util.Map",
      "AtomicBoolean": "java.util.concurrent.atomic.AtomicBoolean"
    },
    "FieldTypes": {
      "LOGGER": "org.slf4j.Logger",
      "serverListUpdateInProgress": "java.util.concurrent.atomic.AtomicBoolean"
    }
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\ILoadBalancer.java": {
    "TypeDeclarations": [
      "ILoadBalancer"
    ],
    "MethodDeclarations": [
      "ILoadBalancer.addServers(List)",
      "ILoadBalancer.chooseServer(Object)",
      "ILoadBalancer.markServerDown(Server)",
      "ILoadBalancer.getServerList(BasicType(dimensions=[], name=boolean))",
      "ILoadBalancer.getReachableServers()",
      "ILoadBalancer.getAllServers()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "List": "java.util.List"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\InterruptTask.java": {
    "TypeDeclarations": [
      "InterruptTask"
    ],
    "MethodDeclarations": [
      "InterruptTask.cancel()",
      "InterruptTask.run()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "java.util.Timer.schedule",
        "java.util.Timer.schedule"
      ]
    },
    "Imports": {
      "Timer": "java.util.Timer",
      "TimerTask": "java.util.TimerTask"
    },
    "FieldTypes": {
      "timer": "java.util.Timer"
    }
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\IPing.java": {
    "TypeDeclarations": [
      "IPing"
    ],
    "MethodDeclarations": [
      "IPing.isAlive(Server)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {},
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\IPingStrategy.java": {
    "TypeDeclarations": [
      "IPingStrategy"
    ],
    "MethodDeclarations": [
      "IPingStrategy.pingServers(IPing, Server)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {},
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\IRule.java": {
    "TypeDeclarations": [
      "IRule"
    ],
    "MethodDeclarations": [
      "IRule.choose(Object)",
      "IRule.setLoadBalancer(ILoadBalancer)",
      "IRule.getLoadBalancer()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {},
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\LoadBalancerBuilder.java": {
    "TypeDeclarations": [
      "LoadBalancerBuilder"
    ],
    "MethodDeclarations": [
      "LoadBalancerBuilder.newBuilder()",
      "LoadBalancerBuilder.withFactory(IClientConfigAware)",
      "LoadBalancerBuilder.withClientConfig(IClientConfig)",
      "LoadBalancerBuilder.withRule(IRule)",
      "LoadBalancerBuilder.withPing(IPing)",
      "LoadBalancerBuilder.withDynamicServerList(ServerList)",
      "LoadBalancerBuilder.withServerListFilter(ServerListFilter)",
      "LoadBalancerBuilder.withServerListUpdater(ServerListUpdater)",
      "LoadBalancerBuilder.buildFixedServerListLoadBalancer(List)",
      "LoadBalancerBuilder.createRuleFromConfig(IClientConfig, IClientConfigAware)",
      "LoadBalancerBuilder.createServerListUpdaterFromConfig(IClientConfig, IClientConfigAware)",
      "LoadBalancerBuilder.createServerListFromConfig(IClientConfig, IClientConfigAware)",
      "LoadBalancerBuilder.buildDynamicServerListLoadBalancer()",
      "LoadBalancerBuilder.buildDynamicServerListLoadBalancerWithUpdater()",
      "LoadBalancerBuilder.buildLoadBalancerFromConfigWithReflection()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "LoadBalancerBuilder.createRuleFromConfig",
        "LoadBalancerBuilder.createServerListFromConfig",
        "LoadBalancerBuilder.createRuleFromConfig",
        "LoadBalancerBuilder.createServerListFromConfig",
        "LoadBalancerBuilder.createRuleFromConfig",
        "LoadBalancerBuilder.createServerListUpdaterFromConfig"
      ],
      "Unresolved": [
        "newConfig",
        "com.netflix.client.config.IClientConfig.getOrDefault",
        "com.netflix.client.IClientConfigAware.create",
        "com.netflix.client.config.IClientConfig.getOrDefault",
        "com.netflix.client.IClientConfigAware.create",
        "com.netflix.client.config.IClientConfig.get",
        "com.netflix.client.IClientConfigAware.create",
        "com.netflix.client.config.IClientConfig.get",
        "com.netflix.client.IClientConfigAware.create"
      ]
    },
    "Imports": {
      "ClientFactory": "com.netflix.client.ClientFactory",
      "IClientConfigAware": "com.netflix.client.IClientConfigAware",
      "ClientConfigFactory": "com.netflix.client.config.ClientConfigFactory",
      "CommonClientConfigKey": "com.netflix.client.config.CommonClientConfigKey",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "IClientConfigKey": "com.netflix.client.config.IClientConfigKey",
      "List": "java.util.List"
    },
    "FieldTypes": {
      "config": "com.netflix.client.config.IClientConfig",
      "factory": "com.netflix.client.IClientConfigAware"
    }
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\LoadBalancerContext.java": {
    "TypeDeclarations": [
      "LoadBalancerContext"
    ],
    "MethodDeclarations": [
      "LoadBalancerContext.initWithNiwsConfig(IClientConfig)",
      "LoadBalancerContext.getExecuteTracer()",
      "LoadBalancerContext.getClientName()",
      "LoadBalancerContext.getLoadBalancer()",
      "LoadBalancerContext.setLoadBalancer(ILoadBalancer)",
      "LoadBalancerContext.getMaxAutoRetriesNextServer()",
      "LoadBalancerContext.setMaxAutoRetriesNextServer(BasicType(dimensions=[], name=int))",
      "LoadBalancerContext.getMaxAutoRetries()",
      "LoadBalancerContext.setMaxAutoRetries(BasicType(dimensions=[], name=int))",
      "LoadBalancerContext.getDeepestCause(Throwable)",
      "LoadBalancerContext.isPresentAsCause(Throwable, Class)",
      "LoadBalancerContext.isPresentAsCauseHelper(Throwable, Class)",
      "LoadBalancerContext.generateNIWSException(String, Throwable)",
      "LoadBalancerContext.isPresentAsCause(Throwable, Class, String)",
      "LoadBalancerContext.generateTimeoutNIWSException(String, Throwable)",
      "LoadBalancerContext.recordStats(ServerStats, BasicType(dimensions=[], name=long))",
      "LoadBalancerContext.noteRequestCompletion(ServerStats, Object, Throwable, BasicType(dimensions=[], name=long))",
      "LoadBalancerContext.noteRequestCompletion(ServerStats, Object, Throwable, BasicType(dimensions=[], name=long), RetryHandler)",
      "LoadBalancerContext.noteError(ServerStats, ClientRequest, Throwable, BasicType(dimensions=[], name=long))",
      "LoadBalancerContext.noteResponse(ServerStats, ClientRequest, Object, BasicType(dimensions=[], name=long))",
      "LoadBalancerContext.noteOpenConnection(ServerStats)",
      "LoadBalancerContext.deriveSchemeAndPortFromPartialUri(URI)",
      "LoadBalancerContext.getDefaultPortFromScheme(String)",
      "LoadBalancerContext.deriveHostAndPortFromVipAddress(String)",
      "LoadBalancerContext.isVipRecognized(String)",
      "LoadBalancerContext.getServerFromLoadBalancer(URI, Object)",
      "LoadBalancerContext.reconstructURIWithServer(Server, URI)",
      "LoadBalancerContext.getRetriesNextServer(IClientConfig)",
      "LoadBalancerContext.getServerStats(Server)",
      "LoadBalancerContext.getNumberRetriesOnSameServer(IClientConfig)",
      "LoadBalancerContext.handleSameServerRetry(Server, BasicType(dimensions=[], name=int), BasicType(dimensions=[], name=int), Throwable)",
      "LoadBalancerContext.getRetryHandler()",
      "LoadBalancerContext.setRetryHandler(RetryHandler)",
      "LoadBalancerContext.isOkToRetryOnAllOperations()",
      "LoadBalancerContext.setOkToRetryOnAllOperations(BasicType(dimensions=[], name=boolean))"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "LoadBalancerContext.initWithNiwsConfig",
        "LoadBalancerContext.getExecuteTracer",
        "LoadBalancerContext.isPresentAsCauseHelper",
        "LoadBalancerContext.isPresentAsCause",
        "LoadBalancerContext.generateTimeoutNIWSException",
        "LoadBalancerContext.isPresentAsCauseHelper",
        "LoadBalancerContext.isPresentAsCause",
        "LoadBalancerContext.getDeepestCause",
        "LoadBalancerContext.getDeepestCause",
        "LoadBalancerContext.noteRequestCompletion",
        "LoadBalancerContext.recordStats",
        "LoadBalancerContext.getRetryHandler",
        "LoadBalancerContext.recordStats",
        "LoadBalancerContext.getRetryHandler",
        "LoadBalancerContext.recordStats",
        "LoadBalancerContext.getRetryHandler",
        "LoadBalancerContext.getDefaultPortFromScheme",
        "LoadBalancerContext.deriveSchemeAndPortFromPartialUri",
        "LoadBalancerContext.getLoadBalancer",
        "LoadBalancerContext.deriveHostAndPortFromVipAddress",
        "LoadBalancerContext.isVipRecognized",
        "LoadBalancerContext.deriveSchemeAndPortFromPartialUri",
        "LoadBalancerContext.getLoadBalancer"
      ],
      "Unresolved": [
        "isAssignableFrom",
        "contains",
        "getMessage",
        "getMessage",
        "org.slf4j.Logger.error",
        "org.slf4j.Logger.error",
        "org.slf4j.Logger.error",
        "org.slf4j.Logger.error",
        "org.slf4j.Logger.debug",
        "org.slf4j.Logger.debug",
        "org.slf4j.Logger.debug",
        "org.slf4j.Logger.debug",
        "first",
        "append",
        "append",
        "append",
        "append",
        "append",
        "org.slf4j.Logger.warn",
        "org.slf4j.Logger.debug"
      ]
    },
    "Imports": {
      "Strings": "com.google.common.base.Strings",
      "ClientException": "com.netflix.client.ClientException",
      "ClientRequest": "com.netflix.client.ClientRequest",
      "DefaultLoadBalancerRetryHandler": "com.netflix.client.DefaultLoadBalancerRetryHandler",
      "IClientConfigAware": "com.netflix.client.IClientConfigAware",
      "RetryHandler": "com.netflix.client.RetryHandler",
      "CommonClientConfigKey": "com.netflix.client.config.CommonClientConfigKey",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "Monitors": "com.netflix.servo.monitor.Monitors",
      "Timer": "com.netflix.servo.monitor.Timer",
      "Pair": "com.netflix.util.Pair",
      "StringUtils": "org.apache.commons.lang.StringUtils",
      "Logger": "org.slf4j.Logger",
      "LoggerFactory": "org.slf4j.LoggerFactory",
      "Nullable": "javax.annotation.Nullable",
      "URI": "java.net.URI",
      "URISyntaxException": "java.net.URISyntaxException",
      "TimeUnit": "java.util.concurrent.TimeUnit"
    },
    "FieldTypes": {
      "logger": "org.slf4j.Logger",
      "defaultRetryHandler": "com.netflix.client.RetryHandler",
      "tracer": "com.netflix.servo.monitor.Timer"
    }
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\LoadBalancerStats.java": {
    "TypeDeclarations": [
      "LoadBalancerStats"
    ],
    "MethodDeclarations": [
      "LoadBalancerStats.createServerStats(Server)",
      "LoadBalancerStats.initWithNiwsConfig(IClientConfig)",
      "LoadBalancerStats.getName()",
      "LoadBalancerStats.setName(String)",
      "LoadBalancerStats.getConnectionFailureCountThreshold()",
      "LoadBalancerStats.getCircuitTrippedTimeoutFactor()",
      "LoadBalancerStats.getCircuitTripMaxTimeoutSeconds()",
      "LoadBalancerStats.getActiveRequestsCountTimeout()",
      "LoadBalancerStats.updateServerList(List)",
      "LoadBalancerStats.addServer(Server)",
      "LoadBalancerStats.noteResponseTime(Server, BasicType(dimensions=[], name=double))",
      "LoadBalancerStats.getServerStats(Server)",
      "LoadBalancerStats.incrementActiveRequestsCount(Server)",
      "LoadBalancerStats.decrementActiveRequestsCount(Server)",
      "LoadBalancerStats.getZoneStats(String)",
      "LoadBalancerStats.isCircuitBreakerTripped(Server)",
      "LoadBalancerStats.incrementSuccessiveConnectionFailureCount(Server)",
      "LoadBalancerStats.clearSuccessiveConnectionFailureCount(Server)",
      "LoadBalancerStats.incrementNumRequests(Server)",
      "LoadBalancerStats.incrementZoneCounter(Server)",
      "LoadBalancerStats.updateZoneServerMapping(Map)",
      "LoadBalancerStats.getInstanceCount(String)",
      "LoadBalancerStats.getActiveRequestsCount(String)",
      "LoadBalancerStats.getActiveRequestsPerServer(String)",
      "LoadBalancerStats.getZoneSnapshot(String)",
      "LoadBalancerStats.getZoneSnapshot(List)",
      "LoadBalancerStats.getCircuitBreakerTrippedCount(String)",
      "LoadBalancerStats.getCircuitBreakerTrippedCount()",
      "LoadBalancerStats.getMeasuredZoneHits(String)",
      "LoadBalancerStats.getCongestionRatePercentage(String)",
      "LoadBalancerStats.getAvailableZones()",
      "LoadBalancerStats.getSingleServerStat(Server)",
      "LoadBalancerStats.getServerStats()",
      "LoadBalancerStats.getZoneStats()",
      "LoadBalancerStats.toString()",
      "LoadBalancerStats.getSortedServerStats(Collection)"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.util.Map.get",
        "java.util.Map.put",
        "java.util.Map.get",
        "java.util.Map.get",
        "java.util.Map.get",
        "java.util.Map.keySet",
        "java.util.Map.get",
        "java.util.Map.get",
        "java.util.Map.keySet"
      ],
      "UserDefined": [
        "LoadBalancerStats.createServerStats",
        "LoadBalancerStats.addServer",
        "LoadBalancerStats.createServerStats",
        "LoadBalancerStats.getServerStats",
        "LoadBalancerStats.createServerStats",
        "LoadBalancerStats.getServerStats",
        "LoadBalancerStats.getServerStats",
        "LoadBalancerStats.getName",
        "LoadBalancerStats.getServerStats",
        "LoadBalancerStats.getServerStats",
        "LoadBalancerStats.getServerStats",
        "LoadBalancerStats.getServerStats",
        "LoadBalancerStats.getZoneStats",
        "LoadBalancerStats.getZoneStats",
        "LoadBalancerStats.getZoneSnapshot",
        "LoadBalancerStats.getActiveRequestsCount",
        "LoadBalancerStats.getZoneSnapshot",
        "LoadBalancerStats.getZoneSnapshot",
        "LoadBalancerStats.getSingleServerStat",
        "LoadBalancerStats.getZoneSnapshot",
        "LoadBalancerStats.getCircuitBreakerTrippedCount",
        "LoadBalancerStats.getSingleServerStat",
        "LoadBalancerStats.getSingleServerStat",
        "LoadBalancerStats.getServerStats",
        "LoadBalancerStats.getSortedServerStats",
        "LoadBalancerStats.toString",
        "LoadBalancerStats.getServerStats"
      ],
      "Unresolved": [
        "com.netflix.client.config.IClientConfigKey.defaultValue",
        "com.netflix.client.config.IClientConfigKey.defaultValue",
        "com.netflix.client.config.IClientConfigKey.defaultValue",
        "com.netflix.client.config.IClientConfigKey.defaultValue",
        "expireAfterAccess",
        "removalListener",
        "close",
        "build",
        "fallbackWith",
        "com.netflix.client.config.IClientConfigKey.format",
        "fallbackWith",
        "com.netflix.client.config.IClientConfigKey.format",
        "fallbackWith",
        "com.netflix.client.config.IClientConfigKey.format",
        "com.google.common.cache.LoadingCache.get",
        "com.google.common.cache.LoadingCache.asMap",
        "putIfAbsent",
        "com.google.common.cache.LoadingCache.get",
        "com.google.common.cache.LoadingCache.asMap",
        "putIfAbsent",
        "com.google.common.cache.LoadingCache.asMap",
        "get",
        "incrementCounter",
        "getLoadPerServer",
        "getCircuitTrippedCount",
        "com.google.common.cache.LoadingCache.asMap",
        "java.util.Map.toString",
        "values"
      ]
    },
    "Imports": {
      "Preconditions": "com.google.common.base.Preconditions",
      "CacheBuilder": "com.google.common.cache.CacheBuilder",
      "CacheLoader": "com.google.common.cache.CacheLoader",
      "LoadingCache": "com.google.common.cache.LoadingCache",
      "RemovalListener": "com.google.common.cache.RemovalListener",
      "IClientConfigAware": "com.netflix.client.IClientConfigAware",
      "ClientConfigFactory": "com.netflix.client.config.ClientConfigFactory",
      "CommonClientConfigKey": "com.netflix.client.config.CommonClientConfigKey",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "IClientConfigKey": "com.netflix.client.config.IClientConfigKey",
      "UnboxedIntProperty": "com.netflix.client.config.UnboxedIntProperty",
      "DataSourceType": "com.netflix.servo.annotations.DataSourceType",
      "Monitor": "com.netflix.servo.annotations.Monitor",
      "Monitors": "com.netflix.servo.monitor.Monitors",
      "ArrayList": "java.util.ArrayList",
      "Collection": "java.util.Collection",
      "Collections": "java.util.Collections",
      "Comparator": "java.util.Comparator",
      "List": "java.util.List",
      "Map": "java.util.Map",
      "Set": "java.util.Set",
      "ConcurrentHashMap": "java.util.concurrent.ConcurrentHashMap",
      "ExecutionException": "java.util.concurrent.ExecutionException",
      "TimeUnit": "java.util.concurrent.TimeUnit"
    },
    "FieldTypes": {
      "ACTIVE_REQUESTS_COUNT_TIMEOUT": "com.netflix.client.config.IClientConfigKey",
      "CONNECTION_FAILURE_COUNT_THRESHOLD": "com.netflix.client.config.IClientConfigKey",
      "CIRCUIT_TRIP_TIMEOUT_FACTOR_SECONDS": "com.netflix.client.config.IClientConfigKey",
      "CIRCUIT_TRIP_MAX_TIMEOUT_SECONDS": "com.netflix.client.config.IClientConfigKey",
      "DEFAULT_CONNECTION_FAILURE_COUNT_THRESHOLD": "com.netflix.client.config.IClientConfigKey",
      "DEFAULT_CIRCUIT_TRIP_TIMEOUT_FACTOR_SECONDS": "com.netflix.client.config.IClientConfigKey",
      "DEFAULT_CIRCUIT_TRIP_MAX_TIMEOUT_SECONDS": "com.netflix.client.config.IClientConfigKey",
      "zoneStatsMap": "java.util.Map",
      "upServerListZoneMap": "java.util.Map",
      "connectionFailureThreshold": "com.netflix.client.config.UnboxedIntProperty",
      "circuitTrippedTimeoutFactor": "com.netflix.client.config.UnboxedIntProperty",
      "maxCircuitTrippedTimeout": "com.netflix.client.config.UnboxedIntProperty",
      "activeRequestsCountTimeout": "com.netflix.client.config.UnboxedIntProperty",
      "serverStatsCache": "com.google.common.cache.LoadingCache",
      "serverStatsComparator": "java.util.Comparator"
    }
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\NoOpLoadBalancer.java": {
    "TypeDeclarations": [
      "NoOpLoadBalancer"
    ],
    "MethodDeclarations": [
      "NoOpLoadBalancer.addServers(List)",
      "NoOpLoadBalancer.chooseServer(Object)",
      "NoOpLoadBalancer.getLoadBalancerStats()",
      "NoOpLoadBalancer.getServerList(ServerGroup)",
      "NoOpLoadBalancer.markServerDown(Server)",
      "NoOpLoadBalancer.getServerList(BasicType(dimensions=[], name=boolean))",
      "NoOpLoadBalancer.getReachableServers()",
      "NoOpLoadBalancer.getAllServers()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "org.slf4j.Logger.info",
        "org.slf4j.Logger.info"
      ]
    },
    "Imports": {
      "Collections": "java.util.Collections",
      "List": "java.util.List",
      "Logger": "org.slf4j.Logger",
      "LoggerFactory": "org.slf4j.LoggerFactory"
    },
    "FieldTypes": {
      "logger": "org.slf4j.Logger"
    }
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\NoOpPing.java": {
    "TypeDeclarations": [
      "NoOpPing"
    ],
    "MethodDeclarations": [
      "NoOpPing.isAlive(Server)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {},
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\PingConstant.java": {
    "TypeDeclarations": [
      "PingConstant"
    ],
    "MethodDeclarations": [
      "PingConstant.setConstant(String)",
      "PingConstant.setConstant(BasicType(dimensions=[], name=boolean))",
      "PingConstant.getConstant()",
      "PingConstant.isAlive(Server)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {},
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\PollingServerListUpdater.java": {
    "TypeDeclarations": [
      "PollingServerListUpdater",
      "LazyHolder"
    ],
    "MethodDeclarations": [
      "PollingServerListUpdater.getRefreshExecutor()",
      "PollingServerListUpdater.start(UpdateAction)",
      "PollingServerListUpdater.stop()",
      "PollingServerListUpdater.getLastUpdate()",
      "PollingServerListUpdater.getDurationSinceLastUpdateMs()",
      "PollingServerListUpdater.getNumberMissedCycles()",
      "PollingServerListUpdater.getCoreThreads()",
      "PollingServerListUpdater.getRefreshIntervalMs(IClientConfig)"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.lang.toString"
      ],
      "UserDefined": [],
      "Unresolved": [
        "setNameFormat",
        "setDaemon",
        "build",
        "getRefreshIntervalMs",
        "java.util.concurrent.atomic.AtomicBoolean.compareAndSet",
        "java.util.concurrent.atomic.AtomicBoolean.get",
        "java.util.concurrent.ScheduledFuture.cancel",
        "org.slf4j.Logger.warn",
        "getRefreshExecutor",
        "scheduleWithFixedDelay",
        "org.slf4j.Logger.info",
        "java.util.concurrent.atomic.AtomicBoolean.compareAndSet",
        "java.util.concurrent.ScheduledFuture.cancel",
        "org.slf4j.Logger.info",
        "java.util.concurrent.atomic.AtomicBoolean.get"
      ]
    },
    "Imports": {
      "ThreadFactoryBuilder": "com.google.common.util.concurrent.ThreadFactoryBuilder",
      "CommonClientConfigKey": "com.netflix.client.config.CommonClientConfigKey",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "Logger": "org.slf4j.Logger",
      "LoggerFactory": "org.slf4j.LoggerFactory",
      "Date": "java.util.Date",
      "Executors": "java.util.concurrent.Executors",
      "ScheduledExecutorService": "java.util.concurrent.ScheduledExecutorService",
      "ScheduledFuture": "java.util.concurrent.ScheduledFuture",
      "TimeUnit": "java.util.concurrent.TimeUnit",
      "AtomicBoolean": "java.util.concurrent.atomic.AtomicBoolean"
    },
    "FieldTypes": {
      "logger": "org.slf4j.Logger",
      "_serverListRefreshExecutor": "java.util.concurrent.ScheduledExecutorService",
      "isActive": "java.util.concurrent.atomic.AtomicBoolean",
      "scheduledFuture": "java.util.concurrent.ScheduledFuture"
    }
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\PredicateBasedRule.java": {
    "TypeDeclarations": [
      "PredicateBasedRule"
    ],
    "MethodDeclarations": [
      "PredicateBasedRule.getPredicate()",
      "PredicateBasedRule.choose(Object)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "PredicateBasedRule.getPredicate"
      ],
      "Unresolved": [
        "getLoadBalancer",
        "chooseRoundRobinAfterFiltering"
      ]
    },
    "Imports": {
      "Optional": "com.google.common.base.Optional"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\PredicateKey.java": {
    "TypeDeclarations": [
      "PredicateKey"
    ],
    "MethodDeclarations": [
      "PredicateKey.getLoadBalancerKey()",
      "PredicateKey.getServer()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {},
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\RandomRule.java": {
    "TypeDeclarations": [
      "RandomRule"
    ],
    "MethodDeclarations": [
      "RandomRule.choose(ILoadBalancer, Object)",
      "RandomRule.chooseRandomInt(BasicType(dimensions=[], name=int))",
      "RandomRule.choose(Object)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "RandomRule.chooseRandomInt",
        "RandomRule.choose"
      ],
      "Unresolved": [
        "nextInt",
        "getLoadBalancer"
      ]
    },
    "Imports": {
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "List": "java.util.List",
      "ThreadLocalRandom": "java.util.concurrent.ThreadLocalRandom"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\ResponseTimeWeightedRule.java": {
    "TypeDeclarations": [
      "ResponseTimeWeightedRule",
      "DynamicServerWeightTask",
      "ServerWeight"
    ],
    "MethodDeclarations": [
      "ResponseTimeWeightedRule.setLoadBalancer(ILoadBalancer)",
      "ResponseTimeWeightedRule.initialize(ILoadBalancer)",
      "ResponseTimeWeightedRule.shutdown()",
      "ResponseTimeWeightedRule.choose(ILoadBalancer, Object)",
      "DynamicServerWeightTask.run()",
      "ServerWeight.maintainWeights()",
      "ResponseTimeWeightedRule.setWeights(List)",
      "ResponseTimeWeightedRule.initWithNiwsConfig(IClientConfig)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "initialize",
        "java.util.Timer.cancel",
        "java.util.Timer.schedule",
        "addShutdownHook",
        "org.slf4j.Logger.info",
        "java.util.Timer.cancel",
        "org.slf4j.Logger.info",
        "java.util.Timer.cancel",
        "getLoadBalancer",
        "java.util.Random.nextDouble",
        "org.slf4j.Logger.error",
        "getLoadBalancer",
        "java.util.concurrent.atomic.AtomicBoolean.compareAndSet",
        "org.slf4j.Logger.info",
        "setWeights",
        "org.slf4j.Logger.error",
        "java.util.concurrent.atomic.AtomicBoolean.set"
      ]
    },
    "Imports": {
      "ArrayList": "java.util.ArrayList",
      "List": "java.util.List",
      "Random": "java.util.Random",
      "Timer": "java.util.Timer",
      "TimerTask": "java.util.TimerTask",
      "AtomicBoolean": "java.util.concurrent.atomic.AtomicBoolean",
      "Logger": "org.slf4j.Logger",
      "LoggerFactory": "org.slf4j.LoggerFactory",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "IClientConfigKey": "com.netflix.client.config.IClientConfigKey"
    },
    "FieldTypes": {
      "WEIGHT_TASK_TIMER_INTERVAL_CONFIG_KEY": "com.netflix.client.config.IClientConfigKey",
      "logger": "org.slf4j.Logger",
      "accumulatedWeights": "java.util.List",
      "random": "java.util.Random",
      "serverWeightTimer": "java.util.Timer",
      "serverWeightAssignmentInProgress": "java.util.concurrent.atomic.AtomicBoolean"
    }
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\RetryRule.java": {
    "TypeDeclarations": [
      "RetryRule"
    ],
    "MethodDeclarations": [
      "RetryRule.setRule(IRule)",
      "RetryRule.getRule()",
      "RetryRule.setMaxRetryMillis(BasicType(dimensions=[], name=long))",
      "RetryRule.getMaxRetryMillis()",
      "RetryRule.setLoadBalancer(ILoadBalancer)",
      "RetryRule.choose(ILoadBalancer, Object)",
      "RetryRule.choose(Object)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "RetryRule.choose"
      ],
      "Unresolved": [
        "getLoadBalancer"
      ]
    },
    "Imports": {
      "IClientConfig": "com.netflix.client.config.IClientConfig"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\RoundRobinRule.java": {
    "TypeDeclarations": [
      "RoundRobinRule"
    ],
    "MethodDeclarations": [
      "RoundRobinRule.choose(ILoadBalancer, Object)",
      "RoundRobinRule.incrementAndGetModulo(BasicType(dimensions=[], name=int))",
      "RoundRobinRule.choose(Object)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "RoundRobinRule.incrementAndGetModulo",
        "RoundRobinRule.choose"
      ],
      "Unresolved": [
        "setLoadBalancer",
        "org.slf4j.Logger.warn",
        "org.slf4j.Logger.warn",
        "org.slf4j.Logger.warn",
        "java.util.concurrent.atomic.AtomicInteger.get",
        "java.util.concurrent.atomic.AtomicInteger.compareAndSet",
        "getLoadBalancer"
      ]
    },
    "Imports": {
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "Logger": "org.slf4j.Logger",
      "LoggerFactory": "org.slf4j.LoggerFactory",
      "List": "java.util.List",
      "AtomicInteger": "java.util.concurrent.atomic.AtomicInteger"
    },
    "FieldTypes": {
      "nextServerCyclicCounter": "java.util.concurrent.atomic.AtomicInteger",
      "log": "org.slf4j.Logger"
    }
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\Server.java": {
    "TypeDeclarations": [
      "Server",
      "MetaInfo"
    ],
    "MethodDeclarations": [
      "MetaInfo.getAppName()",
      "MetaInfo.getServerGroup()",
      "MetaInfo.getServiceIdForDiscovery()",
      "MetaInfo.getInstanceId()",
      "Server.setAlive(BasicType(dimensions=[], name=boolean))",
      "Server.isAlive()",
      "Server.setHostPort(String)",
      "Server.normalizeId(String)",
      "Server.getScheme(String)",
      "Server.getHostPort(String)",
      "Server.setId(String)",
      "Server.setSchemea(String)",
      "Server.setPort(BasicType(dimensions=[], name=int))",
      "Server.setHost(String)",
      "Server.getId()",
      "Server.getHost()",
      "Server.getPort()",
      "Server.getScheme()",
      "Server.getHostPort()",
      "Server.getMetaInfo()",
      "Server.toString()",
      "Server.equals(Object)",
      "Server.hashCode()",
      "Server.getZone()",
      "Server.setZone(String)",
      "Server.isReadyToServe()",
      "Server.setReadyToServe(BasicType(dimensions=[], name=boolean))"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.lang.equals",
        "java.lang.hashCode"
      ],
      "UserDefined": [],
      "Unresolved": [
        "setId",
        "setId",
        "getHostPort",
        "startsWith",
        "startsWith",
        "startsWith",
        "startsWith",
        "getHostPort",
        "getScheme",
        "getId",
        "getId",
        "getId",
        "getId"
      ]
    },
    "Imports": {
      "Pair": "com.netflix.util.Pair"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\ServerComparator.java": {
    "TypeDeclarations": [
      "ServerComparator"
    ],
    "MethodDeclarations": [
      "ServerComparator.compare(Server, Server)"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.lang.compareTo"
      ],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "Serializable": "java.io.Serializable",
      "Comparator": "java.util.Comparator"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\ServerList.java": {
    "TypeDeclarations": [
      "ServerList"
    ],
    "MethodDeclarations": [
      "ServerList.getInitialListOfServers()",
      "ServerList.getUpdatedListOfServers()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "List": "java.util.List"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\ServerListChangeListener.java": {
    "TypeDeclarations": [
      "ServerListChangeListener"
    ],
    "MethodDeclarations": [
      "ServerListChangeListener.serverListChanged(List, List)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "List": "java.util.List"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\ServerListFilter.java": {
    "TypeDeclarations": [
      "ServerListFilter"
    ],
    "MethodDeclarations": [
      "ServerListFilter.getFilteredListOfServers(List)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "List": "java.util.List"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\ServerListSubsetFilter.java": {
    "TypeDeclarations": [
      "ServerListSubsetFilter"
    ],
    "MethodDeclarations": [
      "ServerListSubsetFilter.initWithNiwsConfig(IClientConfig)",
      "ServerListSubsetFilter.getFilteredListOfServers(List)",
      "ServerListSubsetFilter.randomChoose(List, BasicType(dimensions=[], name=int))",
      "ServerListSubsetFilter.compare(T, T)"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.util.Set.size"
      ],
      "UserDefined": [
        "ServerListSubsetFilter.initWithNiwsConfig",
        "ServerListSubsetFilter.randomChoose"
      ],
      "Unresolved": [
        "com.netflix.client.config.IClientConfigKey.defaultValue",
        "com.netflix.client.config.IClientConfigKey.defaultValue",
        "com.netflix.client.config.IClientConfigKey.defaultValue",
        "com.netflix.client.config.IClientConfigKey.defaultValue",
        "getLoadBalancerStats",
        "com.netflix.client.config.Property.getOrDefault",
        "com.netflix.client.config.Property.getOrDefault",
        "com.netflix.client.config.Property.getOrDefault",
        "com.netflix.client.config.Property.getOrDefault",
        "java.util.Random.nextInt",
        "getLoadBalancerStats"
      ]
    },
    "Imports": {
      "Lists": "com.google.common.collect.Lists",
      "Sets": "com.google.common.collect.Sets",
      "IClientConfigAware": "com.netflix.client.IClientConfigAware",
      "CommonClientConfigKey": "com.netflix.client.config.CommonClientConfigKey",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "IClientConfigKey": "com.netflix.client.config.IClientConfigKey",
      "Property": "com.netflix.client.config.Property",
      "Collections": "java.util.Collections",
      "Comparator": "java.util.Comparator",
      "List": "java.util.List",
      "Random": "java.util.Random",
      "Set": "java.util.Set"
    },
    "FieldTypes": {
      "random": "java.util.Random",
      "currentSubset": "java.util.Set",
      "sizeProp": "com.netflix.client.config.Property",
      "eliminationPercent": "com.netflix.client.config.Property",
      "eliminationFailureCountThreshold": "com.netflix.client.config.Property",
      "eliminationConnectionCountThreshold": "com.netflix.client.config.Property",
      "SIZE": "com.netflix.client.config.IClientConfigKey",
      "FORCE_ELIMINATE_PERCENT": "com.netflix.client.config.IClientConfigKey",
      "ELIMINATION_FAILURE_THRESHOLD": "com.netflix.client.config.IClientConfigKey",
      "ELIMINATION_CONNECTION_THRESHOLD": "com.netflix.client.config.IClientConfigKey"
    }
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\ServerListUpdater.java": {
    "TypeDeclarations": [
      "ServerListUpdater",
      "UpdateAction"
    ],
    "MethodDeclarations": [
      "UpdateAction.doUpdate()",
      "ServerListUpdater.start(UpdateAction)",
      "ServerListUpdater.stop()",
      "ServerListUpdater.getLastUpdate()",
      "ServerListUpdater.getDurationSinceLastUpdateMs()",
      "ServerListUpdater.getNumberMissedCycles()",
      "ServerListUpdater.getCoreThreads()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {},
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\ServerStats.java": {
    "TypeDeclarations": [
      "ServerStats",
      "Percent"
    ],
    "MethodDeclarations": [
      "ServerStats.initialize(Server)",
      "ServerStats.close()",
      "ServerStats.getServer()",
      "ServerStats.getBufferSize()",
      "ServerStats.getPublishIntervalMillis()",
      "ServerStats.setBufferSize(BasicType(dimensions=[], name=int))",
      "ServerStats.setPublishInterval(BasicType(dimensions=[], name=int))",
      "Percent.getValue()",
      "ServerStats.makePercentValues()",
      "ServerStats.getFailureCountSlidingWindowInterval()",
      "ServerStats.setFailureCountSlidingWindowInterval(BasicType(dimensions=[], name=long))",
      "ServerStats.addToFailureCount()",
      "ServerStats.getFailureCount()",
      "ServerStats.noteResponseTime(BasicType(dimensions=[], name=double))",
      "ServerStats.incrementNumRequests()",
      "ServerStats.incrementActiveRequestsCount()",
      "ServerStats.incrementOpenConnectionsCount()",
      "ServerStats.decrementActiveRequestsCount()",
      "ServerStats.decrementOpenConnectionsCount()",
      "ServerStats.getActiveRequestsCount()",
      "ServerStats.getActiveRequestsCount(BasicType(dimensions=[], name=long))",
      "ServerStats.getOpenConnectionsCount()",
      "ServerStats.getMeasuredRequestsCount()",
      "ServerStats.getMonitoredActiveRequestsCount()",
      "ServerStats.isCircuitBreakerTripped()",
      "ServerStats.isCircuitBreakerTripped(BasicType(dimensions=[], name=long))",
      "ServerStats.getCircuitBreakerTimeout()",
      "ServerStats.getCircuitBreakerBlackoutPeriod()",
      "ServerStats.incrementSuccessiveConnectionFailureCount()",
      "ServerStats.clearSuccessiveConnectionFailureCount()",
      "ServerStats.getSuccessiveConnectionFailureCount()",
      "ServerStats.getResponseTimeAvg()",
      "ServerStats.getResponseTimeMax()",
      "ServerStats.getResponseTimeMin()",
      "ServerStats.getResponseTimeStdDev()",
      "ServerStats.getResponseTimePercentileNumValues()",
      "ServerStats.getResponseTimePercentileTime()",
      "ServerStats.getResponseTimePercentileTimeMillis()",
      "ServerStats.getResponseTimeAvgRecent()",
      "ServerStats.getResponseTime10thPercentile()",
      "ServerStats.getResponseTime25thPercentile()",
      "ServerStats.getResponseTime50thPercentile()",
      "ServerStats.getResponseTime75thPercentile()",
      "ServerStats.getResponseTime90thPercentile()",
      "ServerStats.getResponseTime95thPercentile()",
      "ServerStats.getResponseTime98thPercentile()",
      "ServerStats.getResponseTime99thPercentile()",
      "ServerStats.getResponseTime99point5thPercentile()",
      "ServerStats.getTotalRequestsCount()",
      "ServerStats.getResponseTimePercentile(Percent)",
      "ServerStats.toString()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "Percent.getValue"
      ],
      "Unresolved": [
        "makePercentValues",
        "getBufferSize",
        "getPublishIntervalMillis",
        "com.netflix.stats.distribution.DataPublisher.start",
        "com.netflix.stats.distribution.DataPublisher.stop",
        "com.netflix.util.MeasuredRate.increment",
        "com.netflix.util.MeasuredRate.getCurrentCount",
        "com.netflix.stats.distribution.DataDistribution.noteValue",
        "com.netflix.stats.distribution.Distribution.noteValue",
        "java.util.concurrent.atomic.AtomicLong.incrementAndGet",
        "java.util.concurrent.atomic.AtomicInteger.incrementAndGet",
        "com.netflix.util.MeasuredRate.increment",
        "java.util.concurrent.atomic.AtomicInteger.incrementAndGet",
        "java.util.concurrent.atomic.AtomicInteger.getAndUpdate",
        "java.util.concurrent.atomic.AtomicInteger.getAndUpdate",
        "getActiveRequestsCount",
        "java.util.concurrent.atomic.AtomicInteger.get",
        "com.netflix.client.config.UnboxedIntProperty.get",
        "java.util.concurrent.atomic.AtomicInteger.set",
        "java.util.concurrent.atomic.AtomicInteger.get",
        "com.netflix.util.MeasuredRate.getCount",
        "java.util.concurrent.atomic.AtomicInteger.get",
        "isCircuitBreakerTripped",
        "getCircuitBreakerTimeout",
        "getCircuitBreakerBlackoutPeriod",
        "java.util.concurrent.atomic.AtomicInteger.get",
        "com.netflix.client.config.UnboxedIntProperty.get",
        "com.netflix.client.config.UnboxedIntProperty.get",
        "com.netflix.client.config.UnboxedIntProperty.get",
        "com.netflix.client.config.UnboxedIntProperty.get",
        "java.util.concurrent.atomic.AtomicInteger.incrementAndGet",
        "java.util.concurrent.atomic.AtomicLong.addAndGet",
        "getCircuitBreakerBlackoutPeriod",
        "java.util.concurrent.atomic.AtomicInteger.set",
        "java.util.concurrent.atomic.AtomicInteger.get",
        "com.netflix.stats.distribution.Distribution.getMean",
        "com.netflix.stats.distribution.Distribution.getMaximum",
        "com.netflix.stats.distribution.Distribution.getMinimum",
        "com.netflix.stats.distribution.Distribution.getStdDev",
        "com.netflix.stats.distribution.DataDistribution.getSampleSize",
        "com.netflix.stats.distribution.DataDistribution.getTimestamp",
        "com.netflix.stats.distribution.DataDistribution.getTimestampMillis",
        "com.netflix.stats.distribution.DataDistribution.getMean",
        "getResponseTimePercentile",
        "getResponseTimePercentile",
        "getResponseTimePercentile",
        "getResponseTimePercentile",
        "getResponseTimePercentile",
        "getResponseTimePercentile",
        "getResponseTimePercentile",
        "getResponseTimePercentile",
        "getResponseTimePercentile",
        "java.util.concurrent.atomic.AtomicLong.get",
        "com.netflix.stats.distribution.DataDistribution.getPercentiles",
        "getSuccessiveConnectionFailureCount",
        "isCircuitBreakerTripped",
        "getCircuitBreakerTimeout",
        "java.util.concurrent.atomic.AtomicLong.get",
        "getMonitoredActiveRequestsCount",
        "getFailureCount",
        "getResponseTimeAvg",
        "getResponseTime90thPercentile",
        "getResponseTime95thPercentile",
        "getResponseTimeMin",
        "getResponseTimeMax",
        "getResponseTimeStdDev"
      ]
    },
    "Imports": {
      "VisibleForTesting": "com.google.common.annotations.VisibleForTesting",
      "CommonClientConfigKey": "com.netflix.client.config.CommonClientConfigKey",
      "IClientConfigKey": "com.netflix.client.config.IClientConfigKey",
      "Property": "com.netflix.client.config.Property",
      "UnboxedIntProperty": "com.netflix.client.config.UnboxedIntProperty",
      "DataSourceType": "com.netflix.servo.annotations.DataSourceType",
      "Monitor": "com.netflix.servo.annotations.Monitor",
      "DataDistribution": "com.netflix.stats.distribution.DataDistribution",
      "DataPublisher": "com.netflix.stats.distribution.DataPublisher",
      "Distribution": "com.netflix.stats.distribution.Distribution",
      "MeasuredRate": "com.netflix.util.MeasuredRate",
      "Date": "java.util.Date",
      "Random": "java.util.Random",
      "AtomicInteger": "java.util.concurrent.atomic.AtomicInteger",
      "AtomicLong": "java.util.concurrent.atomic.AtomicLong"
    },
    "FieldTypes": {
      "connectionFailureThreshold": "com.netflix.client.config.UnboxedIntProperty",
      "circuitTrippedTimeoutFactor": "com.netflix.client.config.UnboxedIntProperty",
      "maxCircuitTrippedTimeout": "com.netflix.client.config.UnboxedIntProperty",
      "activeRequestsCountTimeout": "com.netflix.client.config.UnboxedIntProperty",
      "dataDist": "com.netflix.stats.distribution.DataDistribution",
      "publisher": "com.netflix.stats.distribution.DataPublisher",
      "responseTimeDist": "com.netflix.stats.distribution.Distribution",
      "serverFailureCounts": "com.netflix.util.MeasuredRate",
      "requestCountInWindow": "com.netflix.util.MeasuredRate",
      "totalRequests": "java.util.concurrent.atomic.AtomicLong",
      "successiveConnectionFailureCount": "java.util.concurrent.atomic.AtomicInteger",
      "activeRequestsCount": "java.util.concurrent.atomic.AtomicInteger",
      "openConnectionsCount": "java.util.concurrent.atomic.AtomicInteger",
      "totalCircuitBreakerBlackOutPeriod": "java.util.concurrent.atomic.AtomicLong"
    }
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\ServerStatusChangeListener.java": {
    "TypeDeclarations": [
      "ServerStatusChangeListener"
    ],
    "MethodDeclarations": [
      "ServerStatusChangeListener.serverStatusChanged(Collection)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "Collection": "java.util.Collection"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\WeightedResponseTimeRule.java": {
    "TypeDeclarations": [
      "WeightedResponseTimeRule",
      "DynamicServerWeightTask",
      "ServerWeight"
    ],
    "MethodDeclarations": [
      "WeightedResponseTimeRule.setLoadBalancer(ILoadBalancer)",
      "WeightedResponseTimeRule.initialize(ILoadBalancer)",
      "WeightedResponseTimeRule.shutdown()",
      "WeightedResponseTimeRule.getAccumulatedWeights()",
      "WeightedResponseTimeRule.choose(ILoadBalancer, Object)",
      "DynamicServerWeightTask.run()",
      "ServerWeight.maintainWeights()",
      "WeightedResponseTimeRule.setWeights(List)",
      "WeightedResponseTimeRule.initWithNiwsConfig(IClientConfig)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "key",
        "initialize",
        "java.util.Timer.cancel",
        "java.util.Timer.schedule",
        "addShutdownHook",
        "org.slf4j.Logger.info",
        "java.util.Timer.cancel",
        "org.slf4j.Logger.info",
        "java.util.Timer.cancel",
        "getLoadBalancer",
        "java.util.Random.nextDouble",
        "org.slf4j.Logger.error",
        "getLoadBalancer",
        "java.util.concurrent.atomic.AtomicBoolean.compareAndSet",
        "org.slf4j.Logger.info",
        "setWeights",
        "org.slf4j.Logger.error",
        "java.util.concurrent.atomic.AtomicBoolean.set"
      ]
    },
    "Imports": {
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "IClientConfigKey": "com.netflix.client.config.IClientConfigKey",
      "Logger": "org.slf4j.Logger",
      "LoggerFactory": "org.slf4j.LoggerFactory",
      "ArrayList": "java.util.ArrayList",
      "Collections": "java.util.Collections",
      "List": "java.util.List",
      "Random": "java.util.Random",
      "Timer": "java.util.Timer",
      "TimerTask": "java.util.TimerTask",
      "AtomicBoolean": "java.util.concurrent.atomic.AtomicBoolean"
    },
    "FieldTypes": {
      "WEIGHT_TASK_TIMER_INTERVAL_CONFIG_KEY": "com.netflix.client.config.IClientConfigKey",
      "logger": "org.slf4j.Logger",
      "accumulatedWeights": "java.util.List",
      "random": "java.util.Random",
      "serverWeightTimer": "java.util.Timer",
      "serverWeightAssignmentInProgress": "java.util.concurrent.atomic.AtomicBoolean"
    }
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\ZoneAffinityPredicate.java": {
    "TypeDeclarations": [
      "ZoneAffinityPredicate"
    ],
    "MethodDeclarations": [
      "ZoneAffinityPredicate.apply(PredicateKey)"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.lang.equals"
      ],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {},
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\ZoneAffinityServerListFilter.java": {
    "TypeDeclarations": [
      "ZoneAffinityServerListFilter"
    ],
    "MethodDeclarations": [
      "ZoneAffinityServerListFilter.initWithNiwsConfig(IClientConfig)",
      "ZoneAffinityServerListFilter.shouldEnableZoneAffinity(List)",
      "ZoneAffinityServerListFilter.getFilteredListOfServers(List)",
      "ZoneAffinityServerListFilter.toString()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "ZoneAffinityServerListFilter.initWithNiwsConfig",
        "ZoneAffinityServerListFilter.shouldEnableZoneAffinity"
      ],
      "Unresolved": [
        "getOrDefault",
        "getLoadBalancerStats",
        "org.slf4j.Logger.debug",
        "com.netflix.client.config.Property.getOrDefault",
        "com.netflix.client.config.Property.getOrDefault",
        "com.netflix.client.config.Property.getOrDefault",
        "org.slf4j.Logger.debug",
        "getServerOnlyPredicate",
        "com.netflix.servo.monitor.Counter.increment",
        "append",
        "append",
        "append",
        "append"
      ]
    },
    "Imports": {
      "Iterables": "com.google.common.collect.Iterables",
      "Lists": "com.google.common.collect.Lists",
      "IClientConfigAware": "com.netflix.client.IClientConfigAware",
      "CommonClientConfigKey": "com.netflix.client.config.CommonClientConfigKey",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "IClientConfigKey": "com.netflix.client.config.IClientConfigKey",
      "Property": "com.netflix.client.config.Property",
      "Counter": "com.netflix.servo.monitor.Counter",
      "Monitors": "com.netflix.servo.monitor.Monitors",
      "Logger": "org.slf4j.Logger",
      "LoggerFactory": "org.slf4j.LoggerFactory",
      "List": "java.util.List"
    },
    "FieldTypes": {
      "ZONE": "com.netflix.client.config.IClientConfigKey",
      "MAX_LOAD_PER_SERVER": "com.netflix.client.config.IClientConfigKey",
      "MAX_BLACKOUT_SERVER_PERCENTAGE": "com.netflix.client.config.IClientConfigKey",
      "MIN_AVAILABLE_SERVERS": "com.netflix.client.config.IClientConfigKey",
      "activeReqeustsPerServerThreshold": "com.netflix.client.config.Property",
      "blackOutServerPercentageThreshold": "com.netflix.client.config.Property",
      "availableServersThreshold": "com.netflix.client.config.Property",
      "overrideCounter": "com.netflix.servo.monitor.Counter",
      "logger": "org.slf4j.Logger"
    }
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\ZoneAvoidancePredicate.java": {
    "TypeDeclarations": [
      "ZoneAvoidancePredicate"
    ],
    "MethodDeclarations": [
      "ZoneAvoidancePredicate.initDynamicProperties(IClientConfig)",
      "ZoneAvoidancePredicate.apply(PredicateKey)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "ZoneAvoidancePredicate.initDynamicProperties",
        "ZoneAvoidancePredicate.initDynamicProperties"
      ],
      "Unresolved": [
        "com.netflix.client.config.IClientConfigKey.defaultValue",
        "com.netflix.client.config.IClientConfigKey.defaultValue",
        "com.netflix.client.config.IClientConfigKey.defaultValue",
        "com.netflix.client.config.IClientConfigKey.format",
        "com.netflix.client.config.IClientConfigKey.format",
        "com.netflix.client.config.Property.getOrDefault",
        "getZone",
        "getLBStats",
        "size",
        "contains",
        "org.slf4j.Logger.debug",
        "com.netflix.client.config.Property.getOrDefault",
        "com.netflix.client.config.Property.getOrDefault",
        "org.slf4j.Logger.debug",
        "getZone"
      ]
    },
    "Imports": {
      "CommonClientConfigKey": "com.netflix.client.config.CommonClientConfigKey",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "IClientConfigKey": "com.netflix.client.config.IClientConfigKey",
      "Property": "com.netflix.client.config.Property",
      "Logger": "org.slf4j.Logger",
      "LoggerFactory": "org.slf4j.LoggerFactory",
      "Nullable": "javax.annotation.Nullable",
      "Map": "java.util.Map",
      "Set": "java.util.Set"
    },
    "FieldTypes": {
      "logger": "org.slf4j.Logger",
      "TRIGGERING_LOAD_PER_SERVER_THRESHOLD": "com.netflix.client.config.IClientConfigKey",
      "AVOID_ZONE_WITH_BLACKOUT_PERCENTAGE": "com.netflix.client.config.IClientConfigKey",
      "ENABLED": "com.netflix.client.config.IClientConfigKey",
      "triggeringLoad": "com.netflix.client.config.Property",
      "triggeringBlackoutPercentage": "com.netflix.client.config.Property",
      "enabled": "com.netflix.client.config.Property"
    }
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\ZoneAvoidanceRule.java": {
    "TypeDeclarations": [
      "ZoneAvoidanceRule"
    ],
    "MethodDeclarations": [
      "ZoneAvoidanceRule.createCompositePredicate(ZoneAvoidancePredicate, AvailabilityPredicate)",
      "ZoneAvoidanceRule.initWithNiwsConfig(IClientConfig)",
      "ZoneAvoidanceRule.createSnapshot(LoadBalancerStats)",
      "ZoneAvoidanceRule.randomChooseZone(Map, Set)",
      "ZoneAvoidanceRule.getAvailableZones(Map, BasicType(dimensions=[], name=double), BasicType(dimensions=[], name=double))",
      "ZoneAvoidanceRule.getAvailableZones(LoadBalancerStats, BasicType(dimensions=[], name=double), BasicType(dimensions=[], name=double))",
      "ZoneAvoidanceRule.getPredicate()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "ZoneAvoidanceRule.createCompositePredicate",
        "ZoneAvoidanceRule.createCompositePredicate",
        "ZoneAvoidanceRule.randomChooseZone",
        "ZoneAvoidanceRule.createSnapshot",
        "ZoneAvoidanceRule.getAvailableZones"
      ],
      "Unresolved": [
        "addFallbackPredicate",
        "addFallbackPredicate",
        "build",
        "next",
        "getInstanceCount",
        "java.util.Random.nextInt",
        "getInstanceCount"
      ]
    },
    "Imports": {
      "HashMap": "java.util.HashMap",
      "HashSet": "java.util.HashSet",
      "Map": "java.util.Map",
      "Random": "java.util.Random",
      "Set": "java.util.Set",
      "IClientConfig": "com.netflix.client.config.IClientConfig"
    },
    "FieldTypes": {
      "random": "java.util.Random"
    }
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\ZoneAwareLoadBalancer.java": {
    "TypeDeclarations": [
      "ZoneAwareLoadBalancer"
    ],
    "MethodDeclarations": [
      "ZoneAwareLoadBalancer.setUpServerList(List)",
      "ZoneAwareLoadBalancer.initWithNiwsConfig(IClientConfig)",
      "ZoneAwareLoadBalancer.setServerListForZones(Map)",
      "ZoneAwareLoadBalancer.chooseServer(Object)",
      "ZoneAwareLoadBalancer.getLoadBalancer(String)",
      "ZoneAwareLoadBalancer.cloneRule(IRule)",
      "ZoneAwareLoadBalancer.setRule(IRule)"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.util.concurrent.ConcurrentHashMap.get",
        "java.util.concurrent.ConcurrentHashMap.putIfAbsent",
        "java.util.concurrent.ConcurrentHashMap.get"
      ],
      "UserDefined": [
        "ZoneAwareLoadBalancer.getLoadBalancer",
        "ZoneAwareLoadBalancer.getLoadBalancer",
        "ZoneAwareLoadBalancer.cloneRule",
        "ZoneAwareLoadBalancer.setRule",
        "ZoneAwareLoadBalancer.cloneRule"
      ],
      "Unresolved": [
        "com.netflix.client.config.IClientConfigKey.defaultValue",
        "com.netflix.client.config.IClientConfigKey.defaultValue",
        "com.netflix.client.config.IClientConfigKey.defaultValue",
        "orElse",
        "getName",
        "com.netflix.client.config.IClientConfigKey.format",
        "com.netflix.client.config.IClientConfigKey.format",
        "orElse",
        "getName",
        "com.netflix.client.config.IClientConfigKey.format",
        "com.netflix.client.config.IClientConfigKey.format",
        "orElse",
        "getName",
        "com.netflix.client.config.IClientConfigKey.format",
        "com.netflix.client.config.IClientConfigKey.format",
        "toLowerCase",
        "setServersList",
        "java.util.concurrent.ConcurrentHashMap.entrySet",
        "contains",
        "setServersList",
        "com.netflix.client.config.Property.getOrDefault",
        "getLoadBalancerStats",
        "getAvailableZones",
        "size",
        "org.slf4j.Logger.debug",
        "getLoadBalancerStats",
        "org.slf4j.Logger.debug",
        "com.netflix.client.config.Property.getOrDefault",
        "com.netflix.client.config.Property.getOrDefault",
        "org.slf4j.Logger.debug",
        "size",
        "org.slf4j.Logger.debug",
        "org.slf4j.Logger.error",
        "org.slf4j.Logger.debug",
        "getRule",
        "getName",
        "getLoadBalancerStats",
        "getName",
        "getClientConfig",
        "java.util.concurrent.ConcurrentHashMap.keySet"
      ]
    },
    "Imports": {
      "VisibleForTesting": "com.google.common.annotations.VisibleForTesting",
      "Preconditions": "com.google.common.base.Preconditions",
      "ClientFactory": "com.netflix.client.ClientFactory",
      "ClientConfigFactory": "com.netflix.client.config.ClientConfigFactory",
      "CommonClientConfigKey": "com.netflix.client.config.CommonClientConfigKey",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "IClientConfigKey": "com.netflix.client.config.IClientConfigKey",
      "Property": "com.netflix.client.config.Property",
      "Logger": "org.slf4j.Logger",
      "LoggerFactory": "org.slf4j.LoggerFactory",
      "Collections": "java.util.Collections",
      "List": "java.util.List",
      "Map": "java.util.Map",
      "Optional": "java.util.Optional",
      "Set": "java.util.Set",
      "ConcurrentHashMap": "java.util.concurrent.ConcurrentHashMap"
    },
    "FieldTypes": {
      "balancers": "java.util.concurrent.ConcurrentHashMap",
      "logger": "org.slf4j.Logger",
      "ENABLED": "com.netflix.client.config.IClientConfigKey",
      "TRIGGERING_LOAD_PER_SERVER_THRESHOLD": "com.netflix.client.config.IClientConfigKey",
      "AVOID_ZONE_WITH_BLACKOUT_PERCENTAGE": "com.netflix.client.config.IClientConfigKey",
      "triggeringLoad": "com.netflix.client.config.Property",
      "triggeringBlackoutPercentage": "com.netflix.client.config.Property",
      "enabled": "com.netflix.client.config.Property"
    }
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\ZoneSnapshot.java": {
    "TypeDeclarations": [
      "ZoneSnapshot"
    ],
    "MethodDeclarations": [
      "ZoneSnapshot.getInstanceCount()",
      "ZoneSnapshot.getLoadPerServer()",
      "ZoneSnapshot.getCircuitTrippedCount()",
      "ZoneSnapshot.getActiveRequestsCount()",
      "ZoneSnapshot.toString()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {},
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\ZoneStats.java": {
    "TypeDeclarations": [
      "ZoneStats"
    ],
    "MethodDeclarations": [
      "ZoneStats.getZone()",
      "ZoneStats.getActiveRequestsCount()",
      "ZoneStats.getInstanceCount()",
      "ZoneStats.getCircuitBreakerTrippedCount()",
      "ZoneStats.getActiveRequestsPerServer()",
      "ZoneStats.getMeasuredZoneHits()",
      "ZoneStats.getCircuitBreakerTrippedPercentage()",
      "ZoneStats.incrementCounter()",
      "ZoneStats.toString()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "ZoneStats.getInstanceCount",
        "ZoneStats.getActiveRequestsCount",
        "ZoneStats.getCircuitBreakerTrippedCount",
        "ZoneStats.getActiveRequestsPerServer"
      ],
      "Unresolved": [
        "com.netflix.servo.monitor.Counter.increment"
      ]
    },
    "Imports": {
      "DataSourceType": "com.netflix.servo.annotations.DataSourceType",
      "Monitor": "com.netflix.servo.annotations.Monitor",
      "Counter": "com.netflix.servo.monitor.Counter",
      "Monitors": "com.netflix.servo.monitor.Monitors"
    },
    "FieldTypes": {
      "counter": "com.netflix.servo.monitor.Counter"
    }
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\reactive\\ExecutionContext.java": {
    "TypeDeclarations": [
      "ExecutionContext",
      "ChildContext"
    ],
    "MethodDeclarations": [
      "ChildContext.getGlobalContext()",
      "ExecutionContext.getChildContext(Object)",
      "ExecutionContext.getRequest()",
      "ExecutionContext.get(String)",
      "ExecutionContext.getClientProperty(IClientConfigKey)",
      "ExecutionContext.put(String, Object)",
      "ExecutionContext.getRequestConfig()",
      "ExecutionContext.getGlobalContext()",
      "ExecutionContext.getRetryHandler()"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.util.concurrent.ConcurrentHashMap.get",
        "java.util.concurrent.ConcurrentHashMap.putIfAbsent",
        "java.util.Map.get",
        "java.util.Map.put"
      ],
      "UserDefined": [],
      "Unresolved": [
        "com.netflix.client.config.IClientConfig.get",
        "com.netflix.client.config.IClientConfig.get"
      ]
    },
    "Imports": {
      "RetryHandler": "com.netflix.client.RetryHandler",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "IClientConfigKey": "com.netflix.client.config.IClientConfigKey",
      "Map": "java.util.Map",
      "ConcurrentHashMap": "java.util.concurrent.ConcurrentHashMap"
    },
    "FieldTypes": {
      "context": "java.util.Map",
      "subContexts": "java.util.concurrent.ConcurrentHashMap",
      "requestConfig": "com.netflix.client.config.IClientConfig",
      "retryHandler": "com.netflix.client.RetryHandler",
      "clientConfig": "com.netflix.client.config.IClientConfig"
    }
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\reactive\\ExecutionContextListenerInvoker.java": {
    "TypeDeclarations": [
      "ExecutionContextListenerInvoker"
    ],
    "MethodDeclarations": [
      "ExecutionContextListenerInvoker.onExecutionStart()",
      "ExecutionContextListenerInvoker.onExecutionStart(ExecutionContext)",
      "ExecutionContextListenerInvoker.onStartWithServer(ExecutionInfo)",
      "ExecutionContextListenerInvoker.onStartWithServer(ExecutionContext, ExecutionInfo)",
      "ExecutionContextListenerInvoker.onExceptionWithServer(Throwable, ExecutionInfo)",
      "ExecutionContextListenerInvoker.onExceptionWithServer(ExecutionContext, Throwable, ExecutionInfo)",
      "ExecutionContextListenerInvoker.onExecutionSuccess(O, ExecutionInfo)",
      "ExecutionContextListenerInvoker.onExecutionSuccess(ExecutionContext, O, ExecutionInfo)",
      "ExecutionContextListenerInvoker.onExecutionFailed(Throwable, ExecutionInfo)",
      "ExecutionContextListenerInvoker.onExecutionFailed(ExecutionContext, Throwable, ExecutionInfo)",
      "ExecutionContextListenerInvoker.isListenerDisabled(ExecutionListener)"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.util.concurrent.ConcurrentHashMap.get",
        "java.util.concurrent.ConcurrentHashMap.putIfAbsent"
      ],
      "UserDefined": [
        "ExecutionContextListenerInvoker.onExecutionStart",
        "ExecutionContextListenerInvoker.isListenerDisabled",
        "ExecutionContextListenerInvoker.onStartWithServer",
        "ExecutionContextListenerInvoker.isListenerDisabled",
        "ExecutionContextListenerInvoker.onExceptionWithServer",
        "ExecutionContextListenerInvoker.isListenerDisabled",
        "ExecutionContextListenerInvoker.onExecutionSuccess",
        "ExecutionContextListenerInvoker.isListenerDisabled",
        "ExecutionContextListenerInvoker.onExecutionFailed",
        "ExecutionContextListenerInvoker.isListenerDisabled"
      ],
      "Unresolved": [
        "org.slf4j.Logger.error",
        "org.slf4j.Logger.error",
        "org.slf4j.Logger.error",
        "org.slf4j.Logger.error",
        "org.slf4j.Logger.error",
        "getName",
        "com.netflix.client.config.IClientConfig.get"
      ]
    },
    "Imports": {
      "CommonClientConfigKey": "com.netflix.client.config.CommonClientConfigKey",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "IClientConfigKey": "com.netflix.client.config.IClientConfigKey",
      "AbortExecutionException": "com.netflix.loadbalancer.reactive.ExecutionListener.AbortExecutionException",
      "Logger": "org.slf4j.Logger",
      "LoggerFactory": "org.slf4j.LoggerFactory",
      "Collections": "java.util.Collections",
      "List": "java.util.List",
      "ConcurrentHashMap": "java.util.concurrent.ConcurrentHashMap"
    },
    "FieldTypes": {
      "logger": "org.slf4j.Logger",
      "listeners": "java.util.List",
      "clientConfig": "com.netflix.client.config.IClientConfig",
      "classConfigKeyMap": "java.util.concurrent.ConcurrentHashMap"
    }
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\reactive\\ExecutionInfo.java": {
    "TypeDeclarations": [
      "ExecutionInfo"
    ],
    "MethodDeclarations": [
      "ExecutionInfo.create(Server, BasicType(dimensions=[], name=int), BasicType(dimensions=[], name=int))",
      "ExecutionInfo.getServer()",
      "ExecutionInfo.getNumberOfPastAttemptsOnServer()",
      "ExecutionInfo.getNumberOfPastServersAttempted()",
      "ExecutionInfo.toString()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "Server": "com.netflix.loadbalancer.Server"
    },
    "FieldTypes": {
      "server": "com.netflix.loadbalancer.Server"
    }
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\reactive\\ExecutionListener.java": {
    "TypeDeclarations": [
      "ExecutionListener",
      "AbortExecutionException"
    ],
    "MethodDeclarations": [
      "ExecutionListener.onExecutionStart(ExecutionContext)",
      "ExecutionListener.onStartWithServer(ExecutionContext, ExecutionInfo)",
      "ExecutionListener.onExceptionWithServer(ExecutionContext, Throwable, ExecutionInfo)",
      "ExecutionListener.onExecutionSuccess(ExecutionContext, O, ExecutionInfo)",
      "ExecutionListener.onExecutionFailed(ExecutionContext, Throwable, ExecutionInfo)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {},
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\reactive\\LoadBalancerCommand.java": {
    "TypeDeclarations": [
      "LoadBalancerCommand",
      "Builder",
      "ExecutionInfoContext"
    ],
    "MethodDeclarations": [
      "Builder.withLoadBalancer(ILoadBalancer)",
      "Builder.withLoadBalancerURI(URI)",
      "Builder.withListeners(List)",
      "Builder.withRetryHandler(RetryHandler)",
      "Builder.withClientConfig(IClientConfig)",
      "Builder.withServerLocator(Object)",
      "Builder.withLoadBalancerContext(LoadBalancerContext)",
      "Builder.withExecutionContext(ExecutionContext)",
      "Builder.withServer(Server)",
      "Builder.build()",
      "LoadBalancerCommand.builder()",
      "LoadBalancerCommand.selectServer()",
      "ExecutionInfoContext.setServer(Server)",
      "ExecutionInfoContext.incAttemptCount()",
      "ExecutionInfoContext.getAttemptCount()",
      "ExecutionInfoContext.getServer()",
      "ExecutionInfoContext.getServerAttemptCount()",
      "ExecutionInfoContext.toExecutionInfo()",
      "ExecutionInfoContext.toFinalExecutionInfo()",
      "LoadBalancerCommand.retryPolicy(BasicType(dimensions=[], name=int), BasicType(dimensions=[], name=boolean))",
      "LoadBalancerCommand.submit(ServerOperation)"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.util.List.size"
      ],
      "UserDefined": [],
      "Unresolved": [
        "addAll",
        "com.netflix.loadbalancer.LoadBalancerContext.getRetryHandler",
        "com.netflix.loadbalancer.LoadBalancerContext.getServerFromLoadBalancer",
        "com.netflix.client.RetryHandler.isRetriableException",
        "com.netflix.client.RetryHandler.getMaxRetriesOnSameServer",
        "com.netflix.client.RetryHandler.getMaxRetriesOnNextServer",
        "selectServer",
        "retryPolicy"
      ]
    },
    "Imports": {
      "URI": "java.net.URI",
      "Collection": "java.util.Collection",
      "LinkedList": "java.util.LinkedList",
      "List": "java.util.List",
      "TimeUnit": "java.util.concurrent.TimeUnit",
      "Logger": "org.slf4j.Logger",
      "LoggerFactory": "org.slf4j.LoggerFactory",
      "Observable": "rx.Observable",
      "OnSubscribe": "rx.Observable.OnSubscribe",
      "Observer": "rx.Observer",
      "Subscriber": "rx.Subscriber",
      "Func1": "rx.functions.Func1",
      "Func2": "rx.functions.Func2",
      "ClientException": "com.netflix.client.ClientException",
      "RetryHandler": "com.netflix.client.RetryHandler",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "ILoadBalancer": "com.netflix.loadbalancer.ILoadBalancer",
      "LoadBalancerContext": "com.netflix.loadbalancer.LoadBalancerContext",
      "Server": "com.netflix.loadbalancer.Server",
      "ServerStats": "com.netflix.loadbalancer.ServerStats",
      "AbortExecutionException": "com.netflix.loadbalancer.reactive.ExecutionListener.AbortExecutionException",
      "Stopwatch": "com.netflix.servo.monitor.Stopwatch"
    },
    "FieldTypes": {
      "logger": "org.slf4j.Logger",
      "retryHandler": "com.netflix.client.RetryHandler",
      "loadBalancer": "com.netflix.loadbalancer.ILoadBalancer",
      "config": "com.netflix.client.config.IClientConfig",
      "loadBalancerContext": "com.netflix.loadbalancer.LoadBalancerContext",
      "listeners": "java.util.List",
      "loadBalancerURI": "java.net.URI",
      "server": "com.netflix.loadbalancer.Server"
    }
  },
  "ribbon\\ribbon-loadbalancer\\src\\main\\java\\com\\netflix\\loadbalancer\\reactive\\ServerOperation.java": {
    "TypeDeclarations": [
      "ServerOperation"
    ],
    "MethodDeclarations": [
      "ServerOperation.call(Server)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "Observable": "rx.Observable",
      "Func1": "rx.functions.Func1",
      "Server": "com.netflix.loadbalancer.Server"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\test\\java\\com\\netflix\\client\\SimpleVipAddressResolverTest.java": {
    "TypeDeclarations": [
      "SimpleVipAddressResolverTest"
    ],
    "MethodDeclarations": [
      "SimpleVipAddressResolverTest.test()",
      "SimpleVipAddressResolverTest.testNoMacro()",
      "SimpleVipAddressResolverTest.testUndefinedProp()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "setProperty",
        "setProperty",
        "assertEquals",
        "setProperty",
        "setProperty",
        "assertEquals",
        "setProperty",
        "assertEquals"
      ]
    },
    "Imports": {
      "org.junit.Assert.*": "org.junit.Assert",
      "Test": "org.junit.Test",
      "ConfigurationManager": "com.netflix.config.ConfigurationManager"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\test\\java\\com\\netflix\\client\\testutil\\MockHttpServer.java": {
    "TypeDeclarations": [
      "MockHttpServer",
      "RequestContext",
      "TestHttpHandler"
    ],
    "MethodDeclarations": [
      "MockHttpServer.handler(String, HttpHandler)",
      "MockHttpServer.port(BasicType(dimensions=[], name=int))",
      "MockHttpServer.secure()",
      "MockHttpServer.threadCount(BasicType(dimensions=[], name=int))",
      "MockHttpServer.apply(Statement, Description)",
      "RequestContext.response(BasicType(dimensions=[], name=int), String)",
      "RequestContext.query(String)",
      "TestHttpHandler.handle(HttpExchange)",
      "TestHttpHandler.handle(RequestContext)",
      "TestHttpHandler.queryToMap(HttpExchange)",
      "MockHttpServer.before(Description)",
      "MockHttpServer.after(Description)",
      "MockHttpServer.getServerUrl()",
      "MockHttpServer.getServerURI()",
      "MockHttpServer.getServerPath(String)",
      "MockHttpServer.getServerPathURI(String)",
      "MockHttpServer.getServerPort()",
      "MockHttpServer.getKeyStore()",
      "MockHttpServer.getTrustStore()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "TestHttpHandler.queryToMap",
        "TestHttpHandler.handle"
      ],
      "Unresolved": [
        "java.util.LinkedHashMap.put",
        "java.util.LinkedHashMap.put",
        "java.util.LinkedHashMap.put",
        "java.util.LinkedHashMap.put",
        "java.util.LinkedHashMap.put",
        "java.util.LinkedHashMap.put",
        "before",
        "after",
        "interrupt",
        "getQuery",
        "setDaemon",
        "setNameFormat",
        "build",
        "getSSLContext",
        "com.sun.net.httpserver.HttpServer.setExecutor",
        "java.util.LinkedHashMap.entrySet",
        "com.sun.net.httpserver.HttpServer.createContext",
        "com.sun.net.httpserver.HttpServer.start",
        "com.sun.net.httpserver.HttpServer.getAddress",
        "getPort",
        "getServerUrl",
        "com.sun.net.httpserver.HttpServer.stop",
        "com.sun.net.httpserver.HttpServer.getExecutor",
        "getServerUrl",
        "getServerUrl",
        "getServerUrl",
        "getServerUrl"
      ]
    },
    "Imports": {
      "File": "java.io.File",
      "FileInputStream": "java.io.FileInputStream",
      "FileOutputStream": "java.io.FileOutputStream",
      "IOException": "java.io.IOException",
      "OutputStream": "java.io.OutputStream",
      "PrintWriter": "java.io.PrintWriter",
      "StringWriter": "java.io.StringWriter",
      "InetSocketAddress": "java.net.InetSocketAddress",
      "URI": "java.net.URI",
      "URISyntaxException": "java.net.URISyntaxException",
      "KeyStore": "java.security.KeyStore",
      "HashMap": "java.util.HashMap",
      "LinkedHashMap": "java.util.LinkedHashMap",
      "Map": "java.util.Map",
      "Entry": "java.util.Map.Entry",
      "ExecutorService": "java.util.concurrent.ExecutorService",
      "Executors": "java.util.concurrent.Executors",
      "TimeUnit": "java.util.concurrent.TimeUnit",
      "KeyManagerFactory": "javax.net.ssl.KeyManagerFactory",
      "SSLContext": "javax.net.ssl.SSLContext",
      "SSLParameters": "javax.net.ssl.SSLParameters",
      "TrustManagerFactory": "javax.net.ssl.TrustManagerFactory",
      "TestRule": "org.junit.rules.TestRule",
      "Description": "org.junit.runner.Description",
      "Statement": "org.junit.runners.model.Statement",
      "ThreadFactoryBuilder": "com.google.common.util.concurrent.ThreadFactoryBuilder",
      "Base64": "com.sun.jersey.core.util.Base64",
      "HttpExchange": "com.sun.net.httpserver.HttpExchange",
      "HttpHandler": "com.sun.net.httpserver.HttpHandler",
      "HttpServer": "com.sun.net.httpserver.HttpServer",
      "HttpsConfigurator": "com.sun.net.httpserver.HttpsConfigurator",
      "HttpsParameters": "com.sun.net.httpserver.HttpsParameters",
      "HttpsServer": "com.sun.net.httpserver.HttpsServer"
    },
    "FieldTypes": {
      "server": "com.sun.net.httpserver.HttpServer",
      "service": "java.util.concurrent.ExecutorService",
      "handlers": "java.util.LinkedHashMap",
      "keystore": "java.io.File",
      "truststore": "java.io.File"
    }
  },
  "ribbon\\ribbon-loadbalancer\\src\\test\\java\\com\\netflix\\loadbalancer\\BestAvailableRuleTest.java": {
    "TypeDeclarations": [
      "BestAvailableRuleTest"
    ],
    "MethodDeclarations": [
      "BestAvailableRuleTest.testRule()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "withRule",
        "buildFixedServerListLoadBalancer",
        "getSingleServerStat",
        "assertEquals",
        "getSingleServerStat",
        "assertEquals"
      ]
    },
    "Imports": {
      "org.junit.Assert.*": "org.junit.Assert",
      "List": "java.util.List",
      "Test": "org.junit.Test",
      "Lists": "com.google.common.collect.Lists"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\test\\java\\com\\netflix\\loadbalancer\\ConfigurationBasedServerListTest.java": {
    "TypeDeclarations": [
      "ConfigurationBasedServerListTest"
    ],
    "MethodDeclarations": [
      "ConfigurationBasedServerListTest.testList()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "assertTrue",
        "isEmpty",
        "setProperty",
        "assertEquals",
        "setProperty",
        "assertTrue",
        "isEmpty",
        "clearProperty",
        "assertTrue",
        "isEmpty"
      ]
    },
    "Imports": {
      "org.junit.Assert.*": "org.junit.Assert",
      "ArrayList": "java.util.ArrayList",
      "List": "java.util.List",
      "Test": "org.junit.Test",
      "DefaultClientConfigImpl": "com.netflix.client.config.DefaultClientConfigImpl",
      "ConfigurationManager": "com.netflix.config.ConfigurationManager"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\test\\java\\com\\netflix\\loadbalancer\\DynamicServerListLoadBalancerTest.java": {
    "TypeDeclarations": [
      "DynamicServerListLoadBalancerTest",
      "MyServerList"
    ],
    "MethodDeclarations": [
      "MyServerList.getInitialListOfServers()",
      "MyServerList.getUpdatedListOfServers()",
      "MyServerList.initWithNiwsConfig(IClientConfig)",
      "DynamicServerListLoadBalancerTest.testDynamicServerListLoadBalancer()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "com.netflix.client.testutil.MockHttpServer.getServerUrl",
        "java.util.concurrent.atomic.AtomicInteger.incrementAndGet",
        "java.util.concurrent.CountDownLatch.countDown",
        "getName",
        "getName",
        "assertTrue",
        "assertEquals",
        "assertTrue",
        "assertEquals"
      ]
    },
    "Imports": {
      "org.junit.Assert.*": "org.junit.Assert",
      "List": "java.util.List",
      "CountDownLatch": "java.util.concurrent.CountDownLatch",
      "TimeUnit": "java.util.concurrent.TimeUnit",
      "AtomicInteger": "java.util.concurrent.atomic.AtomicInteger",
      "ClassRule": "org.junit.ClassRule",
      "Test": "org.junit.Test",
      "Lists": "com.google.common.collect.Lists",
      "CommonClientConfigKey": "com.netflix.client.config.CommonClientConfigKey",
      "DefaultClientConfigImpl": "com.netflix.client.config.DefaultClientConfigImpl",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "MockHttpServer": "com.netflix.client.testutil.MockHttpServer"
    },
    "FieldTypes": {
      "server": "com.netflix.client.testutil.MockHttpServer",
      "latch": "java.util.concurrent.CountDownLatch",
      "counter": "java.util.concurrent.atomic.AtomicInteger",
      "list": "java.util.List"
    }
  },
  "ribbon\\ribbon-loadbalancer\\src\\test\\java\\com\\netflix\\loadbalancer\\LoadBalancerCommandTest.java": {
    "TypeDeclarations": [
      "LoadBalancerCommandTest"
    ],
    "MethodDeclarations": [
      "LoadBalancerCommandTest.testRetrySameServer()",
      "LoadBalancerCommandTest.testRetryNextServer()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "com.netflix.loadbalancer.reactive.LoadBalancerCommand",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "com.netflix.loadbalancer.reactive.LoadBalancerCommand",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals"
      ],
      "Unresolved": [
        "buildFixedServerListLoadBalancer",
        "withLoadBalancer",
        "withRetryHandler",
        "withServer",
        "build",
        "java.util.concurrent.atomic.AtomicInteger.incrementAndGet",
        "toBlocking",
        "single",
        "getSingleServerStat",
        "getTotalRequestsCount",
        "buildFixedServerListLoadBalancer",
        "java.util.concurrent.atomic.AtomicInteger.incrementAndGet",
        "withLoadBalancer",
        "withRetryHandler",
        "build",
        "toBlocking",
        "single",
        "getSingleServerStat",
        "getTotalRequestsCount"
      ]
    },
    "Imports": {
      "assertEquals": "org.junit.Assert.assertEquals",
      "List": "java.util.List",
      "AtomicInteger": "java.util.concurrent.atomic.AtomicInteger",
      "Test": "org.junit.Test",
      "Observable": "rx.Observable",
      "OnSubscribe": "rx.Observable.OnSubscribe",
      "Subscriber": "rx.Subscriber",
      "Lists": "com.google.common.collect.Lists",
      "RetryHandler": "com.netflix.client.RetryHandler",
      "LoadBalancerCommand": "com.netflix.loadbalancer.reactive.LoadBalancerCommand",
      "ServerOperation": "com.netflix.loadbalancer.reactive.ServerOperation"
    },
    "FieldTypes": {
      "list": "java.util.List",
      "count": "java.util.concurrent.atomic.AtomicInteger"
    }
  },
  "ribbon\\ribbon-loadbalancer\\src\\test\\java\\com\\netflix\\loadbalancer\\LoadBalancerContextTest.java": {
    "TypeDeclarations": [
      "LoadBalancerContextTest",
      "MyLoadBalancerContext"
    ],
    "MethodDeclarations": [
      "LoadBalancerContextTest.testComputeURIWithMixedSchemaLoadBalancer()",
      "LoadBalancerContextTest.testComputeFinalUriWithLoadBalancer()",
      "LoadBalancerContextTest.testEncodedPath()",
      "LoadBalancerContextTest.testPreservesUserInfo()",
      "LoadBalancerContextTest.testQueryWithoutPath()",
      "LoadBalancerContextTest.testEncodedPathAndHostChange()",
      "LoadBalancerContextTest.testEncodedQuery()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals"
      ],
      "Unresolved": []
    },
    "Imports": {
      "assertEquals": "org.junit.Assert.assertEquals",
      "URI": "java.net.URI",
      "URLEncoder": "java.net.URLEncoder",
      "Test": "org.junit.Test",
      "IClientConfig": "com.netflix.client.config.IClientConfig"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\test\\java\\com\\netflix\\loadbalancer\\MockServerList.java": {
    "TypeDeclarations": [
      "MockServerList"
    ],
    "MethodDeclarations": [
      "MockServerList.setServerList(List)",
      "MockServerList.getInitialListOfServers()",
      "MockServerList.getUpdatedListOfServers()",
      "MockServerList.initWithNiwsConfig(IClientConfig)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "List": "java.util.List",
      "Lists": "com.google.common.collect.Lists",
      "IClientConfig": "com.netflix.client.config.IClientConfig"
    },
    "FieldTypes": {
      "serverList": "java.util.List"
    }
  },
  "ribbon\\ribbon-loadbalancer\\src\\test\\java\\com\\netflix\\loadbalancer\\PollingServerListUpdaterTest.java": {
    "TypeDeclarations": [
      "PollingServerListUpdaterTest"
    ],
    "MethodDeclarations": [
      "PollingServerListUpdaterTest.testUpdating()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "org.junit.Assert.assertTrue",
        "org.junit.Assert.assertTrue"
      ],
      "Unresolved": []
    },
    "Imports": {
      "Test": "org.junit.Test",
      "CountDownLatch": "java.util.concurrent.CountDownLatch",
      "TimeUnit": "java.util.concurrent.TimeUnit",
      "AtomicLong": "java.util.concurrent.atomic.AtomicLong",
      "assertTrue": "org.junit.Assert.assertTrue"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\test\\java\\com\\netflix\\loadbalancer\\PredicatesTest.java": {
    "TypeDeclarations": [
      "PredicatesTest"
    ],
    "MethodDeclarations": [
      "PredicatesTest.cleanup()",
      "PredicatesTest.setServerStats(LoadBalancerStats, Object)",
      "PredicatesTest.testAvalabilityPredicate()",
      "PredicatesTest.testAvalabilityPredicateAfterFailure()",
      "PredicatesTest.testZoneAvoidancePredicate()",
      "PredicatesTest.testCompositePredicate()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "PredicatesTest.setServerStats",
        "PredicatesTest.setServerStats",
        "PredicatesTest.setServerStats",
        "PredicatesTest.setServerStats",
        "PredicatesTest.setServerStats"
      ],
      "Unresolved": [
        "setProperty",
        "setProperty",
        "clearProperty",
        "clearProperty",
        "assertFalse",
        "assertTrue",
        "assertEquals",
        "get",
        "assertEquals",
        "assertEquals",
        "get",
        "assertEquals",
        "get",
        "assertEquals",
        "assertFalse",
        "assertTrue",
        "assertTrue",
        "setProperty",
        "build",
        "assertFalse",
        "assertTrue",
        "assertFalse",
        "assertEquals",
        "setFallbackThresholdAsMinimalFilteredNumberOfServers",
        "addFallbackPredicate",
        "build",
        "assertEquals"
      ]
    },
    "Imports": {
      "org.junit.Assert.*": "org.junit.Assert",
      "Arrays": "java.util.Arrays",
      "List": "java.util.List",
      "Map": "java.util.Map",
      "Set": "java.util.Set",
      "AfterClass": "org.junit.AfterClass",
      "Test": "org.junit.Test",
      "Lists": "com.google.common.collect.Lists",
      "Maps": "com.google.common.collect.Maps",
      "Sets": "com.google.common.collect.Sets",
      "ConfigurationManager": "com.netflix.config.ConfigurationManager",
      "ContextKey": "com.netflix.config.DeploymentContext.ContextKey"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\test\\java\\com\\netflix\\loadbalancer\\RandomLBTest.java": {
    "TypeDeclarations": [
      "RandomLBTest",
      "PingFake"
    ],
    "MethodDeclarations": [
      "RandomLBTest.setup()",
      "RandomLBTest.testRoundRobin()",
      "PingFake.isAlive(Server)"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.util.HashMap.put",
        "java.util.HashMap.put",
        "java.util.HashMap.put",
        "java.util.HashMap.put",
        "java.util.HashMap.keySet",
        "java.util.HashMap.get"
      ],
      "UserDefined": [],
      "Unresolved": [
        "assertEquals"
      ]
    },
    "Imports": {
      "org.junit.Assert.*": "org.junit.Assert",
      "HashMap": "java.util.HashMap",
      "HashSet": "java.util.HashSet",
      "Set": "java.util.Set",
      "BeforeClass": "org.junit.BeforeClass",
      "Test": "org.junit.Test"
    },
    "FieldTypes": {
      "isAliveMap": "java.util.HashMap"
    }
  },
  "ribbon\\ribbon-loadbalancer\\src\\test\\java\\com\\netflix\\loadbalancer\\ServerListChangeListenerTest.java": {
    "TypeDeclarations": [
      "ServerListChangeListenerTest"
    ],
    "MethodDeclarations": [
      "ServerListChangeListenerTest.testListener()"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.util.List.isEmpty"
      ],
      "UserDefined": [
        "org.junit.Assert.assertTrue",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals"
      ],
      "Unresolved": []
    },
    "Imports": {
      "assertEquals": "org.junit.Assert.assertEquals",
      "assertTrue": "org.junit.Assert.assertTrue",
      "List": "java.util.List",
      "Test": "org.junit.Test",
      "Lists": "com.google.common.collect.Lists"
    },
    "FieldTypes": {
      "oldList": "java.util.List",
      "newList": "java.util.List"
    }
  },
  "ribbon\\ribbon-loadbalancer\\src\\test\\java\\com\\netflix\\loadbalancer\\ServerListLoabBalancerTest.java": {
    "TypeDeclarations": [
      "ServerListLoabBalancerTest",
      "FixedServerList"
    ],
    "MethodDeclarations": [
      "FixedServerList.initWithNiwsConfig(IClientConfig)",
      "FixedServerList.getInitialListOfServers()",
      "FixedServerList.getUpdatedListOfServers()",
      "ServerListLoabBalancerTest.init()",
      "ServerListLoabBalancerTest.testChooseServer()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "getName",
        "getName",
        "assertNotNull",
        "com.netflix.loadbalancer.DynamicServerListLoadBalancer.chooseServer",
        "assertEquals"
      ]
    },
    "Imports": {
      "org.junit.Assert.*": "org.junit.Assert",
      "Arrays": "java.util.Arrays",
      "HashSet": "java.util.HashSet",
      "List": "java.util.List",
      "Set": "java.util.Set",
      "Configuration": "org.apache.commons.configuration.Configuration",
      "BeforeClass": "org.junit.BeforeClass",
      "Test": "org.junit.Test",
      "ClientFactory": "com.netflix.client.ClientFactory",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "ConfigurationManager": "com.netflix.config.ConfigurationManager",
      "DynamicServerListLoadBalancer": "com.netflix.loadbalancer.DynamicServerListLoadBalancer",
      "Server": "com.netflix.loadbalancer.Server"
    },
    "FieldTypes": {
      "servers": "com.netflix.loadbalancer.Server",
      "serverList": "java.util.List",
      "lb": "com.netflix.loadbalancer.DynamicServerListLoadBalancer"
    }
  },
  "ribbon\\ribbon-loadbalancer\\src\\test\\java\\com\\netflix\\loadbalancer\\ServerStatsTest.java": {
    "TypeDeclarations": [
      "ServerStatsTest"
    ],
    "MethodDeclarations": [
      "ServerStatsTest.testRegisterWithServo()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "org.junit.Assert.*": "org.junit.Assert",
      "Test": "org.junit.Test",
      "Monitors": "com.netflix.servo.monitor.Monitors"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\test\\java\\com\\netflix\\loadbalancer\\ServerStatusChangeListenerTest.java": {
    "TypeDeclarations": [
      "ServerStatusChangeListenerTest",
      "NoPingTaskLoadBalancer"
    ],
    "MethodDeclarations": [
      "NoPingTaskLoadBalancer.setupPingTask()",
      "ServerStatusChangeListenerTest.setupLoadbalancerAndListener()",
      "ServerStatusChangeListenerTest.markServerDownByIdShouldBeReceivedByListener()",
      "ServerStatusChangeListenerTest.markServerDownByObjectShouldBeReceivedByListener()",
      "ServerStatusChangeListenerTest.changeServerStatusByPingShouldBeReceivedByListener()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "java.util.Arrays.asList",
        "org.hamcrest.CoreMatchers.is",
        "java.util.Collections.singletonList",
        "org.hamcrest.CoreMatchers.is",
        "java.util.Collections.singletonList",
        "org.hamcrest.CoreMatchers.is",
        "java.util.Collections.singletonList",
        "org.hamcrest.CoreMatchers.is",
        "java.util.Collections.singletonList",
        "org.hamcrest.core.AllOf.allOf",
        "org.hamcrest.CoreMatchers.hasItem",
        "org.hamcrest.CoreMatchers.hasItem",
        "org.hamcrest.core.AllOf.allOf",
        "org.hamcrest.CoreMatchers.hasItem",
        "org.hamcrest.CoreMatchers.hasItem"
      ],
      "Unresolved": [
        "java.util.concurrent.atomic.AtomicReference.set",
        "assertThat",
        "java.util.concurrent.atomic.AtomicReference.get",
        "assertThat",
        "java.util.concurrent.atomic.AtomicReference.get",
        "assertThat",
        "java.util.concurrent.atomic.AtomicReference.get",
        "assertThat",
        "java.util.concurrent.atomic.AtomicReference.get",
        "assertThat",
        "java.util.concurrent.atomic.AtomicReference.get",
        "java.util.concurrent.atomic.AtomicReference.set",
        "assertFalse",
        "java.util.concurrent.atomic.AtomicReference.get",
        "isEmpty",
        "assertThat",
        "java.util.concurrent.atomic.AtomicReference.get"
      ]
    },
    "Imports": {
      "asList": "java.util.Arrays.asList",
      "singletonList": "java.util.Collections.singletonList",
      "hasItem": "org.hamcrest.CoreMatchers.hasItem",
      "is": "org.hamcrest.CoreMatchers.is",
      "allOf": "org.hamcrest.core.AllOf.allOf",
      "org.junit.Assert.*": "org.junit.Assert",
      "ArrayList": "java.util.ArrayList",
      "Collection": "java.util.Collection",
      "List": "java.util.List",
      "Queue": "java.util.Queue",
      "ConcurrentLinkedQueue": "java.util.concurrent.ConcurrentLinkedQueue",
      "CountDownLatch": "java.util.concurrent.CountDownLatch",
      "TimeUnit": "java.util.concurrent.TimeUnit",
      "AtomicReference": "java.util.concurrent.atomic.AtomicReference",
      "Before": "org.junit.Before",
      "Test": "org.junit.Test"
    },
    "FieldTypes": {
      "serversReceivedByListener": "java.util.concurrent.atomic.AtomicReference"
    }
  },
  "ribbon\\ribbon-loadbalancer\\src\\test\\java\\com\\netflix\\loadbalancer\\ServerTest.java": {
    "TypeDeclarations": [
      "ServerTest"
    ],
    "MethodDeclarations": [
      "ServerTest.createSchemeHost()",
      "ServerTest.createSchemeHostPort()",
      "ServerTest.createSecureSchemeHost()",
      "ServerTest.createSecureSchemeHostPort()",
      "ServerTest.createSecureSchemeHostPortExplicit()",
      "ServerTest.createHost()",
      "ServerTest.createHostPort()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertNull",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertNull",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals"
      ],
      "Unresolved": []
    },
    "Imports": {
      "assertEquals": "org.junit.Assert.assertEquals",
      "assertNull": "org.junit.Assert.assertNull",
      "Test": "org.junit.Test"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\test\\java\\com\\netflix\\loadbalancer\\SimpleRoundRobinLBTest.java": {
    "TypeDeclarations": [
      "SimpleRoundRobinLBTest",
      "PingFake"
    ],
    "MethodDeclarations": [
      "SimpleRoundRobinLBTest.setup()",
      "SimpleRoundRobinLBTest.cleanup()",
      "SimpleRoundRobinLBTest.testAddingServers()",
      "SimpleRoundRobinLBTest.testRoundRobin()",
      "PingFake.isAlive(Server)"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.util.Map.put",
        "java.util.Map.put",
        "java.util.Map.put",
        "java.util.Map.put",
        "java.util.Map.keySet",
        "java.util.Map.keySet",
        "java.util.Map.put",
        "java.lang.equals",
        "java.util.Map.get"
      ],
      "UserDefined": [],
      "Unresolved": [
        "setLevel",
        "setLevel",
        "assertEquals",
        "assertEquals",
        "assertNotNull",
        "assertFalse"
      ]
    },
    "Imports": {
      "org.junit.Assert.*": "org.junit.Assert",
      "ArrayList": "java.util.ArrayList",
      "HashSet": "java.util.HashSet",
      "List": "java.util.List",
      "Map": "java.util.Map",
      "Set": "java.util.Set",
      "ConcurrentHashMap": "java.util.concurrent.ConcurrentHashMap",
      "Level": "org.apache.log4j.Level",
      "LogManager": "org.apache.log4j.LogManager",
      "AfterClass": "org.junit.AfterClass",
      "BeforeClass": "org.junit.BeforeClass",
      "Test": "org.junit.Test"
    },
    "FieldTypes": {
      "isAliveMap": "java.util.Map"
    }
  },
  "ribbon\\ribbon-loadbalancer\\src\\test\\java\\com\\netflix\\loadbalancer\\SimpleRoundRobinWithRetryLBTest.java": {
    "TypeDeclarations": [
      "SimpleRoundRobinWithRetryLBTest",
      "PingFake"
    ],
    "MethodDeclarations": [
      "SimpleRoundRobinWithRetryLBTest.setup()",
      "SimpleRoundRobinWithRetryLBTest.testRoundRobinWithAServerFailure()",
      "PingFake.isAlive(Server)"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.util.HashMap.put",
        "java.util.HashMap.put",
        "java.util.HashMap.put",
        "java.util.HashMap.put",
        "java.util.HashMap.put",
        "java.lang.equals",
        "java.util.HashMap.get"
      ],
      "UserDefined": [],
      "Unresolved": [
        "assertFalse"
      ]
    },
    "Imports": {
      "org.junit.Assert.*": "org.junit.Assert",
      "BeforeClass": "org.junit.BeforeClass",
      "Test": "org.junit.Test",
      "HashMap": "java.util.HashMap"
    },
    "FieldTypes": {
      "isAliveMap": "java.util.HashMap"
    }
  },
  "ribbon\\ribbon-loadbalancer\\src\\test\\java\\com\\netflix\\loadbalancer\\SubsetFilterTest.java": {
    "TypeDeclarations": [
      "SubsetFilterTest",
      "DummyServerStats"
    ],
    "MethodDeclarations": [
      "SubsetFilterTest.init()",
      "SubsetFilterTest.getServersAndStats(LoadBalancerStats, Object)",
      "SubsetFilterTest.testSorting()",
      "SubsetFilterTest.testFiltering()",
      "SubsetFilterTest.testWithLoadBalancer()",
      "DummyServerStats.setActiveRequestsCount(BasicType(dimensions=[], name=int))",
      "DummyServerStats.setConnectionFailureCount(BasicType(dimensions=[], name=int))",
      "DummyServerStats.getActiveRequestsCount()",
      "DummyServerStats.getFailureCount()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertTrue",
        "org.junit.Assert.assertTrue",
        "org.junit.Assert.assertTrue",
        "org.junit.Assert.assertTrue",
        "org.junit.Assert.assertTrue",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertTrue",
        "org.junit.Assert.assertTrue",
        "org.junit.Assert.assertTrue",
        "org.junit.Assert.assertTrue",
        "org.junit.Assert.assertTrue",
        "org.junit.Assert.assertEquals"
      ],
      "Unresolved": [
        "getName",
        "getName",
        "getName",
        "put",
        "getServersAndStats",
        "getHost",
        "getServersAndStats",
        "getServersAndStats"
      ]
    },
    "Imports": {
      "assertEquals": "org.junit.Assert.assertEquals",
      "assertTrue": "org.junit.Assert.assertTrue",
      "Collections": "java.util.Collections",
      "List": "java.util.List",
      "TimeUnit": "java.util.concurrent.TimeUnit",
      "Uninterruptibles": "com.google.common.util.concurrent.Uninterruptibles",
      "Configuration": "org.apache.commons.configuration.Configuration",
      "BeforeClass": "org.junit.BeforeClass",
      "Ignore": "org.junit.Ignore",
      "Test": "org.junit.Test",
      "Lists": "com.google.common.collect.Lists",
      "ClientFactory": "com.netflix.client.ClientFactory",
      "DefaultClientConfigImpl": "com.netflix.client.config.DefaultClientConfigImpl",
      "ConfigurationManager": "com.netflix.config.ConfigurationManager"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\test\\java\\com\\netflix\\loadbalancer\\WeightedResponseTimeRuleTest.java": {
    "TypeDeclarations": [
      "WeightedResponseTimeRuleTest"
    ],
    "MethodDeclarations": [
      "WeightedResponseTimeRuleTest.setUp()",
      "WeightedResponseTimeRuleTest.tearDown()",
      "WeightedResponseTimeRuleTest.shouldNotFailWithIndexOutOfBoundExceptionWhenChoosingServerWhenNumberOfServersIsDecreased()",
      "WeightedResponseTimeRuleTest.waitUntilWeightsAreCalculated()",
      "WeightedResponseTimeRuleTest.setupLoadBalancer(List)",
      "WeightedResponseTimeRuleTest.getLoadBalancerStats(List)",
      "WeightedResponseTimeRuleTest.statsWithResponseTimeAverage(BasicType(dimensions=[], name=double))",
      "WeightedResponseTimeRuleTest.server(String)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "org.mockito.Mockito.mock",
        "WeightedResponseTimeRuleTest.setupLoadBalancer",
        "java.util.Arrays.asList",
        "WeightedResponseTimeRuleTest.server",
        "WeightedResponseTimeRuleTest.server",
        "WeightedResponseTimeRuleTest.server",
        "WeightedResponseTimeRuleTest.waitUntilWeightsAreCalculated",
        "WeightedResponseTimeRuleTest.setupLoadBalancer",
        "java.util.Collections.singletonList",
        "WeightedResponseTimeRuleTest.server",
        "org.junit.Assert.assertNotNull",
        "org.awaitility.Awaitility.await",
        "org.junit.Assert.assertNotEquals",
        "WeightedResponseTimeRuleTest.getLoadBalancerStats",
        "org.mockito.Mockito.when",
        "org.mockito.Mockito.when",
        "org.mockito.Mockito.when",
        "org.mockito.Mockito.mock",
        "WeightedResponseTimeRuleTest.statsWithResponseTimeAverage",
        "org.mockito.Mockito.when",
        "org.mockito.Mockito.mock",
        "org.mockito.Mockito.when"
      ],
      "Unresolved": [
        "untilAsserted",
        "thenReturn",
        "thenReturn",
        "thenReturn",
        "thenReturn",
        "thenReturn"
      ]
    },
    "Imports": {
      "ThrowingRunnable": "org.awaitility.core.ThrowingRunnable",
      "After": "org.junit.After",
      "Before": "org.junit.Before",
      "Test": "org.junit.Test",
      "List": "java.util.List",
      "asList": "java.util.Arrays.asList",
      "singletonList": "java.util.Collections.singletonList",
      "await": "org.awaitility.Awaitility.await",
      "assertNotEquals": "org.junit.Assert.assertNotEquals",
      "assertNotNull": "org.junit.Assert.assertNotNull",
      "mock": "org.mockito.Mockito.mock",
      "when": "org.mockito.Mockito.when"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\test\\java\\com\\netflix\\loadbalancer\\ZoneAwareLoadBalancerTest.java": {
    "TypeDeclarations": [
      "ZoneAwareLoadBalancerTest"
    ],
    "MethodDeclarations": [
      "ZoneAwareLoadBalancerTest.createServer(String, String)",
      "ZoneAwareLoadBalancerTest.createServer(String, BasicType(dimensions=[], name=int), String)",
      "ZoneAwareLoadBalancerTest.createServer(BasicType(dimensions=[], name=int), String)",
      "ZoneAwareLoadBalancerTest.testChooseServer(ZoneAwareLoadBalancer, String)",
      "ZoneAwareLoadBalancerTest.testChooseZone()",
      "ZoneAwareLoadBalancerTest.testZoneOutage()",
      "ZoneAwareLoadBalancerTest.testNonZoneOverride()",
      "ZoneAwareLoadBalancerTest.testAvailabilityFiltering()",
      "ZoneAwareLoadBalancerTest.testConstruction()",
      "ZoneAwareLoadBalancerTest.testActiveConnectionsLimit()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertNotNull",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "org.junit.Assert.assertTrue",
        "org.junit.Assert.assertNotSame",
        "ZoneAwareLoadBalancerTest.testChooseServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "ZoneAwareLoadBalancerTest.testChooseServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "org.junit.Assert.assertEquals",
        "ZoneAwareLoadBalancerTest.createServer",
        "org.junit.Assert.assertEquals",
        "ZoneAwareLoadBalancerTest.testChooseServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "org.junit.Assert.assertEquals",
        "ZoneAwareLoadBalancerTest.testChooseServer",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "ZoneAwareLoadBalancerTest.createServer",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "org.junit.Assert.assertEquals",
        "ZoneAwareLoadBalancerTest.createServer",
        "org.junit.Assert.assertEquals",
        "ZoneAwareLoadBalancerTest.createServer",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "ZoneAwareLoadBalancerTest.testChooseServer",
        "ZoneAwareLoadBalancerTest.testChooseServer",
        "org.junit.Assert.assertNotNull",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.testChooseServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "org.junit.Assert.assertEquals",
        "ZoneAwareLoadBalancerTest.testChooseServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.testChooseServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.testChooseServer",
        "org.junit.Assert.assertNotNull",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.testChooseServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.testChooseServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.testChooseServer",
        "org.junit.Assert.assertNotNull",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.fail",
        "org.junit.Assert.assertEquals",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "org.junit.Assert.assertTrue",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertTrue",
        "org.junit.Assert.assertNotNull",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "ZoneAwareLoadBalancerTest.createServer",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals"
      ],
      "Unresolved": [
        "toLowerCase",
        "setProperty",
        "getRule",
        "getRule",
        "getSuccessiveConnectionFailureCount",
        "getActiveRequestsCount",
        "getSuccessiveConnectionFailureCount",
        "clearProperty",
        "incrementSuccessiveConnectionFailureCount",
        "incrementSuccessiveConnectionFailureCount",
        "incrementSuccessiveConnectionFailureCount",
        "getAllServers",
        "isEmpty",
        "getRule",
        "setProperty",
        "getName",
        "getRule",
        "clearProperty",
        "setProperty",
        "incrementActiveRequestsCount",
        "incrementActiveRequestsCount",
        "incrementSuccessiveConnectionFailureCount",
        "getRule",
        "getRule"
      ]
    },
    "Imports": {
      "assertEquals": "org.junit.Assert.assertEquals",
      "assertNotNull": "org.junit.Assert.assertNotNull",
      "assertNotSame": "org.junit.Assert.assertNotSame",
      "assertTrue": "org.junit.Assert.assertTrue",
      "fail": "org.junit.Assert.fail",
      "ArrayList": "java.util.ArrayList",
      "Arrays": "java.util.Arrays",
      "Collections": "java.util.Collections",
      "HashMap": "java.util.HashMap",
      "HashSet": "java.util.HashSet",
      "List": "java.util.List",
      "Map": "java.util.Map",
      "Set": "java.util.Set",
      "DefaultClientConfigImpl": "com.netflix.client.config.DefaultClientConfigImpl",
      "Ignore": "org.junit.Ignore",
      "Test": "org.junit.Test",
      "ClientFactory": "com.netflix.client.ClientFactory",
      "ConfigurationManager": "com.netflix.config.ConfigurationManager"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-loadbalancer\\src\\test\\java\\com\\netflix\\loadbalancer\\reactive\\ExecutionContextTest.java": {
    "TypeDeclarations": [
      "ExecutionContextTest"
    ],
    "MethodDeclarations": [
      "ExecutionContextTest.testSubContext()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "org.junit.Assert.assertSame",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertNull"
      ],
      "Unresolved": [
        "get"
      ]
    },
    "Imports": {
      "RetryHandler": "com.netflix.client.RetryHandler",
      "DefaultClientConfigImpl": "com.netflix.client.config.DefaultClientConfigImpl",
      "Test": "org.junit.Test",
      "assertEquals": "org.junit.Assert.assertEquals",
      "assertNull": "org.junit.Assert.assertNull",
      "assertSame": "org.junit.Assert.assertSame"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-test\\src\\main\\java\\com\\netflix\\ribbon\\test\\resources\\EmbeddedResources.java": {
    "TypeDeclarations": [
      "EmbeddedResources",
      "Person"
    ],
    "MethodDeclarations": [
      "Person.toString()",
      "Person.hashCode()",
      "Person.equals(Object)",
      "EmbeddedResources.getPerson()",
      "EmbeddedResources.echoContext(String)",
      "EmbeddedResources.getNoEntity()",
      "EmbeddedResources.getReadTimeout()",
      "EmbeddedResources.createPerson(String)",
      "EmbeddedResources.queryPerson(String, BasicType(dimensions=[], name=int))",
      "EmbeddedResources.postWithTimeout(String)",
      "EmbeddedResources.throttle()",
      "EmbeddedResources.getStream()",
      "EmbeddedResources.redirect(BasicType(dimensions=[], name=int))",
      "EmbeddedResources.getEntityStream()"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.lang.getClass",
        "java.util.List.add",
        "java.util.List.add"
      ],
      "UserDefined": [],
      "Unresolved": [
        "org.codehaus.jackson.map.ObjectMapper.writeValueAsString",
        "build",
        "build",
        "build",
        "org.codehaus.jackson.map.ObjectMapper.writeValueAsString",
        "build",
        "org.codehaus.jackson.map.ObjectMapper.readValue",
        "build",
        "org.codehaus.jackson.map.ObjectMapper.writeValueAsString",
        "build",
        "org.codehaus.jackson.map.ObjectMapper.writeValueAsString",
        "build",
        "entity",
        "build",
        "header",
        "build",
        "org.codehaus.jackson.map.ObjectMapper.writeValueAsString"
      ]
    },
    "Imports": {
      "IOException": "java.io.IOException",
      "OutputStream": "java.io.OutputStream",
      "List": "java.util.List",
      "Consumes": "javax.ws.rs.Consumes",
      "GET": "javax.ws.rs.GET",
      "HeaderParam": "javax.ws.rs.HeaderParam",
      "POST": "javax.ws.rs.POST",
      "Path": "javax.ws.rs.Path",
      "Produces": "javax.ws.rs.Produces",
      "QueryParam": "javax.ws.rs.QueryParam",
      "WebApplicationException": "javax.ws.rs.WebApplicationException",
      "MediaType": "javax.ws.rs.core.MediaType",
      "Response": "javax.ws.rs.core.Response",
      "StatusType": "javax.ws.rs.core.Response.StatusType",
      "StreamingOutput": "javax.ws.rs.core.StreamingOutput",
      "ObjectMapper": "org.codehaus.jackson.map.ObjectMapper",
      "Ignore": "org.junit.Ignore",
      "Lists": "com.google.common.collect.Lists"
    },
    "FieldTypes": {
      "mapper": "org.codehaus.jackson.map.ObjectMapper",
      "streamContent": "java.util.List",
      "entityStream": "java.util.List"
    }
  },
  "ribbon\\ribbon-test\\src\\main\\java\\com\\netflix\\ribbon\\testutils\\MockedDiscoveryServerListTest.java": {
    "TypeDeclarations": [
      "MockedDiscoveryServerListTest"
    ],
    "MethodDeclarations": [
      "MockedDiscoveryServerListTest.getMockServerList()",
      "MockedDiscoveryServerListTest.getVipAddress()",
      "MockedDiscoveryServerListTest.getDummyInstanceInfo(String, List)",
      "MockedDiscoveryServerListTest.setupMock()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "MockedDiscoveryServerListTest.getDummyInstanceInfo",
        "MockedDiscoveryServerListTest.getMockServerList",
        "org.powermock.api.easymock.PowerMock.createMock",
        "org.powermock.api.easymock.PowerMock.createMock",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.expect",
        "org.easymock.EasyMock.expect",
        "MockedDiscoveryServerListTest.getVipAddress",
        "org.powermock.api.easymock.PowerMock.replay",
        "org.powermock.api.easymock.PowerMock.replay",
        "org.powermock.api.easymock.PowerMock.replay",
        "org.powermock.api.easymock.PowerMock.replay"
      ],
      "Unresolved": [
        "setAppName",
        "setHostName",
        "setPort",
        "setDataCenterInfo",
        "build",
        "andReturn",
        "anyTimes",
        "andReturn",
        "anyTimes",
        "andReturn",
        "anyTimes",
        "andReturn",
        "anyTimes"
      ]
    },
    "Imports": {
      "DataCenterInfo": "com.netflix.appinfo.DataCenterInfo",
      "InstanceInfo": "com.netflix.appinfo.InstanceInfo",
      "MyDataCenterInfo": "com.netflix.appinfo.MyDataCenterInfo",
      "DefaultEurekaClientConfig": "com.netflix.discovery.DefaultEurekaClientConfig",
      "DiscoveryClient": "com.netflix.discovery.DiscoveryClient",
      "DiscoveryManager": "com.netflix.discovery.DiscoveryManager",
      "Server": "com.netflix.loadbalancer.Server",
      "EasyMock": "org.easymock.EasyMock",
      "Before": "org.junit.Before",
      "Ignore": "org.junit.Ignore",
      "RunWith": "org.junit.runner.RunWith",
      "PowerMock": "org.powermock.api.easymock.PowerMock",
      "PowerMockIgnore": "org.powermock.core.classloader.annotations.PowerMockIgnore",
      "PrepareForTest": "org.powermock.core.classloader.annotations.PrepareForTest",
      "PowerMockRunner": "org.powermock.modules.junit4.PowerMockRunner",
      "ArrayList": "java.util.ArrayList",
      "List": "java.util.List",
      "expect": "org.easymock.EasyMock.expect",
      "createMock": "org.powermock.api.easymock.PowerMock.createMock",
      "replay": "org.powermock.api.easymock.PowerMock.replay"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-test\\src\\main\\java\\com\\netflix\\ribbon\\testutils\\TestUtils.java": {
    "TypeDeclarations": [
      "TestUtils"
    ],
    "MethodDeclarations": [
      "TestUtils.waitUntilTrueOrTimeout(BasicType(dimensions=[], name=int), Func0)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "org.junit.Assert.assertTrue"
      ],
      "Unresolved": [
        "start"
      ]
    },
    "Imports": {
      "assertTrue": "org.junit.Assert.assertTrue",
      "TimeUnit": "java.util.concurrent.TimeUnit",
      "AtomicBoolean": "java.util.concurrent.atomic.AtomicBoolean",
      "Condition": "java.util.concurrent.locks.Condition",
      "Lock": "java.util.concurrent.locks.Lock",
      "ReentrantLock": "java.util.concurrent.locks.ReentrantLock",
      "Func0": "rx.functions.Func0"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-test\\src\\main\\java\\com\\netflix\\serialization\\Deserializer.java": {
    "TypeDeclarations": [
      "Deserializer"
    ],
    "MethodDeclarations": [
      "Deserializer.deserialize(InputStream, TypeDef)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "IOException": "java.io.IOException",
      "InputStream": "java.io.InputStream"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-test\\src\\main\\java\\com\\netflix\\serialization\\JacksonCodec.java": {
    "TypeDeclarations": [
      "JacksonCodec",
      "TypeTokenBasedReference"
    ],
    "MethodDeclarations": [
      "JacksonCodec.deserialize(InputStream, TypeDef)",
      "JacksonCodec.serialize(OutputStream, T, TypeDef)",
      "JacksonCodec.getInstance()",
      "TypeTokenBasedReference.getType()"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.lang.equals"
      ],
      "UserDefined": [],
      "Unresolved": [
        "java.lang.reflect.Type.getRawType",
        "org.codehaus.jackson.map.ObjectMapper.readValue",
        "org.codehaus.jackson.map.ObjectMapper.writeValue",
        "org.codehaus.jackson.map.ObjectMapper.writerWithType"
      ]
    },
    "Imports": {
      "IOException": "java.io.IOException",
      "InputStream": "java.io.InputStream",
      "InputStreamReader": "java.io.InputStreamReader",
      "OutputStream": "java.io.OutputStream",
      "Type": "java.lang.reflect.Type",
      "ObjectMapper": "org.codehaus.jackson.map.ObjectMapper",
      "ObjectWriter": "org.codehaus.jackson.map.ObjectWriter",
      "TypeReference": "org.codehaus.jackson.type.TypeReference",
      "Charsets": "com.google.common.base.Charsets",
      "CharStreams": "com.google.common.io.CharStreams"
    },
    "FieldTypes": {
      "mapper": "org.codehaus.jackson.map.ObjectMapper",
      "type": "java.lang.reflect.Type"
    }
  },
  "ribbon\\ribbon-test\\src\\main\\java\\com\\netflix\\serialization\\SerializationUtils.java": {
    "TypeDeclarations": [
      "SerializationUtils"
    ],
    "MethodDeclarations": [
      "SerializationUtils.deserializeFromString(Deserializer, String, TypeDef)",
      "SerializationUtils.serializeToString(Serializer, T, TypeDef)",
      "SerializationUtils.serializeToBytes(Serializer, T, TypeDef)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "SerializationUtils.serializeToBytes"
      ],
      "Unresolved": []
    },
    "Imports": {
      "ByteArrayInputStream": "java.io.ByteArrayInputStream",
      "ByteArrayOutputStream": "java.io.ByteArrayOutputStream",
      "IOException": "java.io.IOException",
      "Preconditions": "com.google.common.base.Preconditions"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-test\\src\\main\\java\\com\\netflix\\serialization\\Serializer.java": {
    "TypeDeclarations": [
      "Serializer"
    ],
    "MethodDeclarations": [
      "Serializer.serialize(OutputStream, T, TypeDef)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "IOException": "java.io.IOException",
      "OutputStream": "java.io.OutputStream"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-test\\src\\main\\java\\com\\netflix\\serialization\\StringDeserializer.java": {
    "TypeDeclarations": [
      "StringDeserializer"
    ],
    "MethodDeclarations": [
      "StringDeserializer.getInstance()",
      "StringDeserializer.deserialize(InputStream, TypeDef)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "IOException": "java.io.IOException",
      "InputStream": "java.io.InputStream",
      "InputStreamReader": "java.io.InputStreamReader",
      "Charsets": "com.google.common.base.Charsets",
      "CharStreams": "com.google.common.io.CharStreams",
      "Closeables": "com.google.common.io.Closeables"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-test\\src\\main\\java\\com\\netflix\\serialization\\TypeDef.java": {
    "TypeDeclarations": [
      "TypeDef"
    ],
    "MethodDeclarations": [
      "TypeDef.fromClass(Class)",
      "TypeDef.fromType(Type)",
      "TypeDef.getRawType()",
      "TypeDef.getType()"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.lang.getClass"
      ],
      "UserDefined": [
        "com.google.common.base.Preconditions.checkArgument"
      ],
      "Unresolved": [
        "getGenericSuperclass",
        "com.google.common.reflect.TypeToken.getRawType",
        "com.google.common.reflect.TypeToken.getType"
      ]
    },
    "Imports": {
      "checkArgument": "com.google.common.base.Preconditions.checkArgument",
      "ParameterizedType": "java.lang.reflect.ParameterizedType",
      "Type": "java.lang.reflect.Type",
      "TypeToken": "com.google.common.reflect.TypeToken"
    },
    "FieldTypes": {
      "delegate": "com.google.common.reflect.TypeToken"
    }
  },
  "ribbon\\ribbon-transport\\src\\main\\java\\com\\netflix\\ribbon\\RibbonTransportFactory.java": {
    "TypeDeclarations": [
      "RibbonTransportFactory",
      "DefaultRibbonTransportFactory"
    ],
    "MethodDeclarations": [
      "RibbonTransportFactory.newHttpClient(IClientConfig)",
      "RibbonTransportFactory.newTcpClient(IClientConfig)",
      "RibbonTransportFactory.newUdpClient(IClientConfig)",
      "RibbonTransportFactory.newHttpClient(String)",
      "RibbonTransportFactory.newTcpClient(String)",
      "RibbonTransportFactory.newUdpClient(String)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "com.netflix.client.config.ClientConfigFactory.newConfig",
        "newHttpClient",
        "com.netflix.client.config.ClientConfigFactory.newConfig",
        "newTcpClient",
        "com.netflix.client.config.ClientConfigFactory.newConfig",
        "newUdpClient"
      ]
    },
    "Imports": {
      "ClientConfigFactory": "com.netflix.client.config.ClientConfigFactory",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "RibbonTransport": "com.netflix.ribbon.transport.netty.RibbonTransport",
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "DatagramPacket": "io.netty.channel.socket.DatagramPacket",
      "RxClient": "io.reactivex.netty.client.RxClient",
      "HttpClient": "io.reactivex.netty.protocol.http.client.HttpClient",
      "Inject": "javax.inject.Inject"
    },
    "FieldTypes": {
      "clientConfigFactory": "com.netflix.client.config.ClientConfigFactory"
    }
  },
  "ribbon\\ribbon-transport\\src\\main\\java\\com\\netflix\\ribbon\\transport\\netty\\DynamicPropertyBasedPoolStrategy.java": {
    "TypeDeclarations": [
      "DynamicPropertyBasedPoolStrategy"
    ],
    "MethodDeclarations": [
      "DynamicPropertyBasedPoolStrategy.setMaxConnections(BasicType(dimensions=[], name=int))"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "DynamicPropertyBasedPoolStrategy.setMaxConnections",
        "DynamicPropertyBasedPoolStrategy.setMaxConnections"
      ],
      "Unresolved": [
        "com.netflix.config.DynamicProperty.getInteger",
        "com.netflix.config.DynamicProperty.addCallback",
        "com.netflix.config.DynamicProperty.getInteger",
        "getMaxConnections",
        "incrementMaxConnections"
      ]
    },
    "Imports": {
      "DynamicProperty": "com.netflix.config.DynamicProperty",
      "MaxConnectionsBasedStrategy": "io.reactivex.netty.client.MaxConnectionsBasedStrategy"
    },
    "FieldTypes": {
      "poolSizeProperty": "com.netflix.config.DynamicProperty"
    }
  },
  "ribbon\\ribbon-transport\\src\\main\\java\\com\\netflix\\ribbon\\transport\\netty\\LoadBalancingRxClient.java": {
    "TypeDeclarations": [
      "LoadBalancingRxClient"
    ],
    "MethodDeclarations": [
      "LoadBalancingRxClient.getClientConfig()",
      "LoadBalancingRxClient.getResponseTimeOut()",
      "LoadBalancingRxClient.getMaxConcurrentRequests()",
      "LoadBalancingRxClient.getProperty(IClientConfigKey, IClientConfig, S)",
      "LoadBalancingRxClient.getResourceForOptionalProperty(IClientConfigKey)",
      "LoadBalancingRxClient.addLoadBalancerListener()",
      "LoadBalancingRxClient.createRxClient(Server)",
      "LoadBalancingRxClient.getOrCreateRxClient(Server)",
      "LoadBalancingRxClient.removeClient(Server)",
      "LoadBalancingRxClient.connect()",
      "LoadBalancingRxClient.createListener(String)",
      "LoadBalancingRxClient.shutdown()",
      "LoadBalancingRxClient.name()",
      "LoadBalancingRxClient.subscribe(MetricEventsListener)",
      "LoadBalancingRxClient.getLoadBalancerContext()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "LoadBalancingRxClient.createListener",
        "LoadBalancingRxClient.getProperty",
        "LoadBalancingRxClient.getResourceForOptionalProperty",
        "LoadBalancingRxClient.getResourceForOptionalProperty",
        "LoadBalancingRxClient.addLoadBalancerListener",
        "LoadBalancingRxClient.getProperty",
        "LoadBalancingRxClient.getProperty",
        "LoadBalancingRxClient.createRxClient",
        "com.netflix.loadbalancer.reactive.LoadBalancerCommand",
        "LoadBalancingRxClient.getOrCreateRxClient",
        "LoadBalancingRxClient.connect",
        "LoadBalancingRxClient.removeClient"
      ],
      "Unresolved": [
        "withClientConfig",
        "buildLoadBalancerFromConfigWithReflection",
        "com.netflix.client.config.IClientConfig.get",
        "com.netflix.client.config.IClientConfig.get",
        "com.netflix.client.config.IClientConfig.get",
        "com.netflix.client.RetryHandler.getMaxRetriesOnNextServer",
        "com.netflix.client.RetryHandler.getMaxRetriesOnSameServer",
        "com.netflix.client.config.IClientConfig.get",
        "com.netflix.client.config.IClientConfig.get",
        "com.netflix.client.config.IClientConfig.get",
        "com.netflix.client.config.IClientConfig.get",
        "com.netflix.loadbalancer.LoadBalancerContext.getLoadBalancer",
        "com.netflix.loadbalancer.LoadBalancerContext.getLoadBalancer",
        "java.util.concurrent.ConcurrentMap.get",
        "java.util.concurrent.ConcurrentMap.putIfAbsent",
        "java.util.concurrent.ConcurrentMap.remove",
        "withLoadBalancerContext",
        "build",
        "submit",
        "java.util.concurrent.ConcurrentMap.keySet",
        "com.netflix.client.config.IClientConfig.getClientName",
        "io.reactivex.netty.metrics.MetricEventsSubject.subscribe"
      ]
    },
    "Imports": {
      "ObservableConnection": "io.reactivex.netty.channel.ObservableConnection",
      "ClientMetricsEvent": "io.reactivex.netty.client.ClientMetricsEvent",
      "RxClient": "io.reactivex.netty.client.RxClient",
      "MetricEventsListener": "io.reactivex.netty.metrics.MetricEventsListener",
      "MetricEventsSubject": "io.reactivex.netty.metrics.MetricEventsSubject",
      "PipelineConfigurator": "io.reactivex.netty.pipeline.PipelineConfigurator",
      "URL": "java.net.URL",
      "HashSet": "java.util.HashSet",
      "List": "java.util.List",
      "Set": "java.util.Set",
      "ConcurrentHashMap": "java.util.concurrent.ConcurrentHashMap",
      "ConcurrentMap": "java.util.concurrent.ConcurrentMap",
      "Nullable": "javax.annotation.Nullable",
      "Logger": "org.slf4j.Logger",
      "LoggerFactory": "org.slf4j.LoggerFactory",
      "Observable": "rx.Observable",
      "Subscription": "rx.Subscription",
      "RetryHandler": "com.netflix.client.RetryHandler",
      "CommonClientConfigKey": "com.netflix.client.config.CommonClientConfigKey",
      "DefaultClientConfigImpl": "com.netflix.client.config.DefaultClientConfigImpl",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "IClientConfigKey": "com.netflix.client.config.IClientConfigKey",
      "AbstractSslContextFactory": "com.netflix.client.ssl.AbstractSslContextFactory",
      "ClientSslSocketFactoryException": "com.netflix.client.ssl.ClientSslSocketFactoryException",
      "URLSslContextFactory": "com.netflix.client.ssl.URLSslContextFactory",
      "Resources": "com.netflix.client.util.Resources",
      "BaseLoadBalancer": "com.netflix.loadbalancer.BaseLoadBalancer",
      "ILoadBalancer": "com.netflix.loadbalancer.ILoadBalancer",
      "LoadBalancerBuilder": "com.netflix.loadbalancer.LoadBalancerBuilder",
      "LoadBalancerContext": "com.netflix.loadbalancer.LoadBalancerContext",
      "Server": "com.netflix.loadbalancer.Server",
      "ServerListChangeListener": "com.netflix.loadbalancer.ServerListChangeListener",
      "LoadBalancerCommand": "com.netflix.loadbalancer.reactive.LoadBalancerCommand",
      "ServerOperation": "com.netflix.loadbalancer.reactive.ServerOperation"
    },
    "FieldTypes": {
      "logger": "org.slf4j.Logger",
      "rxClientCache": "java.util.concurrent.ConcurrentMap",
      "pipelineConfigurator": "io.reactivex.netty.pipeline.PipelineConfigurator",
      "clientConfig": "com.netflix.client.config.IClientConfig",
      "defaultRetryHandler": "com.netflix.client.RetryHandler",
      "sslContextFactory": "com.netflix.client.ssl.AbstractSslContextFactory",
      "listener": "io.reactivex.netty.metrics.MetricEventsListener",
      "eventSubject": "io.reactivex.netty.metrics.MetricEventsSubject",
      "lbContext": "com.netflix.loadbalancer.LoadBalancerContext"
    }
  },
  "ribbon\\ribbon-transport\\src\\main\\java\\com\\netflix\\ribbon\\transport\\netty\\LoadBalancingRxClientWithPoolOptions.java": {
    "TypeDeclarations": [
      "LoadBalancingRxClientWithPoolOptions"
    ],
    "MethodDeclarations": [
      "LoadBalancingRxClientWithPoolOptions.getPoolStrategy()",
      "LoadBalancingRxClientWithPoolOptions.getConnectionIdleTimeoutMillis()",
      "LoadBalancingRxClientWithPoolOptions.isPoolEnabled()",
      "LoadBalancingRxClientWithPoolOptions.getMaxConcurrentRequests()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "withClientConfig",
        "buildDynamicServerListLoadBalancer",
        "io.reactivex.netty.client.MaxConnectionsBasedStrategy.getMaxConnections"
      ]
    },
    "Imports": {
      "CompositePoolLimitDeterminationStrategy": "io.reactivex.netty.client.CompositePoolLimitDeterminationStrategy",
      "MaxConnectionsBasedStrategy": "io.reactivex.netty.client.MaxConnectionsBasedStrategy",
      "PoolLimitDeterminationStrategy": "io.reactivex.netty.client.PoolLimitDeterminationStrategy",
      "RxClient": "io.reactivex.netty.client.RxClient",
      "PipelineConfigurator": "io.reactivex.netty.pipeline.PipelineConfigurator",
      "ScheduledExecutorService": "java.util.concurrent.ScheduledExecutorService",
      "RetryHandler": "com.netflix.client.RetryHandler",
      "CommonClientConfigKey": "com.netflix.client.config.CommonClientConfigKey",
      "DefaultClientConfigImpl": "com.netflix.client.config.DefaultClientConfigImpl",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "IClientConfigKey": "com.netflix.client.config.IClientConfigKey",
      "Keys": "com.netflix.client.config.IClientConfigKey.Keys",
      "ILoadBalancer": "com.netflix.loadbalancer.ILoadBalancer",
      "LoadBalancerBuilder": "com.netflix.loadbalancer.LoadBalancerBuilder"
    },
    "FieldTypes": {
      "poolStrategy": "io.reactivex.netty.client.CompositePoolLimitDeterminationStrategy",
      "globalStrategy": "io.reactivex.netty.client.MaxConnectionsBasedStrategy",
      "poolCleanerScheduler": "java.util.concurrent.ScheduledExecutorService"
    }
  },
  "ribbon\\ribbon-transport\\src\\main\\java\\com\\netflix\\ribbon\\transport\\netty\\RibbonTransport.java": {
    "TypeDeclarations": [
      "RibbonTransport"
    ],
    "MethodDeclarations": [
      "RibbonTransport.getDefaultHttpRetryHandlerWithConfig(IClientConfig)",
      "RibbonTransport.getDefaultRetryHandlerWithConfig(IClientConfig)",
      "RibbonTransport.newTcpClient(ILoadBalancer, IClientConfig)",
      "RibbonTransport.newTcpClient(ILoadBalancer, PipelineConfigurator, IClientConfig, RetryHandler)",
      "RibbonTransport.newTcpClient(PipelineConfigurator, IClientConfig)",
      "RibbonTransport.newTcpClient(IClientConfig)",
      "RibbonTransport.newUdpClient(ILoadBalancer, IClientConfig)",
      "RibbonTransport.newUdpClient(IClientConfig)",
      "RibbonTransport.newUdpClient(ILoadBalancer, PipelineConfigurator, IClientConfig, RetryHandler)",
      "RibbonTransport.newUdpClient(PipelineConfigurator, IClientConfig)",
      "RibbonTransport.newHttpClient()",
      "RibbonTransport.newHttpClient(ILoadBalancer, IClientConfig)",
      "RibbonTransport.newHttpClient(ILoadBalancer, IClientConfig, RetryHandler)",
      "RibbonTransport.newHttpClient(ILoadBalancer, IClientConfig, RetryHandler, List)",
      "RibbonTransport.newHttpClient(IClientConfig)",
      "RibbonTransport.newHttpClient(ILoadBalancer)",
      "RibbonTransport.newHttpClient(PipelineConfigurator, ILoadBalancer, IClientConfig)",
      "RibbonTransport.newHttpClient(PipelineConfigurator, IClientConfig)",
      "RibbonTransport.newHttpClient(PipelineConfigurator, IClientConfig, RetryHandler)",
      "RibbonTransport.newHttpClient(PipelineConfigurator, ILoadBalancer, IClientConfig, RetryHandler, List)",
      "RibbonTransport.newSSEClient(ILoadBalancer, IClientConfig)",
      "RibbonTransport.newSSEClient(IClientConfig)",
      "RibbonTransport.newSSEClient(PipelineConfigurator, ILoadBalancer, IClientConfig)",
      "RibbonTransport.newSSEClient(PipelineConfigurator, IClientConfig)",
      "RibbonTransport.newSSEClient()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "RibbonTransport.getDefaultRetryHandlerWithConfig",
        "RibbonTransport.getDefaultRetryHandlerWithConfig",
        "RibbonTransport.getDefaultRetryHandlerWithConfig",
        "RibbonTransport.getDefaultRetryHandlerWithConfig",
        "RibbonTransport.getDefaultRetryHandlerWithConfig",
        "RibbonTransport.getDefaultRetryHandlerWithConfig",
        "RibbonTransport.newHttpClient",
        "com.netflix.ribbon.transport.netty.http.LoadBalancingHttpClient",
        "RibbonTransport.getDefaultHttpRetryHandlerWithConfig",
        "com.netflix.ribbon.transport.netty.http.LoadBalancingHttpClient",
        "com.netflix.ribbon.transport.netty.http.LoadBalancingHttpClient",
        "com.netflix.ribbon.transport.netty.http.LoadBalancingHttpClient",
        "RibbonTransport.getDefaultHttpRetryHandlerWithConfig",
        "RibbonTransport.newHttpClient",
        "com.netflix.ribbon.transport.netty.http.LoadBalancingHttpClient",
        "RibbonTransport.getDefaultHttpRetryHandlerWithConfig",
        "com.netflix.ribbon.transport.netty.http.LoadBalancingHttpClient",
        "RibbonTransport.getDefaultHttpRetryHandlerWithConfig",
        "com.netflix.ribbon.transport.netty.http.LoadBalancingHttpClient",
        "com.netflix.ribbon.transport.netty.http.LoadBalancingHttpClient",
        "com.netflix.ribbon.transport.netty.http.SSEClient",
        "RibbonTransport.getDefaultHttpRetryHandlerWithConfig",
        "com.netflix.ribbon.transport.netty.http.SSEClient",
        "RibbonTransport.getDefaultHttpRetryHandlerWithConfig",
        "com.netflix.ribbon.transport.netty.http.SSEClient",
        "RibbonTransport.getDefaultHttpRetryHandlerWithConfig",
        "com.netflix.ribbon.transport.netty.http.SSEClient",
        "RibbonTransport.getDefaultHttpRetryHandlerWithConfig",
        "RibbonTransport.newSSEClient"
      ],
      "Unresolved": [
        "setDaemon",
        "setNameFormat",
        "build",
        "withLoadBalancer",
        "withClientConfig",
        "withRetryHandler",
        "withPipelineConfigurator",
        "withPoolCleanerScheduler",
        "build",
        "withLoadBalancer",
        "withClientConfig",
        "withRetryHandler",
        "withPipelineConfigurator",
        "withPoolCleanerScheduler",
        "build",
        "withLoadBalancer",
        "withClientConfig",
        "withRetryHandler",
        "withPipelineConfigurator",
        "withPoolCleanerScheduler",
        "withExecutorListeners",
        "build",
        "withClientConfig",
        "withRetryHandler",
        "withPipelineConfigurator",
        "withPoolCleanerScheduler",
        "build",
        "withLoadBalancer",
        "withClientConfig",
        "withRetryHandler",
        "withPipelineConfigurator",
        "withPoolCleanerScheduler",
        "build",
        "withClientConfig",
        "withRetryHandler",
        "withPipelineConfigurator",
        "withPoolCleanerScheduler",
        "build",
        "withClientConfig",
        "withRetryHandler",
        "withPipelineConfigurator",
        "withPoolCleanerScheduler",
        "build",
        "withLoadBalancer",
        "withClientConfig",
        "withRetryHandler",
        "withPipelineConfigurator",
        "withPoolCleanerScheduler",
        "withExecutorListeners",
        "build",
        "withLoadBalancer",
        "withClientConfig",
        "withRetryHandler",
        "withPipelineConfigurator",
        "build",
        "withClientConfig",
        "withRetryHandler",
        "withPipelineConfigurator",
        "build",
        "withLoadBalancer",
        "withClientConfig",
        "withRetryHandler",
        "withPipelineConfigurator",
        "build",
        "withClientConfig",
        "withRetryHandler",
        "withPipelineConfigurator",
        "build"
      ]
    },
    "Imports": {
      "ThreadFactoryBuilder": "com.google.common.util.concurrent.ThreadFactoryBuilder",
      "DefaultLoadBalancerRetryHandler": "com.netflix.client.DefaultLoadBalancerRetryHandler",
      "ExecutionListener": "com.netflix.loadbalancer.reactive.ExecutionListener",
      "RetryHandler": "com.netflix.client.RetryHandler",
      "DefaultClientConfigImpl": "com.netflix.client.config.DefaultClientConfigImpl",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "LoadBalancingHttpClient": "com.netflix.ribbon.transport.netty.http.LoadBalancingHttpClient",
      "NettyHttpLoadBalancerErrorHandler": "com.netflix.ribbon.transport.netty.http.NettyHttpLoadBalancerErrorHandler",
      "SSEClient": "com.netflix.ribbon.transport.netty.http.SSEClient",
      "LoadBalancingTcpClient": "com.netflix.ribbon.transport.netty.tcp.LoadBalancingTcpClient",
      "LoadBalancingUdpClient": "com.netflix.ribbon.transport.netty.udp.LoadBalancingUdpClient",
      "DynamicIntProperty": "com.netflix.config.DynamicIntProperty",
      "ILoadBalancer": "com.netflix.loadbalancer.ILoadBalancer",
      "ScheduledThreadPoolExectuorWithDynamicSize": "com.netflix.utils.ScheduledThreadPoolExectuorWithDynamicSize",
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "DatagramPacket": "io.netty.channel.socket.DatagramPacket",
      "RxClient": "io.reactivex.netty.client.RxClient",
      "PipelineConfigurator": "io.reactivex.netty.pipeline.PipelineConfigurator",
      "PipelineConfigurators": "io.reactivex.netty.pipeline.PipelineConfigurators",
      "HttpClientRequest": "io.reactivex.netty.protocol.http.client.HttpClientRequest",
      "HttpClientResponse": "io.reactivex.netty.protocol.http.client.HttpClientResponse",
      "ServerSentEvent": "io.reactivex.netty.protocol.text.sse.ServerSentEvent",
      "List": "java.util.List",
      "ScheduledExecutorService": "java.util.concurrent.ScheduledExecutorService",
      "ThreadFactory": "java.util.concurrent.ThreadFactory"
    },
    "FieldTypes": {
      "DEFAULT_SSE_PIPELINE_CONFIGURATOR": "io.reactivex.netty.pipeline.PipelineConfigurator",
      "DEFAULT_HTTP_PIPELINE_CONFIGURATOR": "io.reactivex.netty.pipeline.PipelineConfigurator",
      "POOL_CLEANER_CORE_SIZE": "com.netflix.config.DynamicIntProperty",
      "poolCleanerScheduler": "java.util.concurrent.ScheduledExecutorService"
    }
  },
  "ribbon\\ribbon-transport\\src\\main\\java\\com\\netflix\\ribbon\\transport\\netty\\http\\DefaultResponseToErrorPolicy.java": {
    "TypeDeclarations": [
      "DefaultResponseToErrorPolicy"
    ],
    "MethodDeclarations": [
      "DefaultResponseToErrorPolicy.call(HttpClientResponse, Integer)"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.lang.equals",
        "java.lang.equals",
        "java.lang.equals",
        "java.lang.equals"
      ],
      "UserDefined": [],
      "Unresolved": [
        "concatMap"
      ]
    },
    "Imports": {
      "HttpResponseStatus": "io.netty.handler.codec.http.HttpResponseStatus",
      "HttpClientResponse": "io.reactivex.netty.protocol.http.client.HttpClientResponse",
      "TimeUnit": "java.util.concurrent.TimeUnit",
      "Observable": "rx.Observable",
      "Func1": "rx.functions.Func1",
      "Func2": "rx.functions.Func2",
      "ClientException": "com.netflix.client.ClientException"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-transport\\src\\main\\java\\com\\netflix\\ribbon\\transport\\netty\\http\\LoadBalancingHttpClient.java": {
    "TypeDeclarations": [
      "LoadBalancingHttpClient",
      "Builder"
    ],
    "MethodDeclarations": [
      "Builder.withLoadBalancer(ILoadBalancer)",
      "Builder.withClientConfig(IClientConfig)",
      "Builder.withRetryHandler(RetryHandler)",
      "Builder.withPipelineConfigurator(PipelineConfigurator)",
      "Builder.withPoolCleanerScheduler(ScheduledExecutorService)",
      "Builder.withExecutorListeners(List)",
      "Builder.withResponseToErrorPolicy(Func2)",
      "Builder.withBackoffStrategy(Func1)",
      "Builder.build()",
      "LoadBalancingHttpClient.builder()",
      "LoadBalancingHttpClient.getRequestRetryHandler(HttpClientRequest, IClientConfig)",
      "LoadBalancingHttpClient.setHostHeader(HttpClientRequest, String)",
      "LoadBalancingHttpClient.submit(HttpClientRequest)",
      "LoadBalancingHttpClient.submit(HttpClientRequest, ClientConfig)",
      "LoadBalancingHttpClient.submit(Server, HttpClientRequest, IClientConfig)",
      "LoadBalancingHttpClient.submit(HttpClientRequest, RetryHandler, IClientConfig)",
      "LoadBalancingHttpClient.submit(Server, HttpClientRequest)",
      "LoadBalancingHttpClient.requestToOperation(HttpClientRequest, ClientConfig)",
      "LoadBalancingHttpClient.getRxClientConfig(IClientConfig)",
      "LoadBalancingHttpClient.getRxClientConfig(IClientConfig, ClientConfig)",
      "LoadBalancingHttpClient.getRibbonClientConfig(ClientConfig)",
      "LoadBalancingHttpClient.submit(Server, HttpClientRequest, RetryHandler, IClientConfig, ClientConfig)",
      "LoadBalancingHttpClient.getServerStats(Server)",
      "LoadBalancingHttpClient.submitToServerInURI(HttpClientRequest, IClientConfig, ClientConfig, RetryHandler, ExecutionContext)",
      "LoadBalancingHttpClient.createRxClient(Server)",
      "LoadBalancingHttpClient.getListener()",
      "LoadBalancingHttpClient.getRxClients()",
      "LoadBalancingHttpClient.createListener(String)"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.lang.equals"
      ],
      "UserDefined": [
        "Builder.withClientConfig",
        "java.util.Collections",
        "com.netflix.loadbalancer.reactive.LoadBalancerCommand",
        "Builder.withClientConfig",
        "Builder.withRetryHandler",
        "Builder.build",
        "Builder.build",
        "com.netflix.loadbalancer.reactive.LoadBalancerCommand",
        "Builder.withClientConfig",
        "Builder.withRetryHandler",
        "Builder.build",
        "com.netflix.loadbalancer.reactive.LoadBalancerCommand",
        "Builder.withRetryHandler",
        "Builder.build",
        "io.reactivex.netty.contexts.RxContexts",
        "io.reactivex.netty.contexts.RxContexts"
      ],
      "Unresolved": [
        "buildLoadBalancerFromConfigWithReflection",
        "com.netflix.client.config.IClientConfig.getOrDefault",
        "rx.functions.Func1.call",
        "getProperty",
        "withLoadBalancerContext",
        "withListeners",
        "set",
        "submit",
        "submit",
        "submit",
        "getRxClientConfig",
        "submit",
        "submit",
        "getRxClientConfig",
        "getOrCreateRxClient",
        "setHostHeader",
        "code",
        "code",
        "rx.functions.Func2.call",
        "rx.functions.Func1.call",
        "java.util.concurrent.atomic.AtomicInteger.getAndIncrement",
        "getProperty",
        "getProperty",
        "readTimeout",
        "getRxClientConfig",
        "withReadTimeout",
        "getRequestRetryHandler",
        "getClientConfig",
        "submitToServerInURI",
        "withExecutionContext",
        "withLoadBalancerContext",
        "withListeners",
        "getClientConfig",
        "withServer",
        "requestToOperation",
        "getRxClientConfig",
        "withLoadBalancerContext",
        "withListeners",
        "withExecutionContext",
        "withServer",
        "submit",
        "requestToOperation",
        "getRxClientConfig",
        "getProperty",
        "getProperty",
        "getProperty",
        "readTimeout",
        "config",
        "isPoolEnabled",
        "withIdleConnectionsTimeoutMillis",
        "withPoolIdleCleanupScheduler"
      ]
    },
    "Imports": {
      "ByteBufAllocator": "io.netty.buffer.ByteBufAllocator",
      "ChannelOption": "io.netty.channel.ChannelOption",
      "HttpHeaders": "io.netty.handler.codec.http.HttpHeaders",
      "HttpMethod": "io.netty.handler.codec.http.HttpMethod",
      "ClientMetricsEvent": "io.reactivex.netty.client.ClientMetricsEvent",
      "CompositePoolLimitDeterminationStrategy": "io.reactivex.netty.client.CompositePoolLimitDeterminationStrategy",
      "RxClient": "io.reactivex.netty.client.RxClient",
      "RxContexts": "io.reactivex.netty.contexts.RxContexts",
      "HttpRequestIdProvider": "io.reactivex.netty.contexts.http.HttpRequestIdProvider",
      "MetricEventsListener": "io.reactivex.netty.metrics.MetricEventsListener",
      "PipelineConfigurator": "io.reactivex.netty.pipeline.PipelineConfigurator",
      "DefaultFactories": "io.reactivex.netty.pipeline.ssl.DefaultFactories",
      "SSLEngineFactory": "io.reactivex.netty.pipeline.ssl.SSLEngineFactory",
      "HttpClient": "io.reactivex.netty.protocol.http.client.HttpClient",
      "HttpClientBuilder": "io.reactivex.netty.protocol.http.client.HttpClientBuilder",
      "HttpClientRequest": "io.reactivex.netty.protocol.http.client.HttpClientRequest",
      "HttpClientResponse": "io.reactivex.netty.protocol.http.client.HttpClientResponse",
      "HttpClientListener": "io.reactivex.netty.servo.http.HttpClientListener",
      "URI": "java.net.URI",
      "URISyntaxException": "java.net.URISyntaxException",
      "Collections": "java.util.Collections",
      "List": "java.util.List",
      "Map": "java.util.Map",
      "Optional": "java.util.Optional",
      "CopyOnWriteArrayList": "java.util.concurrent.CopyOnWriteArrayList",
      "ScheduledExecutorService": "java.util.concurrent.ScheduledExecutorService",
      "TimeUnit": "java.util.concurrent.TimeUnit",
      "AtomicInteger": "java.util.concurrent.atomic.AtomicInteger",
      "SSLEngine": "javax.net.ssl.SSLEngine",
      "Observable": "rx.Observable",
      "Func1": "rx.functions.Func1",
      "Func2": "rx.functions.Func2",
      "VisibleForTesting": "com.google.common.annotations.VisibleForTesting",
      "Preconditions": "com.google.common.base.Preconditions",
      "RequestSpecificRetryHandler": "com.netflix.client.RequestSpecificRetryHandler",
      "RetryHandler": "com.netflix.client.RetryHandler",
      "CommonClientConfigKey": "com.netflix.client.config.CommonClientConfigKey",
      "DefaultClientConfigImpl": "com.netflix.client.config.DefaultClientConfigImpl",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "IClientConfigKey": "com.netflix.client.config.IClientConfigKey",
      "ClientSslSocketFactoryException": "com.netflix.client.ssl.ClientSslSocketFactoryException",
      "ILoadBalancer": "com.netflix.loadbalancer.ILoadBalancer",
      "LoadBalancerBuilder": "com.netflix.loadbalancer.LoadBalancerBuilder",
      "Server": "com.netflix.loadbalancer.Server",
      "ServerStats": "com.netflix.loadbalancer.ServerStats",
      "ExecutionContext": "com.netflix.loadbalancer.reactive.ExecutionContext",
      "ExecutionListener": "com.netflix.loadbalancer.reactive.ExecutionListener",
      "LoadBalancerCommand": "com.netflix.loadbalancer.reactive.LoadBalancerCommand",
      "ServerOperation": "com.netflix.loadbalancer.reactive.ServerOperation",
      "LoadBalancingRxClientWithPoolOptions": "com.netflix.ribbon.transport.netty.LoadBalancingRxClientWithPoolOptions"
    },
    "FieldTypes": {
      "requestIdProvider": "io.reactivex.netty.contexts.http.HttpRequestIdProvider",
      "listeners": "java.util.List",
      "defaultCommandBuilder": "com.netflix.loadbalancer.reactive.LoadBalancerCommand",
      "responseToErrorPolicy": "rx.functions.Func2",
      "backoffStrategy": "rx.functions.Func1",
      "lb": "com.netflix.loadbalancer.ILoadBalancer",
      "config": "com.netflix.client.config.IClientConfig",
      "retryHandler": "com.netflix.client.RetryHandler",
      "pipelineConfigurator": "io.reactivex.netty.pipeline.PipelineConfigurator",
      "poolCleanerScheduler": "java.util.concurrent.ScheduledExecutorService",
      "build": "rx.functions.Func1",
      "count": "java.util.concurrent.atomic.AtomicInteger"
    }
  },
  "ribbon\\ribbon-transport\\src\\main\\java\\com\\netflix\\ribbon\\transport\\netty\\http\\NettyHttpLoadBalancerErrorHandler.java": {
    "TypeDeclarations": [
      "NettyHttpLoadBalancerErrorHandler"
    ],
    "MethodDeclarations": [
      "NettyHttpLoadBalancerErrorHandler.isCircuitTrippingException(Throwable)",
      "NettyHttpLoadBalancerErrorHandler.isRetriableException(Throwable, BasicType(dimensions=[], name=boolean))",
      "NettyHttpLoadBalancerErrorHandler.getRetriableExceptions()",
      "NettyHttpLoadBalancerErrorHandler.getCircuitRelatedExceptions()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "com.google.common.collect.Lists",
        "com.google.common.collect.Lists"
      ],
      "Unresolved": []
    },
    "Imports": {
      "ConnectException": "java.net.ConnectException",
      "SocketException": "java.net.SocketException",
      "SocketTimeoutException": "java.net.SocketTimeoutException",
      "List": "java.util.List",
      "Lists": "com.google.common.collect.Lists",
      "ClientException": "com.netflix.client.ClientException",
      "DefaultLoadBalancerRetryHandler": "com.netflix.client.DefaultLoadBalancerRetryHandler",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "UnexpectedHttpResponseException": "com.netflix.client.http.UnexpectedHttpResponseException"
    },
    "FieldTypes": {
      "retriable": "java.util.List",
      "circuitRelated": "java.util.List"
    }
  },
  "ribbon\\ribbon-transport\\src\\main\\java\\com\\netflix\\ribbon\\transport\\netty\\http\\SSEClient.java": {
    "TypeDeclarations": [
      "SSEClient"
    ],
    "MethodDeclarations": [
      "SSEClient.sseClientBuilder()",
      "SSEClient.getOrCreateRxClient(Server)",
      "SSEClient.shutdown()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "pipelineConfigurator",
        "getProperty",
        "build",
        "config",
        "build"
      ]
    },
    "Imports": {
      "ChannelOption": "io.netty.channel.ChannelOption",
      "RxClient": "io.reactivex.netty.client.RxClient",
      "HttpClient": "io.reactivex.netty.protocol.http.client.HttpClient",
      "HttpClientBuilder": "io.reactivex.netty.protocol.http.client.HttpClientBuilder",
      "ServerSentEvent": "io.reactivex.netty.protocol.text.sse.ServerSentEvent",
      "Func1": "rx.functions.Func1",
      "DefaultClientConfigImpl": "com.netflix.client.config.DefaultClientConfigImpl",
      "IClientConfigKey": "com.netflix.client.config.IClientConfigKey",
      "Server": "com.netflix.loadbalancer.Server"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-transport\\src\\main\\java\\com\\netflix\\ribbon\\transport\\netty\\tcp\\LoadBalancingTcpClient.java": {
    "TypeDeclarations": [
      "LoadBalancingTcpClient"
    ],
    "MethodDeclarations": [
      "LoadBalancingTcpClient.createRxClient(Server)",
      "LoadBalancingTcpClient.createListener(String)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "getProperty",
        "isPoolEnabled",
        "withIdleConnectionsTimeoutMillis",
        "withPoolIdleCleanupScheduler"
      ]
    },
    "Imports": {
      "ScheduledExecutorService": "java.util.concurrent.ScheduledExecutorService",
      "ChannelOption": "io.netty.channel.ChannelOption",
      "RxNetty": "io.reactivex.netty.RxNetty",
      "ClientBuilder": "io.reactivex.netty.client.ClientBuilder",
      "ClientMetricsEvent": "io.reactivex.netty.client.ClientMetricsEvent",
      "RxClient": "io.reactivex.netty.client.RxClient",
      "MetricEventsListener": "io.reactivex.netty.metrics.MetricEventsListener",
      "PipelineConfigurator": "io.reactivex.netty.pipeline.PipelineConfigurator",
      "TcpClientListener": "io.reactivex.netty.servo.tcp.TcpClientListener",
      "RetryHandler": "com.netflix.client.RetryHandler",
      "DefaultClientConfigImpl": "com.netflix.client.config.DefaultClientConfigImpl",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "IClientConfigKey": "com.netflix.client.config.IClientConfigKey",
      "LoadBalancingRxClientWithPoolOptions": "com.netflix.ribbon.transport.netty.LoadBalancingRxClientWithPoolOptions",
      "ILoadBalancer": "com.netflix.loadbalancer.ILoadBalancer",
      "Server": "com.netflix.loadbalancer.Server"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-transport\\src\\main\\java\\com\\netflix\\ribbon\\transport\\netty\\udp\\LoadBalancingUdpClient.java": {
    "TypeDeclarations": [
      "LoadBalancingUdpClient"
    ],
    "MethodDeclarations": [
      "LoadBalancingUdpClient.createRxClient(Server)",
      "LoadBalancingUdpClient.createListener(String)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": []
    },
    "Imports": {
      "RetryHandler": "com.netflix.client.RetryHandler",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "LoadBalancingRxClient": "com.netflix.ribbon.transport.netty.LoadBalancingRxClient",
      "ILoadBalancer": "com.netflix.loadbalancer.ILoadBalancer",
      "Server": "com.netflix.loadbalancer.Server",
      "RxNetty": "io.reactivex.netty.RxNetty",
      "ClientMetricsEvent": "io.reactivex.netty.client.ClientMetricsEvent",
      "RxClient": "io.reactivex.netty.client.RxClient",
      "MetricEventsListener": "io.reactivex.netty.metrics.MetricEventsListener",
      "PipelineConfigurator": "io.reactivex.netty.pipeline.PipelineConfigurator",
      "UdpClientBuilder": "io.reactivex.netty.protocol.udp.client.UdpClientBuilder",
      "UdpClientListener": "io.reactivex.netty.servo.udp.UdpClientListener"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-transport\\src\\test\\java\\com\\netflix\\client\\netty\\udp\\HelloUdpServerExternalResource.java": {
    "TypeDeclarations": [
      "HelloUdpServerExternalResource"
    ],
    "MethodDeclarations": [
      "HelloUdpServerExternalResource.choosePort()",
      "HelloUdpServerExternalResource.setTimeout(BasicType(dimensions=[], name=int))",
      "HelloUdpServerExternalResource.start()",
      "HelloUdpServerExternalResource.after()",
      "HelloUdpServerExternalResource.getServerPort()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "HelloUdpServerExternalResource.choosePort"
      ],
      "Unresolved": [
        "flatMap",
        "take",
        "flatMap",
        "org.slf4j.Logger.info",
        "alloc",
        "buffer",
        "io.reactivex.netty.protocol.udp.server.UdpServer.start",
        "org.slf4j.Logger.info",
        "io.reactivex.netty.protocol.udp.server.UdpServer.shutdown",
        "org.slf4j.Logger.error",
        "io.reactivex.netty.protocol.udp.server.UdpServer.getServerPort"
      ]
    },
    "Imports": {
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "DatagramPacket": "io.netty.channel.socket.DatagramPacket",
      "RxNetty": "io.reactivex.netty.RxNetty",
      "ConnectionHandler": "io.reactivex.netty.channel.ConnectionHandler",
      "ObservableConnection": "io.reactivex.netty.channel.ObservableConnection",
      "UdpServer": "io.reactivex.netty.protocol.udp.server.UdpServer",
      "DatagramSocket": "java.net.DatagramSocket",
      "InetSocketAddress": "java.net.InetSocketAddress",
      "SocketException": "java.net.SocketException",
      "Charset": "java.nio.charset.Charset",
      "TimeUnit": "java.util.concurrent.TimeUnit",
      "ExternalResource": "org.junit.rules.ExternalResource",
      "Logger": "org.slf4j.Logger",
      "LoggerFactory": "org.slf4j.LoggerFactory",
      "Observable": "rx.Observable",
      "Func1": "rx.functions.Func1"
    },
    "FieldTypes": {
      "LOG": "org.slf4j.Logger",
      "server": "io.reactivex.netty.protocol.udp.server.UdpServer"
    }
  },
  "ribbon\\ribbon-transport\\src\\test\\java\\com\\netflix\\ribbon\\transport\\netty\\DynamicPropertyBasedPoolStrategyTest.java": {
    "TypeDeclarations": [
      "DynamicPropertyBasedPoolStrategyTest"
    ],
    "MethodDeclarations": [
      "DynamicPropertyBasedPoolStrategyTest.testResize()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [],
      "Unresolved": [
        "setProperty",
        "assertEquals",
        "setProperty",
        "assertEquals",
        "setProperty",
        "assertEquals"
      ]
    },
    "Imports": {
      "org.junit.Assert.*": "org.junit.Assert",
      "Test": "org.junit.Test",
      "ConfigurationManager": "com.netflix.config.ConfigurationManager"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-transport\\src\\test\\java\\com\\netflix\\ribbon\\transport\\netty\\MyUDPClient.java": {
    "TypeDeclarations": [
      "MyUDPClient",
      "MyRetryHandler"
    ],
    "MethodDeclarations": [
      "MyRetryHandler.getCircuitRelatedExceptions()",
      "MyUDPClient.submit(String)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "com.google.common.collect.Lists",
        "com.netflix.loadbalancer.reactive.LoadBalancerCommand"
      ],
      "Unresolved": [
        "withLoadBalancerContext",
        "build",
        "submit",
        "getOrCreateRxClient",
        "flatMap",
        "timeout",
        "take"
      ]
    },
    "Imports": {
      "Lists": "com.google.common.collect.Lists",
      "DefaultLoadBalancerRetryHandler": "com.netflix.client.DefaultLoadBalancerRetryHandler",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "LoadBalancingUdpClient": "com.netflix.ribbon.transport.netty.udp.LoadBalancingUdpClient",
      "ILoadBalancer": "com.netflix.loadbalancer.ILoadBalancer",
      "LoadBalancerCommand": "com.netflix.loadbalancer.reactive.LoadBalancerCommand",
      "ServerOperation": "com.netflix.loadbalancer.reactive.ServerOperation",
      "Server": "com.netflix.loadbalancer.Server",
      "DatagramPacket": "io.netty.channel.socket.DatagramPacket",
      "ObservableConnection": "io.reactivex.netty.channel.ObservableConnection",
      "RxClient": "io.reactivex.netty.client.RxClient",
      "PipelineConfigurator": "io.reactivex.netty.pipeline.PipelineConfigurator",
      "Observable": "rx.Observable",
      "Func1": "rx.functions.Func1",
      "List": "java.util.List",
      "TimeUnit": "java.util.concurrent.TimeUnit",
      "TimeoutException": "java.util.concurrent.TimeoutException"
    },
    "FieldTypes": {
      "timeoutExceptions": "java.util.List"
    }
  },
  "ribbon\\ribbon-transport\\src\\test\\java\\com\\netflix\\ribbon\\transport\\netty\\http\\DiscoveryLoadBalancerTest.java": {
    "TypeDeclarations": [
      "DiscoveryLoadBalancerTest"
    ],
    "MethodDeclarations": [
      "DiscoveryLoadBalancerTest.getMockServerList()",
      "DiscoveryLoadBalancerTest.getVipAddress()",
      "DiscoveryLoadBalancerTest.testLoadBalancer()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "DiscoveryLoadBalancerTest.getVipAddress",
        "org.junit.Assert.assertEquals",
        "DiscoveryLoadBalancerTest.getMockServerList"
      ],
      "Unresolved": [
        "withDefaultValues",
        "withDeploymentContextBasedVipAddresses",
        "build",
        "set",
        "getName",
        "getAllServers"
      ]
    },
    "Imports": {
      "Lists": "com.google.common.collect.Lists",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "IClientConfigKey": "com.netflix.client.config.IClientConfigKey",
      "RibbonTransport": "com.netflix.ribbon.transport.netty.RibbonTransport",
      "LoadBalancerContext": "com.netflix.loadbalancer.LoadBalancerContext",
      "Server": "com.netflix.loadbalancer.Server",
      "DiscoveryEnabledNIWSServerList": "com.netflix.niws.loadbalancer.DiscoveryEnabledNIWSServerList",
      "MockedDiscoveryServerListTest": "com.netflix.ribbon.testutils.MockedDiscoveryServerListTest",
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "Test": "org.junit.Test",
      "PowerMockIgnore": "org.powermock.core.classloader.annotations.PowerMockIgnore",
      "List": "java.util.List",
      "assertEquals": "org.junit.Assert.assertEquals"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-transport\\src\\test\\java\\com\\netflix\\ribbon\\transport\\netty\\http\\ListenerTest.java": {
    "TypeDeclarations": [
      "ListenerTest"
    ],
    "MethodDeclarations": [
      "ListenerTest.testFailedExecution()",
      "ListenerTest.testFailedExecutionForAbsoluteURI()",
      "ListenerTest.testSuccessExecution()",
      "ListenerTest.testSuccessExecutionOnAbosoluteURI()",
      "ListenerTest.testAbortedExecution()",
      "ListenerTest.testAbortedExecutionOnServer()",
      "ListenerTest.testDisabledListener()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "com.netflix.loadbalancer.LoadBalancerBuilder",
        "com.google.common.collect.Lists",
        "com.netflix.loadbalancer.LoadBalancerBuilder",
        "com.google.common.collect.Lists",
        "com.netflix.loadbalancer.LoadBalancerBuilder",
        "com.google.common.collect.Lists",
        "com.netflix.loadbalancer.LoadBalancerBuilder",
        "com.google.common.collect.Lists",
        "com.netflix.loadbalancer.LoadBalancerBuilder",
        "com.google.common.collect.Lists",
        "com.netflix.loadbalancer.LoadBalancerBuilder",
        "com.google.common.collect.Lists"
      ],
      "Unresolved": [
        "withProperty",
        "withProperty",
        "withProperty",
        "withRule",
        "withPing",
        "buildFixedServerListLoadBalancer",
        "toBlocking",
        "last",
        "fail",
        "assertNotNull",
        "assertEquals",
        "assertEquals",
        "assertEquals",
        "assertEquals",
        "assertTrue",
        "assertTrue",
        "assertNotNull",
        "printStackTrace",
        "assertTrue",
        "assertEquals",
        "getClientProperty",
        "intValue",
        "withProperty",
        "withProperty",
        "withProperty",
        "withRule",
        "withPing",
        "buildFixedServerListLoadBalancer",
        "toBlocking",
        "last",
        "fail",
        "assertNotNull",
        "assertEquals",
        "assertEquals",
        "assertEquals",
        "assertEquals",
        "assertTrue",
        "assertTrue",
        "assertTrue",
        "setResponseCode",
        "setHeader",
        "setBody",
        "withProperty",
        "withProperty",
        "withProperty",
        "withRule",
        "withPing",
        "buildFixedServerListLoadBalancer",
        "set",
        "toBlocking",
        "last",
        "assertEquals",
        "code",
        "assertEquals",
        "assertEquals",
        "assertEquals",
        "assertEquals",
        "assertEquals",
        "assertEquals",
        "getClientProperty",
        "intValue",
        "assertTrue",
        "assertTrue",
        "assertSame",
        "setResponseCode",
        "setHeader",
        "setBody",
        "withProperty",
        "withProperty",
        "withProperty",
        "withRule",
        "withPing",
        "buildFixedServerListLoadBalancer",
        "set",
        "toBlocking",
        "last",
        "assertEquals",
        "code",
        "assertEquals",
        "assertEquals",
        "assertEquals",
        "assertEquals",
        "assertEquals",
        "assertEquals",
        "getClientProperty",
        "intValue",
        "assertTrue",
        "assertTrue",
        "assertSame",
        "withProperty",
        "withProperty",
        "withProperty",
        "withRule",
        "withPing",
        "buildFixedServerListLoadBalancer",
        "subscribe",
        "assertTrue",
        "withProperty",
        "withProperty",
        "withProperty",
        "withRule",
        "withPing",
        "buildFixedServerListLoadBalancer",
        "subscribe",
        "assertTrue",
        "withProperty",
        "withProperty",
        "withProperty",
        "withRule",
        "withPing",
        "buildFixedServerListLoadBalancer",
        "set",
        "setProperty",
        "getName",
        "toBlocking",
        "last",
        "assertNotNull",
        "assertEquals",
        "assertEquals",
        "assertEquals",
        "assertEquals",
        "assertEquals",
        "toBlocking",
        "last",
        "assertNotNull",
        "assertEquals",
        "assertEquals",
        "assertEquals",
        "assertEquals",
        "assertEquals"
      ]
    },
    "Imports": {
      "Lists": "com.google.common.collect.Lists",
      "MockResponse": "com.google.mockwebserver.MockResponse",
      "MockWebServer": "com.google.mockwebserver.MockWebServer",
      "ClientException": "com.netflix.client.ClientException",
      "CommonClientConfigKey": "com.netflix.client.config.CommonClientConfigKey",
      "DefaultClientConfigImpl": "com.netflix.client.config.DefaultClientConfigImpl",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "ConfigurationManager": "com.netflix.config.ConfigurationManager",
      "AvailabilityFilteringRule": "com.netflix.loadbalancer.AvailabilityFilteringRule",
      "BaseLoadBalancer": "com.netflix.loadbalancer.BaseLoadBalancer",
      "DummyPing": "com.netflix.loadbalancer.DummyPing",
      "LoadBalancerBuilder": "com.netflix.loadbalancer.LoadBalancerBuilder",
      "Server": "com.netflix.loadbalancer.Server",
      "ExecutionContext": "com.netflix.loadbalancer.reactive.ExecutionContext",
      "ExecutionInfo": "com.netflix.loadbalancer.reactive.ExecutionInfo",
      "ExecutionListener": "com.netflix.loadbalancer.reactive.ExecutionListener",
      "AbortExecutionException": "com.netflix.loadbalancer.reactive.ExecutionListener.AbortExecutionException",
      "RibbonTransport": "com.netflix.ribbon.transport.netty.RibbonTransport",
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "HttpClientRequest": "io.reactivex.netty.protocol.http.client.HttpClientRequest",
      "HttpClientResponse": "io.reactivex.netty.protocol.http.client.HttpClientResponse",
      "Ignore": "org.junit.Ignore",
      "Test": "org.junit.Test",
      "Action1": "rx.functions.Action1",
      "IOException": "java.io.IOException",
      "Arrays": "java.util.Arrays",
      "List": "java.util.List",
      "CountDownLatch": "java.util.concurrent.CountDownLatch",
      "TimeUnit": "java.util.concurrent.TimeUnit",
      "AtomicReference": "java.util.concurrent.atomic.AtomicReference",
      "org.junit.Assert.*": "org.junit.Assert"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-transport\\src\\test\\java\\com\\netflix\\ribbon\\transport\\netty\\http\\NettyClientTest.java": {
    "TypeDeclarations": [
      "NettyClientTest"
    ],
    "MethodDeclarations": [
      "NettyClientTest.transformSSE(Observable)",
      "NettyClientTest.init()",
      "NettyClientTest.getPersonObservable(Observable)",
      "NettyClientTest.testObservable()",
      "NettyClientTest.testSubmitToAbsoluteURI()",
      "NettyClientTest.testPoolReuse()",
      "NettyClientTest.testPostWithObservable()",
      "NettyClientTest.testPostWithByteBuf()",
      "NettyClientTest.testConnectTimeout()",
      "NettyClientTest.testReadTimeout()",
      "NettyClientTest.testObservableWithMultipleServers()",
      "NettyClientTest.testObservableWithMultipleServersWithOverrideRxConfig()",
      "NettyClientTest.testObservableWithRetrySameServer()",
      "NettyClientTest.testLoadBalancingObservablesWithReadTimeout()",
      "NettyClientTest.testLoadBalancingWithTwoServers()",
      "NettyClientTest.testLoadBalancingPostWithReadTimeout()",
      "NettyClientTest.testLoadBalancingPostWithNoRetrySameServer()",
      "NettyClientTest.testObservableWithMultipleServersFailed()",
      "NettyClientTest.getPersonListFromResponse(Observable)",
      "NettyClientTest.getPersonList(Observable)",
      "NettyClientTest.testStream()",
      "NettyClientTest.testStreamWithLoadBalancer()",
      "NettyClientTest.testQuery()",
      "NettyClientTest.testUnexpectedResponse()",
      "NettyClientTest.testLoadBalancerThrottle()",
      "NettyClientTest.testContext()",
      "NettyClientTest.testRedirect()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "org.junit.Assert.fail",
        "com.netflix.serialization.JacksonCodec",
        "NettyClientTest.getPersonObservable",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "com.netflix.ribbon.testutils.TestUtils.waitUntilTrueOrTimeout",
        "NettyClientTest.getPersonObservable",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "com.netflix.ribbon.testutils.TestUtils.waitUntilTrueOrTimeout",
        "NettyClientTest.getPersonObservable",
        "org.junit.Assert.assertEquals",
        "NettyClientTest.getPersonObservable",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "com.netflix.ribbon.testutils.TestUtils.waitUntilTrueOrTimeout",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "java.nio.charset.Charset",
        "NettyClientTest.getPersonObservable",
        "org.junit.Assert.assertEquals",
        "java.nio.charset.Charset",
        "NettyClientTest.getPersonObservable",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertNotNull",
        "org.junit.Assert.assertTrue",
        "org.junit.Assert.assertTrue",
        "com.netflix.loadbalancer.LoadBalancerBuilder",
        "NettyClientTest.getPersonObservable",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "NettyClientTest.getPersonObservable",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "com.netflix.loadbalancer.LoadBalancerBuilder",
        "NettyClientTest.getPersonObservable",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "com.netflix.ribbon.testutils.TestUtils.waitUntilTrueOrTimeout",
        "com.netflix.loadbalancer.LoadBalancerBuilder",
        "NettyClientTest.getPersonObservable",
        "org.junit.Assert.assertNull",
        "org.junit.Assert.assertTrue",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "java.nio.charset.Charset",
        "NettyClientTest.getPersonObservable",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "com.netflix.ribbon.testutils.TestUtils.waitUntilTrueOrTimeout",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "NettyClientTest.getPersonObservable",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "NettyClientTest.getPersonObservable",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "com.netflix.ribbon.testutils.TestUtils.waitUntilTrueOrTimeout",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "java.nio.charset.Charset",
        "NettyClientTest.getPersonObservable",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "java.nio.charset.Charset",
        "NettyClientTest.getPersonObservable",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "NettyClientTest.getPersonObservable",
        "org.junit.Assert.assertNull",
        "org.junit.Assert.assertTrue",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "NettyClientTest.getPersonList",
        "NettyClientTest.transformSSE",
        "com.netflix.serialization.JacksonCodec",
        "NettyClientTest.getPersonListFromResponse",
        "org.junit.Assert.assertEquals",
        "NettyClientTest.getPersonListFromResponse",
        "org.junit.Assert.assertEquals",
        "NettyClientTest.getPersonObservable",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertTrue",
        "org.junit.Assert.assertTrue",
        "java.nio.charset.Charset",
        "java.nio.charset.Charset",
        "org.junit.Assert.assertTrue",
        "org.junit.Assert.assertTrue",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "NettyClientTest.getPersonObservable",
        "org.junit.Assert.assertEquals"
      ],
      "Unresolved": [
        "nextInt",
        "com.sun.net.httpserver.HttpServer.setExecutor",
        "com.sun.net.httpserver.HttpServer.start",
        "map",
        "deserialize",
        "toBlocking",
        "single",
        "toBlocking",
        "single",
        "withDefaultValues",
        "withMaxAutoRetries",
        "withMaxAutoRetriesNextServer",
        "build",
        "toBlocking",
        "single",
        "toBlocking",
        "single",
        "withHeader",
        "withContent",
        "toBlocking",
        "single",
        "withHeader",
        "withHeader",
        "withContent",
        "toBlocking",
        "single",
        "withProperty",
        "withProperty",
        "withProperty",
        "withRule",
        "withPing",
        "buildFixedServerListLoadBalancer",
        "toBlocking",
        "single",
        "toBlocking",
        "single",
        "withProperty",
        "withRule",
        "withPing",
        "buildFixedServerListLoadBalancer",
        "toBlocking",
        "single",
        "withProperty",
        "withRule",
        "withPing",
        "buildFixedServerListLoadBalancer",
        "com.sun.net.httpserver.HttpServer.enqueue",
        "setResponseCode",
        "setHeader",
        "setBody",
        "com.sun.net.httpserver.HttpServer.play",
        "com.sun.net.httpserver.HttpServer.getPort",
        "com.sun.net.httpserver.HttpServer.shutdown",
        "com.sun.net.httpserver.HttpServer.enqueue",
        "setResponseCode",
        "setHeader",
        "setBody",
        "com.sun.net.httpserver.HttpServer.play",
        "withContent",
        "withHeader",
        "com.sun.net.httpserver.HttpServer.getPort",
        "com.sun.net.httpserver.HttpServer.shutdown",
        "com.sun.net.httpserver.HttpServer.enqueue",
        "setResponseCode",
        "setHeader",
        "setBody",
        "com.sun.net.httpserver.HttpServer.play",
        "withContent",
        "withHeader",
        "com.sun.net.httpserver.HttpServer.getPort",
        "com.sun.net.httpserver.HttpServer.shutdown",
        "com.sun.net.httpserver.HttpServer.enqueue",
        "setResponseCode",
        "setHeader",
        "setBody",
        "com.sun.net.httpserver.HttpServer.play",
        "withContent",
        "withHeader",
        "com.sun.net.httpserver.HttpServer.getPort",
        "com.sun.net.httpserver.HttpServer.shutdown",
        "withDefaultValues",
        "withRetryOnAllOperations",
        "withMaxAutoRetries",
        "withMaxAutoRetriesNextServer",
        "withConnectTimeout",
        "build",
        "toBlocking",
        "getIterator",
        "withRetryOnAllOperations",
        "withMaxAutoRetries",
        "withMaxAutoRetriesNextServer",
        "build",
        "toBlocking",
        "single",
        "code",
        "getSuccessiveConnectionFailureCount",
        "map",
        "toBlocking",
        "single",
        "getContext",
        "withDefaultValues",
        "withFollowRedirects",
        "build",
        "toBlocking",
        "single"
      ]
    },
    "Imports": {
      "waitUntilTrueOrTimeout": "com.netflix.ribbon.testutils.TestUtils.waitUntilTrueOrTimeout",
      "assertEquals": "org.junit.Assert.assertEquals",
      "assertNotNull": "org.junit.Assert.assertNotNull",
      "assertNull": "org.junit.Assert.assertNull",
      "assertTrue": "org.junit.Assert.assertTrue",
      "fail": "org.junit.Assert.fail",
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "ByteBufInputStream": "io.netty.buffer.ByteBufInputStream",
      "Unpooled": "io.netty.buffer.Unpooled",
      "ContextsContainer": "io.reactivex.netty.contexts.ContextsContainer",
      "ContextsContainerImpl": "io.reactivex.netty.contexts.ContextsContainerImpl",
      "MapBackedKeySupplier": "io.reactivex.netty.contexts.MapBackedKeySupplier",
      "RxContexts": "io.reactivex.netty.contexts.RxContexts",
      "HttpClientConfig": "io.reactivex.netty.protocol.http.client.HttpClient.HttpClientConfig",
      "HttpClientRequest": "io.reactivex.netty.protocol.http.client.HttpClientRequest",
      "HttpClientResponse": "io.reactivex.netty.protocol.http.client.HttpClientResponse",
      "ServerSentEvent": "io.reactivex.netty.protocol.text.sse.ServerSentEvent",
      "HttpClientListener": "io.reactivex.netty.servo.http.HttpClientListener",
      "IOException": "java.io.IOException",
      "Charset": "java.nio.charset.Charset",
      "Iterator": "java.util.Iterator",
      "List": "java.util.List",
      "Random": "java.util.Random",
      "CountDownLatch": "java.util.concurrent.CountDownLatch",
      "ExecutorService": "java.util.concurrent.ExecutorService",
      "Executors": "java.util.concurrent.Executors",
      "AtomicReference": "java.util.concurrent.atomic.AtomicReference",
      "ObjectMapper": "org.codehaus.jackson.map.ObjectMapper",
      "BeforeClass": "org.junit.BeforeClass",
      "Ignore": "org.junit.Ignore",
      "Test": "org.junit.Test",
      "Observable": "rx.Observable",
      "Action0": "rx.functions.Action0",
      "Action1": "rx.functions.Action1",
      "Func0": "rx.functions.Func0",
      "Func1": "rx.functions.Func1",
      "Lists": "com.google.common.collect.Lists",
      "MockResponse": "com.google.mockwebserver.MockResponse",
      "MockWebServer": "com.google.mockwebserver.MockWebServer",
      "ClientException": "com.netflix.client.ClientException",
      "RequestSpecificRetryHandler": "com.netflix.client.RequestSpecificRetryHandler",
      "RetryHandler": "com.netflix.client.RetryHandler",
      "CommonClientConfigKey": "com.netflix.client.config.CommonClientConfigKey",
      "DefaultClientConfigImpl": "com.netflix.client.config.DefaultClientConfigImpl",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "IClientConfigKey": "com.netflix.client.config.IClientConfigKey",
      "AvailabilityFilteringRule": "com.netflix.loadbalancer.AvailabilityFilteringRule",
      "BaseLoadBalancer": "com.netflix.loadbalancer.BaseLoadBalancer",
      "DummyPing": "com.netflix.loadbalancer.DummyPing",
      "LoadBalancerBuilder": "com.netflix.loadbalancer.LoadBalancerBuilder",
      "Server": "com.netflix.loadbalancer.Server",
      "ServerStats": "com.netflix.loadbalancer.ServerStats",
      "EmbeddedResources": "com.netflix.ribbon.test.resources.EmbeddedResources",
      "Person": "com.netflix.ribbon.test.resources.EmbeddedResources.Person",
      "RibbonTransport": "com.netflix.ribbon.transport.netty.RibbonTransport",
      "JacksonCodec": "com.netflix.serialization.JacksonCodec",
      "SerializationUtils": "com.netflix.serialization.SerializationUtils",
      "TypeDef": "com.netflix.serialization.TypeDef",
      "HttpServerFactory": "com.sun.jersey.api.container.httpserver.HttpServerFactory",
      "PackagesResourceConfig": "com.sun.jersey.api.core.PackagesResourceConfig",
      "HttpServer": "com.sun.net.httpserver.HttpServer"
    },
    "FieldTypes": {
      "server": "com.sun.net.httpserver.HttpServer"
    }
  },
  "ribbon\\ribbon-transport\\src\\test\\java\\com\\netflix\\ribbon\\transport\\netty\\http\\ObserverWithLatch.java": {
    "TypeDeclarations": [
      "ObserverWithLatch"
    ],
    "MethodDeclarations": [
      "ObserverWithLatch.onCompleted()",
      "ObserverWithLatch.onError(Throwable)",
      "ObserverWithLatch.onNext(T)",
      "ObserverWithLatch.await()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "org.junit.Assert.fail",
        "org.junit.Assert.fail"
      ],
      "Unresolved": [
        "java.util.concurrent.CountDownLatch.countDown",
        "java.util.concurrent.atomic.AtomicInteger.incrementAndGet",
        "java.util.concurrent.CountDownLatch.countDown",
        "java.util.concurrent.atomic.AtomicInteger.incrementAndGet",
        "java.util.concurrent.CountDownLatch.await",
        "java.util.concurrent.atomic.AtomicInteger.get",
        "java.util.concurrent.atomic.AtomicInteger.get"
      ]
    },
    "Imports": {
      "Observer": "rx.Observer",
      "CountDownLatch": "java.util.concurrent.CountDownLatch",
      "TimeUnit": "java.util.concurrent.TimeUnit",
      "AtomicInteger": "java.util.concurrent.atomic.AtomicInteger",
      "fail": "org.junit.Assert.fail"
    },
    "FieldTypes": {
      "latch": "java.util.concurrent.CountDownLatch",
      "nextCounter": "java.util.concurrent.atomic.AtomicInteger",
      "errorCounter": "java.util.concurrent.atomic.AtomicInteger"
    }
  },
  "ribbon\\ribbon-transport\\src\\test\\java\\com\\netflix\\ribbon\\transport\\netty\\http\\ServerListRefreshTest.java": {
    "TypeDeclarations": [
      "ServerListRefreshTest"
    ],
    "MethodDeclarations": [
      "ServerListRefreshTest.testServerListRefresh()"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals"
      ],
      "Unresolved": [
        "setResponseCode",
        "setHeader",
        "setBody",
        "toBlocking",
        "last",
        "toBlocking",
        "last",
        "toBlocking",
        "last",
        "keySet",
        "keySet"
      ]
    },
    "Imports": {
      "Lists": "com.google.common.collect.Lists",
      "Sets": "com.google.common.collect.Sets",
      "MockResponse": "com.google.mockwebserver.MockResponse",
      "MockWebServer": "com.google.mockwebserver.MockWebServer",
      "RibbonTransport": "com.netflix.ribbon.transport.netty.RibbonTransport",
      "BaseLoadBalancer": "com.netflix.loadbalancer.BaseLoadBalancer",
      "Server": "com.netflix.loadbalancer.Server",
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "HttpClientRequest": "io.reactivex.netty.protocol.http.client.HttpClientRequest",
      "Test": "org.junit.Test",
      "IOException": "java.io.IOException",
      "List": "java.util.List",
      "Set": "java.util.Set",
      "assertEquals": "org.junit.Assert.assertEquals"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-transport\\src\\test\\java\\com\\netflix\\ribbon\\transport\\netty\\http\\TestExecutionListener.java": {
    "TypeDeclarations": [
      "TestExecutionListener"
    ],
    "MethodDeclarations": [
      "TestExecutionListener.checkContext(ExecutionContext)",
      "TestExecutionListener.checkExecutionInfo(ExecutionInfo)",
      "TestExecutionListener.onExecutionStart(ExecutionContext)",
      "TestExecutionListener.onStartWithServer(ExecutionContext, ExecutionInfo)",
      "TestExecutionListener.onExceptionWithServer(ExecutionContext, Throwable, ExecutionInfo)",
      "TestExecutionListener.onExecutionSuccess(ExecutionContext, HttpClientResponse, ExecutionInfo)",
      "TestExecutionListener.onExecutionFailed(ExecutionContext, Throwable, ExecutionInfo)",
      "TestExecutionListener.isContextChecked()",
      "TestExecutionListener.isCheckExecutionInfo()",
      "TestExecutionListener.getFinalThrowable()",
      "TestExecutionListener.getResponse()",
      "TestExecutionListener.getContext()",
      "TestExecutionListener.toString()"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.util.List.add"
      ],
      "UserDefined": [
        "org.junit.Assert.assertSame",
        "org.junit.Assert.assertSame",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertSame",
        "org.junit.Assert.assertEquals",
        "org.junit.Assert.assertEquals",
        "TestExecutionListener.checkContext",
        "TestExecutionListener.checkContext",
        "TestExecutionListener.checkExecutionInfo",
        "TestExecutionListener.checkContext",
        "TestExecutionListener.checkExecutionInfo",
        "TestExecutionListener.checkContext",
        "TestExecutionListener.checkExecutionInfo",
        "TestExecutionListener.checkContext",
        "TestExecutionListener.checkExecutionInfo"
      ],
      "Unresolved": [
        "com.netflix.loadbalancer.reactive.ExecutionContext.getRequestConfig",
        "com.netflix.loadbalancer.reactive.ExecutionContext.getRequest",
        "com.netflix.loadbalancer.reactive.ExecutionContext.get",
        "java.util.concurrent.atomic.AtomicInteger.get",
        "java.util.concurrent.atomic.AtomicInteger.get",
        "com.netflix.loadbalancer.reactive.ExecutionContext.put",
        "java.util.concurrent.atomic.AtomicInteger.incrementAndGet",
        "com.netflix.loadbalancer.Server.equals",
        "java.util.concurrent.atomic.AtomicInteger.set",
        "java.util.concurrent.atomic.AtomicInteger.incrementAndGet",
        "java.util.concurrent.atomic.AtomicInteger.incrementAndGet",
        "java.util.concurrent.atomic.AtomicInteger.incrementAndGet",
        "java.util.concurrent.atomic.AtomicInteger.incrementAndGet",
        "java.util.concurrent.atomic.AtomicInteger.incrementAndGet",
        "java.util.concurrent.atomic.AtomicInteger.incrementAndGet"
      ]
    },
    "Imports": {
      "ExecutionContext": "com.netflix.loadbalancer.reactive.ExecutionContext",
      "ExecutionInfo": "com.netflix.loadbalancer.reactive.ExecutionInfo",
      "ExecutionListener": "com.netflix.loadbalancer.reactive.ExecutionListener",
      "IClientConfig": "com.netflix.client.config.IClientConfig",
      "Server": "com.netflix.loadbalancer.Server",
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "HttpClientRequest": "io.reactivex.netty.protocol.http.client.HttpClientRequest",
      "HttpClientResponse": "io.reactivex.netty.protocol.http.client.HttpClientResponse",
      "List": "java.util.List",
      "CopyOnWriteArrayList": "java.util.concurrent.CopyOnWriteArrayList",
      "AtomicInteger": "java.util.concurrent.atomic.AtomicInteger",
      "assertEquals": "org.junit.Assert.assertEquals",
      "assertSame": "org.junit.Assert.assertSame"
    },
    "FieldTypes": {
      "executionStartCounter": "java.util.concurrent.atomic.AtomicInteger",
      "startWithServerCounter": "java.util.concurrent.atomic.AtomicInteger",
      "exceptionWithServerCounter": "java.util.concurrent.atomic.AtomicInteger",
      "executionFailedCounter": "java.util.concurrent.atomic.AtomicInteger",
      "executionSuccessCounter": "java.util.concurrent.atomic.AtomicInteger",
      "expectedRequest": "io.reactivex.netty.protocol.http.client.HttpClientRequest",
      "requestConfig": "com.netflix.client.config.IClientConfig",
      "response": "io.reactivex.netty.protocol.http.client.HttpClientResponse",
      "errors": "java.util.List",
      "numAttemptsOnServer": "java.util.concurrent.atomic.AtomicInteger",
      "numServers": "java.util.concurrent.atomic.AtomicInteger",
      "lastServer": "com.netflix.loadbalancer.Server",
      "context": "com.netflix.loadbalancer.reactive.ExecutionContext"
    }
  },
  "ribbon\\ribbon-transport\\src\\test\\java\\com\\netflix\\ribbon\\transport\\netty\\udp\\HelloUdpServer.java": {
    "TypeDeclarations": [
      "HelloUdpServer"
    ],
    "MethodDeclarations": [
      "HelloUdpServer.createServer()",
      "HelloUdpServer.main(String)"
    ],
    "MethodCalls": {
      "StandardLibrary": [],
      "UserDefined": [
        "HelloUdpServer.createServer"
      ],
      "Unresolved": [
        "flatMap",
        "take",
        "flatMap",
        "alloc",
        "buffer",
        "startAndWait"
      ]
    },
    "Imports": {
      "ByteBuf": "io.netty.buffer.ByteBuf",
      "DatagramPacket": "io.netty.channel.socket.DatagramPacket",
      "RxNetty": "io.reactivex.netty.RxNetty",
      "ConnectionHandler": "io.reactivex.netty.channel.ConnectionHandler",
      "ObservableConnection": "io.reactivex.netty.channel.ObservableConnection",
      "UdpServer": "io.reactivex.netty.protocol.udp.server.UdpServer",
      "Observable": "rx.Observable",
      "Func1": "rx.functions.Func1",
      "InetSocketAddress": "java.net.InetSocketAddress",
      "Charset": "java.nio.charset.Charset",
      "TimeUnit": "java.util.concurrent.TimeUnit"
    },
    "FieldTypes": {}
  },
  "ribbon\\ribbon-transport\\src\\test\\java\\com\\netflix\\ribbon\\transport\\netty\\udp\\UdpClientTest.java": {
    "TypeDeclarations": [
      "UdpClientTest"
    ],
    "MethodDeclarations": [
      "UdpClientTest.choosePort()",
      "UdpClientTest.testUdpClientWithoutTimeout()",
      "UdpClientTest.testUdpClientTimeout()"
    ],
    "MethodCalls": {
      "StandardLibrary": [
        "java.lang.toString",
        "java.lang.toString"
      ],
      "UserDefined": [
        "UdpClientTest.choosePort",
        "org.junit.Assert.assertEquals",
        "UdpClientTest.choosePort",
        "org.junit.Assert.fail",
        "org.junit.Assert.assertTrue",
        "org.junit.Assert.assertEquals"
      ],
      "Unresolved": [
        "createServer",
        "flatMap",
        "take",
        "map",
        "toBlocking",
        "first",
        "createServer",
        "map",
        "toBlocking",
        "first",
        "getServerStats",
        "getSuccessiveConnectionFailureCount"
      ]
    },
    "Imports": {
      "Lists": "com.google.common.collect.Lists",
      "DefaultClientConfigImpl": "com.netflix.client.config.DefaultClientConfigImpl",
      "MyUDPClient": "com.netflix.ribbon.transport.netty.MyUDPClient",
      "RibbonTransport": "com.netflix.ribbon.transport.netty.RibbonTransport",
      "BaseLoadBalancer": "com.netflix.loadbalancer.BaseLoadBalancer",
      "Server": "com.netflix.loadbalancer.Server",
      "DatagramPacket": "io.netty.channel.socket.DatagramPacket",
      "ObservableConnection": "io.reactivex.netty.channel.ObservableConnection",
      "RxClient": "io.reactivex.netty.client.RxClient",
      "UdpServer": "io.reactivex.netty.protocol.udp.server.UdpServer",
      "Test": "org.junit.Test",
      "Observable": "rx.Observable",
      "Func1": "rx.functions.Func1",
      "DatagramSocket": "java.net.DatagramSocket",
      "SocketException": "java.net.SocketException",
      "Charset": "java.nio.charset.Charset",
      "TimeoutException": "java.util.concurrent.TimeoutException",
      "assertEquals": "org.junit.Assert.assertEquals",
      "assertTrue": "org.junit.Assert.assertTrue",
      "fail": "org.junit.Assert.fail"
    },
    "FieldTypes": {}
  }
}
